<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CppBoostDay01一、后续11天的安排1、面向对象的设计 3节课左右 2、线程、pc（包括互斥锁与条件）、线程池 3、计算机网络基础（七层协议、TCP&#x2F;UDP）、网编编程socket、IO多路复用、服务器的框架 4、自己实现一个网络框架Reactor 二、面向对象设计的基本概念面向对象的分析（OOA）：分析需要做的需求。 面向对象的设计（OOD）：需要设计那些类、类中设计哪些数据">
<meta property="og:type" content="article">
<meta property="og:title" content="C++提高">
<meta property="og:url" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/index.html">
<meta property="og:site_name" content="李新乾的个人博客">
<meta property="og:description" content="CppBoostDay01一、后续11天的安排1、面向对象的设计 3节课左右 2、线程、pc（包括互斥锁与条件）、线程池 3、计算机网络基础（七层协议、TCP&#x2F;UDP）、网编编程socket、IO多路复用、服务器的框架 4、自己实现一个网络框架Reactor 二、面向对象设计的基本概念面向对象的分析（OOA）：分析需要做的需求。 面向对象的设计（OOD）：需要设计那些类、类中设计哪些数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126154115234.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126155626442.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126160316083.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126160921378.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126161438831.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126162028313.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126164857829.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126171906285.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126172302952.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126173357826.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126173531715.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127091702669.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127091846690.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127092654889.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127092822562.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127101113384.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127101323580.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127103157721.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127104131866.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127104654838.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129092639388.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129094135344.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129104045288.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129104603520.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129110528646.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129111126368.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129112636247.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129151552655.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129151642406.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129151831366.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129161244114.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129161321564.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129161337618.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129161444181.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129171425699.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129171948519.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129173132368.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129173205004.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129174951705.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130095511622.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130104138249.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130114602958.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160430608.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160446429.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160551421.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160742572.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160832357.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160911093.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130161014148.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130161045709.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130161938422.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130161956306.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130162015124.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131090309971.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131090429077.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131090525191.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131090851919.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121341333.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121450861.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121541742.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121624614.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121722958.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121842007.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121947069.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131122158527.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201093230883.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201094211788.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103140624.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103241431.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103332931.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103525474.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103618504.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103804930.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201105425483.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201105651383.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201111121415.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201111639421.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201141719014.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201175645743.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201143120741.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201144448624.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201152949424.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202093905100.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202102423847.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202170954547.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202172235740.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202172527923.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202172958230.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202173619132.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202174052137.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202174205776.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202175506878.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202175440399.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202175520532.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240204115852087.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240204115957833.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240204120028605.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240204120050554.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105315370.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105335943.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105433845.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105450179.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105529011.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105559220.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110540061.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105707573.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105757198.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105829862.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105918402.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105948324.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110153223.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110249423.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110423974.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110445316.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110718716.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110732337.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110822359.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110900509.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110913742.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110931953.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110945743.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205151115502.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205151237286.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205151256789.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205151320549.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205153531133.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205164631152.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205174204399.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205174230633.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205174312922.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112534699.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112746385.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112848465.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112924922.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112959960.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206113049008.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206113145613.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206113206803.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206113312022.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112144927.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240207102012957.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240207112356546-17243977773751.png">
<meta property="article:published_time" content="2024-07-07T04:00:00.000Z">
<meta property="article:modified_time" content="2024-08-23T07:23:06.906Z">
<meta property="article:author" content="李新乾">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126154115234.png">

<link rel="canonical" href="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++提高 | 李新乾的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="李新乾的个人博客" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李新乾的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="李新乾">
      <meta itemprop="description" content="命由我做，福自己求">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李新乾的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++提高
        </h1>

        <div class="post-meta">
	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-07-07T12:00:00+08:00">2024-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-23 15:23:06" itemprop="dateModified" datetime="2024-08-23T15:23:06+08:00">2024-08-23</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="CppBoostDay01"><a href="#CppBoostDay01" class="headerlink" title="CppBoostDay01"></a>CppBoostDay01</h2><h3 id="一、后续11天的安排"><a href="#一、后续11天的安排" class="headerlink" title="一、后续11天的安排"></a>一、后续11天的安排</h3><p>1、面向对象的设计 3节课左右</p>
<p>2、线程、pc（包括互斥锁与条件）、线程池</p>
<p>3、计算机网络基础（七层协议、TCP&#x2F;UDP）、网编编程socket、IO多路复用、服务器的框架</p>
<p>4、自己实现一个网络框架Reactor</p>
<h3 id="二、面向对象设计的基本概念"><a href="#二、面向对象设计的基本概念" class="headerlink" title="二、面向对象设计的基本概念"></a>二、面向对象设计的基本概念</h3><p>面向对象的分析（OOA）：分析需要做的需求。</p>
<p>面向对象的设计（OOD）：需要设计那些类、类中设计哪些数据成员、哪些成员函数、类与类之间的关系。</p>
<p>面向对象的编程（OOP）：将设计转换为代码</p>
<p>UML语言：统一建模语言</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126154115234.png" alt="image-20240126154115234"></p>
<h3 id="三、类与类之间的关系（-重要-）"><a href="#三、类与类之间的关系（-重要-）" class="headerlink" title="三、类与类之间的关系（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>三、类与类之间的关系（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h3><h4 id="1、继承"><a href="#1、继承" class="headerlink" title="1、继承"></a>1、继承</h4><p>从派生类向基类画出空间三角箭头。基类会成为派生类的一部分，在语义上：A is B</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126155626442.png" alt="image-20240126155626442"></p>
<p>继承：先有基类，然后再产生派生类。泛化（一般化）：先有派生类，然后抽象出基类。</p>
<h4 id="2、关联"><a href="#2、关联" class="headerlink" title="2、关联"></a>2、关联</h4><h5 id="2-1、双向的关联关系"><a href="#2-1、双向的关联关系" class="headerlink" title="2.1、双向的关联关系"></a>2.1、双向的关联关系</h5><p>在类图的画法上，使用的是实心直线。彼此并不负责对方的生命周期。在语义上：A has B。在代码层面上：使用的是指针或者引用。</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126160316083.png" alt="image-20240126160316083"></p>
<h5 id="2-2、单向的关联关系"><a href="#2-2、单向的关联关系" class="headerlink" title="2.2、单向的关联关系"></a>2.2、单向的关联关系</h5><p>在类图的画法上，使用的是实心箭头，从A指向B。彼此并不负责对方的生命周期。在语义上：A has B。在代码层面上：使用的是指针或者引用</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126160921378.png" alt="image-20240126160921378"></p>
<h4 id="3、聚合"><a href="#3、聚合" class="headerlink" title="3、聚合"></a>3、聚合</h4><p>表现为整体与局部的关系，整体并不负责局部的生命周期。在类图的画法上，可以从局部指向整体的空心菱形箭头。在语义上：A has B。在代码层面上：使用的是指针或者引用。</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126161438831.png" alt="image-20240126161438831"></p>
<h4 id="4、组合"><a href="#4、组合" class="headerlink" title="4、组合"></a>4、组合</h4><p>表现为整体与局部的关系，整体会负责局部对象的销毁。在类图的画法上，使用从局部指向整体的实心菱形箭头。在语义上：A has  B。在代码层面上：使用的是子对象的形式</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126162028313.png" alt="image-20240126162028313"></p>
<h4 id="5、依赖"><a href="#5、依赖" class="headerlink" title="5、依赖"></a>5、依赖</h4><p>在类图的画法上，使用的是从A指向B的虚线箭头。在语义层面上：A use B。这种关系是偶然的，临时的，并不是固定的。在代码层面上：</p>
<ul>
<li>B作为A的成员函数的参数</li>
<li>B作为A的成员函数的局部变量（返回值）</li>
<li>A的成员函数调用B的静态方法</li>
</ul>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126164857829.png" alt="image-20240126164857829"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、继承是垂直关系（纵向的关系），其他四种是平行的关系（横向的关系）</p>
<p>2、语义区别：继承是is关系，关联、聚合、组合是has关系，依赖是use关系</p>
<p>3、耦合程度：依赖  &lt; 关联 &lt; 聚合  &lt; 组合  &lt; 继承</p>
<p>4、<strong>聚合</strong>关系是一种稍强的关联关系，<strong>组合</strong>关系是一种更强的关联关系，在代码层面上：聚合使用的是指针或者引用，但是组合使用的是子对象</p>
<h3 id="四、面向对象的设计原则（-重要-）"><a href="#四、面向对象的设计原则（-重要-）" class="headerlink" title="四、面向对象的设计原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>四、面向对象的设计原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h3><h4 id="0、总纲"><a href="#0、总纲" class="headerlink" title="0、总纲"></a>0、总纲</h4><p>低耦合、高内聚。</p>
<p>低耦合：类与类之间的关系、模块与模块之间的关系。高内聚：类内部或者模块内部之间的关系</p>
<h4 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h4><p>核心思想：一个类，最好只做一件事，只有一个引起它变化的原因。</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126171906285.png" alt="image-20240126171906285"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126172302952.png" alt="image-20240126172302952"></p>
<h4 id="2、开放闭合原则（-重要-）"><a href="#2、开放闭合原则（-重要-）" class="headerlink" title="2、开放闭合原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>2、开放闭合原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><p>核心思想：就是对<strong>抽象编程</strong>，<strong>而不对具体编程</strong>，因为抽象相对稳定。对扩展开放，对修改关闭。</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126173357826.png" alt="image-20240126173357826"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240126173531715.png" alt="image-20240126173531715"></p>
<h2 id="CppBoostDay02"><a href="#CppBoostDay02" class="headerlink" title="CppBoostDay02"></a>CppBoostDay02</h2><p><a target="_blank" rel="noopener" href="https://docs.staruml.io/user-guide/managing-extensions#install-extension">https://docs.staruml.io/user-guide/managing-extensions#install-extension</a></p>
<h3 id="一、面向对象的设计原则（-重要-）"><a href="#一、面向对象的设计原则（-重要-）" class="headerlink" title="一、面向对象的设计原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>一、面向对象的设计原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h3><h4 id="3、里氏替换原则（-重要-）"><a href="#3、里氏替换原则（-重要-）" class="headerlink" title="3、里氏替换原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>3、里氏替换原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><p>核心思想：派生类必须能够替换其基类。</p>
<p>表现形式：</p>
<ul>
<li>派生类可以实现基类的抽象方法，表现为多态（也就是C++中的动态多态）</li>
<li>派生类能够新增自己的个性（C++中派生类进行生成的时候，吸收、改造、<strong>新增</strong>）</li>
<li>派生类不能覆盖基类的非抽象方法（C++中隐藏）</li>
</ul>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127091702669.png" alt="image-20240127091702669"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127091846690.png" alt="image-20240127091846690"></p>
<h4 id="4、接口分离原则"><a href="#4、接口分离原则" class="headerlink" title="4、接口分离原则"></a>4、接口分离原则</h4><p>核心思想：使用多个小的专门的接口，而不要使用一个大的总接口</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127092654889.png" alt="image-20240127092654889"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127092822562.png" alt="image-20240127092822562"></p>
<h4 id="5、依赖倒置原则（-重要-）"><a href="#5、依赖倒置原则（-重要-）" class="headerlink" title="5、依赖倒置原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>5、依赖倒置原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><p>核心思想：面向<strong>接口编程，依赖于抽象</strong>(抽象是稳定的，具体的是在变化的)</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127101113384.png" alt="image-20240127101113384"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127101323580.png" alt="image-20240127101323580"></p>
<p>总结：在大多数情况下，开闭原则、里氏代换原则和依赖倒置原则会同时出现，&#x3D;&#x3D;开闭原则是目标，里氏代换原则是基础，依赖倒置原则是手段&#x3D;&#x3D;  </p>
<h4 id="6、最少知识原则"><a href="#6、最少知识原则" class="headerlink" title="6、最少知识原则"></a>6、最少知识原则</h4><p>核心思想：尽量的降低两个类或者模块之前的耦合关系（解耦）</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127103157721.png" alt="image-20240127103157721"></p>
<h4 id="7、组合复用原则"><a href="#7、组合复用原则" class="headerlink" title="7、组合复用原则"></a>7、组合复用原则</h4><p>还是为了降低耦合程度，将继承的写法换成了关联、聚合、组合</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127104131866.png" alt="image-20240127104131866"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240127104654838.png" alt="image-20240127104654838"></p>
<h2 id="CppBoostDay03"><a href="#CppBoostDay03" class="headerlink" title="CppBoostDay03"></a>CppBoostDay03</h2><h3 id="一、线程基本概念"><a href="#一、线程基本概念" class="headerlink" title="一、线程基本概念"></a>一、线程基本概念</h3><h4 id="1、进程与线程区别"><a href="#1、进程与线程区别" class="headerlink" title="1、进程与线程区别"></a>1、进程与线程区别</h4><p>进程：系统中程序执行和<strong>资源分配的基本单位</strong> 。每个进程有自己的数据段、代码段和堆栈段 。 进程之间切换的话，需要进行上下文的切换，开销比较大。</p>
<p>线程：线程是操作系统能够进行运算<strong>调度的最小单位</strong> 。每个进程至少都有一个 main线程， 它与同进程中的其他线程共享进程空间：堆代码、数据 文件描述符、信号等 ， <strong>只拥有少量的栈空间</strong>， 大大减少了上下文切换的开销。线程也将其称为轻量级的进程。</p>
<p>线程和进程在使用上各有优缺点： 线程执行开销小， 占用的 CPU 少，线程之间的切换快，但不利于资源的管理和保护 而进程正相反 。</p>
<p>内核空间：被所有的进程所共享的。</p>
<p>用户态空间：每个进程在运行的时候，都会有自己的用户态空间。</p>
<h4 id="2、线程的分类"><a href="#2、线程的分类" class="headerlink" title="2、线程的分类"></a>2、线程的分类</h4><p>用户线程：运行在用户态的线程，称为用户线程。</p>
<p>内核线程：运行在内核态的线程，称为内核线程。</p>
<p>用户态切换到内核态，可以使用系统调用。</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129092639388.png" alt="image-20240129092639388"></p>
<h3 id="二、线程的常用函数"><a href="#二、线程的常用函数" class="headerlink" title="二、线程的常用函数"></a>二、线程的常用函数</h3><p>NPTL线程库</p>
<h4 id="1、线程的创建（-重要-）"><a href="#1、线程的创建（-重要-）" class="headerlink" title="1、线程的创建（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>1、线程的创建（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">//thread:第一个参数，传递的是线程id。</span></span><br><span class="line"><span class="comment">//attr:第二个参数，是线程的属性。用默认属性，将其设置为nullptr/NULL</span></span><br><span class="line"><span class="comment">//start_routine:第三个参数，线程的入口函数，是函数指针。void *可以看成是C语言中的广泛类型。</span></span><br><span class="line"><span class="comment">//什么叫做线程入口函数：线程运行起来的时候，肯定需要去执行任务，那执行任务的的入口在哪里了，就是线程入口函数</span></span><br><span class="line"><span class="comment">//arg:第四个参数。线程需要进行传递的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的返回值：是一个int类型的。如果函数的返回结果是0，那么就表明创建成功，否则创建失败就会返回错误码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译的时候，需要带上-pthread或者-lpthread  Compile and link with -pthread</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129094135344.png" alt="image-20240129094135344"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129104045288.png" alt="image-20240129104045288"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129104603520.png" alt="image-20240129104603520"></p>
<h4 id="2、线程的退出"><a href="#2、线程的退出" class="headerlink" title="2、线程的退出"></a>2、线程的退出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//让线程主动退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span></span>;</span><br><span class="line"><span class="comment">//retval：可以将子线程中的值带出来。这个值，平时不需要的话，是可以不用传递</span></span><br></pre></td></tr></table></figure>

<h4 id="3、线程的等待（-重要-）"><a href="#3、线程的等待（-重要-）" class="headerlink" title="3、线程的等待（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>3、线程的等待（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br><span class="line"><span class="comment">//thread:需要等待的线程id</span></span><br><span class="line"><span class="comment">//retval:需要等待的（被等待的）线程的中需要传递出来的值</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129110528646.png" alt="image-20240129110528646"></p>
<h4 id="4、获取线程id"><a href="#4、获取线程id" class="headerlink" title="4、获取线程id"></a>4、获取线程id</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129111126368.png" alt="image-20240129111126368"></p>
<h4 id="5、线程的取消（杀死）"><a href="#5、线程的取消（杀死）" class="headerlink" title="5、线程的取消（杀死）"></a>5、线程的取消（杀死）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="comment">//thread:被杀死(被取消)线程的线程id</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129112636247.png" alt="image-20240129112636247"></p>
<p>取消的时候，有一个取消点的概念。哪些函数具备取消点，可以使用man 7 pthreads查看。</p>
<h3 id="三、面向对象的线程封装"><a href="#三、面向对象的线程封装" class="headerlink" title="三、面向对象的线程封装"></a>三、面向对象的线程封装</h3><h4 id="1、类图"><a href="#1、类图" class="headerlink" title="1、类图"></a>1、类图</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129151552655.png" alt="image-20240129151552655"></p>
<h4 id="2、代码难点"><a href="#2、代码难点" class="headerlink" title="2、代码难点"></a>2、代码难点</h4><h5 id="2-1、threadFunc必须是静态的"><a href="#2-1、threadFunc必须是静态的" class="headerlink" title="2.1、threadFunc必须是静态的"></a>2.1、threadFunc必须是静态的</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129151642406.png" alt="image-20240129151642406"></p>
<h5 id="2-2、传递this指针"><a href="#2-2、传递this指针" class="headerlink" title="2.2、传递this指针"></a>2.2、传递this指针</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129151831366.png" alt="image-20240129151831366"></p>
<h3 id="四、基于对象的线程封装"><a href="#四、基于对象的线程封装" class="headerlink" title="四、基于对象的线程封装"></a>四、基于对象的线程封装</h3><h4 id="1、类图-1"><a href="#1、类图-1" class="headerlink" title="1、类图"></a>1、类图</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129161244114.png" alt="image-20240129161244114"></p>
<h4 id="2、代码难点-1"><a href="#2、代码难点-1" class="headerlink" title="2、代码难点"></a>2、代码难点</h4><h5 id="2-1、回调函数的注册"><a href="#2-1、回调函数的注册" class="headerlink" title="2.1、回调函数的注册"></a>2.1、回调函数的注册</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129161321564.png" alt="image-20240129161321564"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129161337618.png" alt="image-20240129161337618"></p>
<h5 id="2-2、回调函数的执行"><a href="#2-2、回调函数的执行" class="headerlink" title="2.2、回调函数的执行"></a>2.2、回调函数的执行</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129161444181.png" alt="image-20240129161444181"></p>
<h3 id="五、互斥锁"><a href="#五、互斥锁" class="headerlink" title="五、互斥锁"></a>五、互斥锁</h3><h4 id="1、互斥锁的类型"><a href="#1、互斥锁的类型" class="headerlink" title="1、互斥锁的类型"></a>1、互斥锁的类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//可以创建互斥锁的变量</span></span><br></pre></td></tr></table></figure>

<h4 id="2、互斥锁的初始化"><a href="#2、互斥锁的初始化" class="headerlink" title="2、互斥锁的初始化"></a>2、互斥锁的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> fastmutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"><span class="comment">//mutex:传递互斥锁的变量</span></span><br><span class="line"><span class="comment">//mutexattr:互斥锁的属性，可以使用默认属性，nullptr/NULL</span></span><br><span class="line"><span class="comment">//返回值：返回类型是一个int。成功返回0，失败返回非0</span></span><br></pre></td></tr></table></figure>

<h4 id="3、互斥锁的销毁"><a href="#3、互斥锁的销毁" class="headerlink" title="3、互斥锁的销毁"></a>3、互斥锁的销毁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="4、互斥锁的上锁与解锁"><a href="#4、互斥锁的上锁与解锁" class="headerlink" title="4、互斥锁的上锁与解锁"></a>4、互斥锁的上锁与解锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//互斥锁的上锁操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥锁的尝试上锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥锁的解锁操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;总结：互斥锁的函数，成功返回的是0，失败返回的是非0的值，以及错误码。&#x3D;&#x3D;</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129171425699.png" alt="image-20240129171425699"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129171948519.png" alt="image-20240129171948519"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129173132368.png" alt="image-20240129173132368"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129173205004.png" alt="image-20240129173205004"></p>
<h4 id="互斥锁使用总结："><a href="#互斥锁使用总结：" class="headerlink" title="互斥锁使用总结："></a>互斥锁使用总结：</h4><p>1、上锁一定要注意解锁，不然有可能会发生阻塞状态（也就上锁与解锁一定要成对出现）</p>
<p>2、两次上锁，会让程序处于阻塞状态，但是可以多次执行尝试上锁（也要注意，一定要解锁）</p>
<p>3、锁只有上锁与解锁状态，没有其他状态</p>
<p>4、如果锁处于上锁状态，那么是不能进行销毁的。也就是只有处于解锁状态的时候，才能销毁。</p>
<h3 id="六、条件变量"><a href="#六、条件变量" class="headerlink" title="六、条件变量"></a>六、条件变量</h3><h4 id="1、条件的类型"><a href="#1、条件的类型" class="headerlink" title="1、条件的类型"></a>1、条件的类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;<span class="comment">//可以创建条件变量的变量</span></span><br></pre></td></tr></table></figure>

<h4 id="2、条件变量的初始化"><a href="#2、条件变量的初始化" class="headerlink" title="2、条件变量的初始化"></a>2、条件变量的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br><span class="line"><span class="comment">//cond:传递条件变量的变量</span></span><br><span class="line"><span class="comment">//cond_attr:条件变量的属性，可以使用默认属性，nullptr/NULL</span></span><br><span class="line"><span class="comment">//返回值：返回类型是一个int。成功返回0，失败返回非0</span></span><br></pre></td></tr></table></figure>

<h4 id="3、条件变量的销毁"><a href="#3、条件变量的销毁" class="headerlink" title="3、条件变量的销毁"></a>3、条件变量的销毁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="4、条件变量的等待"><a href="#4、条件变量的等待" class="headerlink" title="4、条件变量的等待"></a>4、条件变量的等待</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//cond:条件变量对应的变量</span></span><br><span class="line"><span class="comment">//mutex:需要互斥锁的对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex, </span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="5、条件变量的通知"><a href="#5、条件变量的通知" class="headerlink" title="5、条件变量的通知"></a>5、条件变量的通知</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240129174951705.png" alt="image-20240129174951705"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//至少唤醒一个等待等待在条件变量上的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒在条件变量上的所有线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;总结：条件变量的函数，成功返回的是0，失败返回的是非0的值，以及错误码&#x3D;&#x3D;</p>
<h2 id="CppBoostDay04"><a href="#CppBoostDay04" class="headerlink" title="CppBoostDay04"></a>CppBoostDay04</h2><h3 id="一、问题回顾"><a href="#一、问题回顾" class="headerlink" title="一、问题回顾"></a>一、问题回顾</h3><p>1、线程与进程的区别？</p>
<p>2、线程的常用函数？</p>
<p>3、面向对象线程封装的设计与代码难点？</p>
<p>4、基于对象的线程封装的设计与代码难点？</p>
<p>5、互斥锁的常用函数以及所用需要注意那些点？</p>
<p>6、条件变量的常用函数有哪些？</p>
<h3 id="二、条件变量的使用"><a href="#二、条件变量的使用" class="headerlink" title="二、条件变量的使用"></a>二、条件变量的使用</h3><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130095511622.png" alt="image-20240130095511622"></p>
<p>唤醒操作一定要在wait之后，不然wait在条件变量上的线程是无法被唤醒的。</p>
<h3 id="三、面向对象生产者与消费者封装"><a href="#三、面向对象生产者与消费者封装" class="headerlink" title="三、面向对象生产者与消费者封装"></a>三、面向对象生产者与消费者封装</h3><h4 id="1、原理图"><a href="#1、原理图" class="headerlink" title="1、原理图"></a>1、原理图</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130104138249.png" alt="image-20240130104138249"></p>
<h4 id="2、类图设计"><a href="#2、类图设计" class="headerlink" title="2、类图设计"></a>2、类图设计</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130114602958.png" alt="image-20240130114602958"></p>
<h4 id="3、代码难点（-重要-）"><a href="#3、代码难点（-重要-）" class="headerlink" title="3、代码难点（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>3、代码难点（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><h5 id="3-1、防止死锁"><a href="#3-1、防止死锁" class="headerlink" title="3.1、防止死锁"></a>3.1、防止死锁</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160430608.png" alt="image-20240130160430608"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160446429.png" alt="image-20240130160446429"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160551421.png" alt="image-20240130160551421"></p>
<h5 id="3-2、虚假唤醒"><a href="#3-2、虚假唤醒" class="headerlink" title="3.2、虚假唤醒"></a>3.2、虚假唤醒</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160742572.png" alt="image-20240130160742572"></p>
<h5 id="3-3、TaskQueue中的push与pop完整思路"><a href="#3-3、TaskQueue中的push与pop完整思路" class="headerlink" title="3.3、TaskQueue中的push与pop完整思路"></a>3.3、TaskQueue中的push与pop完整思路</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160832357.png" alt="image-20240130160832357"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130160911093.png" alt="image-20240130160911093"></p>
<h5 id="3-4、生产者与消费者的run方法"><a href="#3-4、生产者与消费者的run方法" class="headerlink" title="3.4、生产者与消费者的run方法"></a>3.4、生产者与消费者的run方法</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130161014148.png" alt="image-20240130161014148"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130161045709.png" alt="image-20240130161045709"></p>
<h5 id="3-5、禁止复制"><a href="#3-5、禁止复制" class="headerlink" title="3.5、禁止复制"></a>3.5、禁止复制</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130161938422.png" alt="image-20240130161938422"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130161956306.png" alt="image-20240130161956306"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240130162015124.png" alt="image-20240130162015124"></p>
<h2 id="CppBoostDay05"><a href="#CppBoostDay05" class="headerlink" title="CppBoostDay05"></a>CppBoostDay05</h2><h3 id="一、问题回顾-1"><a href="#一、问题回顾-1" class="headerlink" title="一、问题回顾"></a>一、问题回顾</h3><p>1、面向对象的PC原理？类图的设计是什么？</p>
<p>2、如何防止死锁？如何防止虚假唤醒？禁止复制有哪些方式？</p>
<p>3、如何解析源码？</p>
<p>4、基于对象的PC如何实现？</p>
<p>5、面向对象线程池的类图设计回顾？</p>
<h3 id="二、基于对象的PC"><a href="#二、基于对象的PC" class="headerlink" title="二、基于对象的PC"></a>二、基于对象的PC</h3><h4 id="1、类图-2"><a href="#1、类图-2" class="headerlink" title="1、类图"></a>1、类图</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131090309971.png" alt="image-20240131090309971"></p>
<h4 id="2、代码难点-2"><a href="#2、代码难点-2" class="headerlink" title="2、代码难点"></a>2、代码难点</h4><h5 id="2-1、生产者与消费者的run的改造"><a href="#2-1、生产者与消费者的run的改造" class="headerlink" title="2.1、生产者与消费者的run的改造"></a>2.1、生产者与消费者的run的改造</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131090429077.png" alt="image-20240131090429077"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131090525191.png" alt="image-20240131090525191"></p>
<h5 id="2-2、测试代码"><a href="#2-2、测试代码" class="headerlink" title="2.2、测试代码"></a>2.2、测试代码</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131090851919.png" alt="image-20240131090851919"></p>
<h3 id="三、面向对象线程池封装"><a href="#三、面向对象线程池封装" class="headerlink" title="三、面向对象线程池封装"></a>三、面向对象线程池封装</h3><h4 id="1、使用场景"><a href="#1、使用场景" class="headerlink" title="1、使用场景"></a>1、使用场景</h4><p>如果任务比较少的话，可以来一个任务就对应创建一个线程，当任务执行结束之后，就将线程回收。如果任务量比较大的时候，还这样操作，那么线程的创建与销毁就比较频繁，而线程的创建与销毁也是会耗费资源的，所以在任务来之前，就创建一部分线程，任务到来之后，就放在任务队列中，线程池中的子线程在任务队列中拿任务，只要任务没有执行完毕，那么子线程就一直拿任务，执行任务。</p>
<h4 id="2、类图的设计"><a href="#2、类图的设计" class="headerlink" title="2、类图的设计"></a>2、类图的设计</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121341333.png" alt="image-20240131121341333"></p>
<h4 id="3、代码难点"><a href="#3、代码难点" class="headerlink" title="3、代码难点"></a>3、代码难点</h4><h5 id="3-1、任务执行不完，程序就退出了"><a href="#3-1、任务执行不完，程序就退出了" class="headerlink" title="3.1、任务执行不完，程序就退出了"></a>3.1、任务执行不完，程序就退出了</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121450861.png" alt="image-20240131121450861"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121541742.png" alt="image-20240131121541742"></p>
<h5 id="3-2、线程池无法退出"><a href="#3-2、线程池无法退出" class="headerlink" title="3.2、线程池无法退出"></a>3.2、线程池无法退出</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121624614.png" alt="image-20240131121624614"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121722958.png" alt="image-20240131121722958"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121842007.png" alt="image-20240131121842007"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131121947069.png" alt="image-20240131121947069"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240131122158527.png" alt="image-20240131122158527"></p>
<h4 id="4、面向对象的线程池序列图"><a href="#4、面向对象的线程池序列图" class="headerlink" title="4、面向对象的线程池序列图"></a>4、面向对象的线程池序列图</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201093230883.png" alt="image-20240201093230883"></p>
<h2 id="CppBoostDay06"><a href="#CppBoostDay06" class="headerlink" title="CppBoostDay06"></a>CppBoostDay06</h2><h3 id="一、基于对象的线程池封装"><a href="#一、基于对象的线程池封装" class="headerlink" title="一、基于对象的线程池封装"></a>一、基于对象的线程池封装</h3><h4 id="1、类图设计"><a href="#1、类图设计" class="headerlink" title="1、类图设计"></a>1、类图设计</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201094211788.png" alt="image-20240201094211788"></p>
<h4 id="2、代码难点-3"><a href="#2、代码难点-3" class="headerlink" title="2、代码难点"></a>2、代码难点</h4><h5 id="2-1、doTask的注册与执行"><a href="#2-1、doTask的注册与执行" class="headerlink" title="2.1、doTask的注册与执行"></a>2.1、doTask的注册与执行</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103140624.png" alt="image-20240201103140624"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103241431.png" alt="image-20240201103241431"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103332931.png" alt="image-20240201103332931"></p>
<h5 id="2-2、MyTask类中process的注册与执行"><a href="#2-2、MyTask类中process的注册与执行" class="headerlink" title="2.2、MyTask类中process的注册与执行"></a>2.2、MyTask类中process的注册与执行</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103525474.png" alt="image-20240201103525474"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103618504.png" alt="image-20240201103618504"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201103804930.png" alt="image-20240201103804930"></p>
<h3 id="二、计算机网络基础"><a href="#二、计算机网络基础" class="headerlink" title="二、计算机网络基础"></a>二、计算机网络基础</h3><h4 id="1、协议"><a href="#1、协议" class="headerlink" title="1、协议"></a>1、协议</h4><p>通信双方需要遵循的规则。</p>
<h4 id="2、TCP-IP协议"><a href="#2、TCP-IP协议" class="headerlink" title="2、TCP&#x2F;IP协议"></a>2、TCP&#x2F;IP协议</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201105425483.png" alt="image-20240201105425483"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201105651383.png" alt="image-20240201105651383"></p>
<h4 id="3、协议格式（-了解-）"><a href="#3、协议格式（-了解-）" class="headerlink" title="3、协议格式（&#x3D;&#x3D;了解&#x3D;&#x3D;）"></a>3、协议格式（&#x3D;&#x3D;了解&#x3D;&#x3D;）</h4><p>在不同的层，都会有相应的包头，每个包头都会有对应的格式，这个作为了解，如果给出头的图，可以将其封装起来就可以了。</p>
<h4 id="4、TCP协议（-重要-）"><a href="#4、TCP协议（-重要-）" class="headerlink" title="4、TCP协议（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>4、TCP协议（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><p>TCP协议是一个<strong>传输层</strong>的协议、<strong>面向连接</strong>的协议、<strong>可靠</strong>的协议、<strong>全双工</strong>的协议、字节流的协议、进行流量控制的协议 。</p>
<h5 id="三次握手（建立连接）"><a href="#三次握手（建立连接）" class="headerlink" title="三次握手（建立连接）"></a>三次握手（建立连接）</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201111121415.png" alt="image-20240201111121415"></p>
<h5 id="四次挥手（断开连接）"><a href="#四次挥手（断开连接）" class="headerlink" title="四次挥手（断开连接）"></a>四次挥手（断开连接）</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201111639421.png" alt="image-20240201111639421"></p>
<p>2MSL</p>
<h4 id="5、状态迁移图（-重要-）"><a href="#5、状态迁移图（-重要-）" class="headerlink" title="5、状态迁移图（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>5、状态迁移图（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><p>一共有11中状态。</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201141719014.png" alt="image-20240201141719014"></p>
<p>2MSL时间、半关闭状态</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201175645743.png" alt="image-20240201175645743"></p>
<h3 id="三、网络编程（-重要-）"><a href="#三、网络编程（-重要-）" class="headerlink" title="三、网络编程（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>三、网络编程（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h3><h4 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h4><p>在网络环境中，要确定一台主机，需要知道彼此的ip；在网络环境中，要想确定一个进程，需要知道ip+port</p>
<h4 id="2、字节序"><a href="#2、字节序" class="headerlink" title="2、字节序"></a>2、字节序</h4><p>TCP&#x2F;IP协议规定，<strong>网络数据流应采用大端字节序</strong>  </p>
<p>大端：低地址存高位，高地址存低位。小端：低地址存低位，高地址存高位。<br><strong>网络字节序</strong>，就是在网络中进行传输的字节序列，采用的是<strong>大端法</strong>。<strong>主机字节序</strong>，就是本地计算机中存储数据采用的字节序列，采用的是<strong>小端法</strong>  </p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201143120741.png" alt="image-20240201143120741"></p>
<p>字节序转换的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;<span class="comment">//h = host n = network l = long s = short</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串类型的ip从本机字节序转换为网络字节序</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3、网络通信的原理图（逻辑图）"><a href="#3、网络通信的原理图（逻辑图）" class="headerlink" title="3、网络通信的原理图（逻辑图）"></a>3、网络通信的原理图（逻辑图）</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201144448624.png" alt="image-20240201144448624"></p>
<h4 id="4、网络通信常规函数（-重要-）"><a href="#4、网络通信常规函数（-重要-）" class="headerlink" title="4、网络通信常规函数（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>4、网络通信常规函数（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h4><h5 id="4-1、socket函数"><a href="#4-1、socket函数" class="headerlink" title="4.1、socket函数"></a>4.1、socket函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接的通信点</span></span><br><span class="line"><span class="comment">//套接字函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//domain:协议族，常规的几种参数：AF_INET/AF_INET6/AF_UNIX</span></span><br><span class="line"><span class="comment">//type:SOCK_STREAM(TCP)/SOCK_DGRAM(UDP)</span></span><br><span class="line"><span class="comment">//protocol:一般都设置为0，使用默认协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：返回的结果是一个文件描述符，该值是大于零。如果返回-1，就表明函数执行失败</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;文件描述符，可以将其理解为指针、门把手。&#x3D;&#x3D;</p>
<h5 id="4-2、bind函数"><a href="#4-2、bind函数" class="headerlink" title="4.2、bind函数"></a>4.2、bind函数</h5><p>绑定ip与端口号port</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//sockfd:就是socket函数调用的返回结果</span></span><br><span class="line"><span class="comment">//addr:是一个结构体，目的就是将ip与端口号传进来</span></span><br><span class="line"><span class="comment">//addrlen:结构体的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port; <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> s_addr; <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240201152949424.png" alt="image-20240201152949424"></p>
<h5 id="4-3、listen函数"><a href="#4-3、listen函数" class="headerlink" title="4.3、listen函数"></a>4.3、listen函数</h5><p>服务器需要监听客户端的连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">//sockfd:是创建套接字socket的返回结果。</span></span><br><span class="line"><span class="comment">//backlog:用来指定监听上限数值,默认使用128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回-1.</span></span><br></pre></td></tr></table></figure>

<h5 id="4-4、accept函数"><a href="#4-4、accept函数" class="headerlink" title="4.4、accept函数"></a>4.4、accept函数</h5><p>接收连接请求的函数，&#x3D;&#x3D;阻塞等待客户端发起连接&#x3D;&#x3D;  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">//sockfd:就是socket函数调用的返回结果</span></span><br><span class="line"><span class="comment">//addr:通过该结构体，可以将客户端的ip与端口号反向的解出来。将网络字节序转换为本机字节序</span></span><br><span class="line"><span class="comment">//addrlen:结构体addr的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：会返回非负的整数，标识客户端与服务器已经建立了连接。可以通过该连接进行数据的传输。如果范返回失败，会得到-1</span></span><br></pre></td></tr></table></figure>

<h5 id="4-5、close函数"><a href="#4-5、close函数" class="headerlink" title="4.5、close函数"></a>4.5、close函数</h5><p>关闭文件描述符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">//fd：需要关闭的文件描述符</span></span><br><span class="line"><span class="comment">//返回值：成功返回0， 失败返回-1.</span></span><br></pre></td></tr></table></figure>

<h5 id="4-6、connect函数"><a href="#4-6、connect函数" class="headerlink" title="4.6、connect函数"></a>4.6、connect函数</h5><p>客户端与服务器进行连接的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//sockfd:由客户端调用socket函数返回的文件描述符</span></span><br><span class="line"><span class="comment">//addr:ip地址与端口号，客户端将服务器的ip与端口号设置到本addr中，进而为连接到服务器做准备</span></span><br><span class="line"><span class="comment">//addrlen:addr的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：成功返回0， 失败返回-1</span></span><br></pre></td></tr></table></figure>

<h5 id="4-7、读数据read-recv"><a href="#4-7、读数据read-recv" class="headerlink" title="4.7、读数据read&#x2F;recv"></a>4.7、读数据read&#x2F;recv</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">//从文件描述符fd中读取count个数据，放在buf开头的缓冲区中。</span></span><br><span class="line"><span class="comment">//函数的返回结果：成功的时候，会读取到所读的字节数；如果返回结果是0，表明读完了；如果小于0，表明出错了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//从文件描述符sockfd中读取len个数据，放在buf开头的缓冲区中。如果flags=0，那么recv与read是等价的</span></span><br><span class="line"><span class="comment">//如果flags被设置为MSG_PEEK,那么数据会从内核态拷贝到用户态，并且数据不会从内核从删除。</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;注意：read读数据的时候，会将数据直接移走（将内核中的数据移走），会将内核缓冲区清空。&#x3D;&#x3D;</p>
<h5 id="4-8、写数据write-send"><a href="#4-8、写数据write-send" class="headerlink" title="4.8、写数据write&#x2F;send"></a>4.8、写数据write&#x2F;send</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">//将buf指向的缓冲区中的count个数据，写入到fd对应的文件描述符中。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//如果flags=0，那么send与write是等价的</span></span><br></pre></td></tr></table></figure>

<h4 id="5、代码实现"><a href="#5、代码实现" class="headerlink" title="5、代码实现"></a>5、代码实现</h4><h2 id="CppBoostDay07"><a href="#CppBoostDay07" class="headerlink" title="CppBoostDay07"></a>CppBoostDay07</h2><h3 id="一、问题回顾-2"><a href="#一、问题回顾-2" class="headerlink" title="一、问题回顾"></a>一、问题回顾</h3><p>1、什么是协议？TCP&#x2F;IP协议包括哪几层？什么是TCP协议？什么是三次握手？什么是四次挥手？</p>
<p>2、状态迁移图有哪11中状态？FIN_WAIT_2、TIME_WAIT、CLOSE_WAIT状态？</p>
<p>3、什么是大端存储？什么是小端存储？网络字节序与网络字节序采用什么存储方法？</p>
<p>4、网络编程常规函数有哪些？</p>
<h3 id="二、端口复用"><a href="#二、端口复用" class="headerlink" title="二、端口复用"></a>二、端口复用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>





<h3 id="三、IO多路复用-重难点"><a href="#三、IO多路复用-重难点" class="headerlink" title="三、IO多路复用(&#x3D;&#x3D;重难点&#x3D;&#x3D;)"></a>三、IO多路复用(&#x3D;&#x3D;重难点&#x3D;&#x3D;)</h3><h4 id="0、原理图"><a href="#0、原理图" class="headerlink" title="0、原理图"></a>0、原理图</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202093905100.png" alt="image-20240202093905100"></p>
<h4 id="1、select的使用"><a href="#1、select的使用" class="headerlink" title="1、select的使用"></a>1、select的使用</h4><h5 id="1-1、函数接口"><a href="#1-1、函数接口" class="headerlink" title="1.1、函数接口"></a>1.1、函数接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">//nfds：是监听的文件描述符的个数。最大文件描述符 +1</span></span><br><span class="line"><span class="comment">//文件描述符对应的有读事件、写事件、以及异常事件</span></span><br><span class="line"><span class="comment">//fd_set:本质是位图。</span></span><br><span class="line"><span class="comment">//readfds、writefds、exceptfds这三个参数是三个位图的集合，可以将文件描述符对应的读事件、写事件、异常事件分别放在三个参数中。</span></span><br><span class="line"><span class="comment">//timeout:表示的是时间，表明等待的时间长短。</span></span><br><span class="line"><span class="comment">//定时阻塞监控时间，3中情况：</span></span><br><span class="line"><span class="comment">//1、NULL，永远等下去</span></span><br><span class="line"><span class="comment">//2、设置timeval，等待固定时间</span></span><br><span class="line"><span class="comment">//3、设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的返回值：文件描述符的个数。也就是三个位图中满足条件的文件描述符的总和，也就是三个位图中1的个数。</span></span><br><span class="line"><span class="comment">//如果返回是-1，那就是异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span>    tv_nsec;        <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件描述符fd从set中删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看文件描述符fd是不是还在set中</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件描述符fd放在set中进行监听</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将位图中的每一位全部清空为0（初始化为0）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd&#x3D;4 0 1 2 3</p>
<p>fd &#x3D; 4;   0 1 2 3 </p>
<h5 id="1-2、位图"><a href="#1-2、位图" class="headerlink" title="1.2、位图"></a>1.2、位图</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202102423847.png" alt="image-20240202102423847"></p>
<p>3 5 8 </p>
<p>readfs 3、5、8号文件描述符的读事件0 1  1</p>
<p>writefds  3、5号文件描述符的写事件0 1</p>
<p>exceptfds 3、5号文件描述符的异常事件1 0</p>
<h5 id="1-3、优缺点"><a href="#1-3、优缺点" class="headerlink" title="1.3、优缺点"></a>1.3、优缺点</h5><ul>
<li>监听的文件描述符是有上限的1024。</li>
<li>当监听的文件描述符个数比较稀疏的时候（比如6， 600， 1023），循环判断比较麻烦，所以需要自定义数据结构：数组（在我们的代码中就是client数组）  </li>
<li>监听集合（也就是位图）与满足监听条件的集合（也就是位图）是同一个，需要将原有集合保存（allset）  </li>
<li>如果监听的文件描述符比较密集，那么select效率还是比较不错的。</li>
</ul>
<h4 id="2、poll的使用"><a href="#2、poll的使用" class="headerlink" title="2、poll的使用"></a>2、poll的使用</h4><h5 id="2-1、函数接口"><a href="#2-1、函数接口" class="headerlink" title="2.1、函数接口"></a>2.1、函数接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fds:是一个结构体的数组</span></span><br><span class="line"><span class="comment">//nfds：数组的长度</span></span><br><span class="line"><span class="comment">//timeout 毫秒级等待</span></span><br><span class="line"><span class="comment">//-1:阻塞等，#define INFTIM -1 Linux中没有定义此宏</span></span><br><span class="line"><span class="comment">//0:立即返回，不阻塞进程</span></span><br><span class="line"><span class="comment">//&gt;0:等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值：满足监听条件的文件描述符的数目</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br><span class="line">events/revents:可以被设置为<span class="built_in">POLLIN</span>(读)/<span class="built_in">POLLOUT</span>(写)/<span class="built_in">POLLERR</span>(异常)</span><br></pre></td></tr></table></figure>

<h5 id="2-2、优缺点"><a href="#2-2、优缺点" class="headerlink" title="2.2、优缺点"></a>2.2、优缺点</h5><ul>
<li>突破了文件描述符1024的上限</li>
<li>监听集合与返回的集合分离</li>
<li>监听1000个文件描述符，但是只有3个满足条件，这样也需要全部遍历，效率依旧低</li>
</ul>
<h4 id="3、epoll的使用"><a href="#3、epoll的使用" class="headerlink" title="3、epoll的使用"></a>3、epoll的使用</h4><h5 id="3-1、函数接口"><a href="#3-1、函数接口" class="headerlink" title="3.1、函数接口"></a>3.1、函数接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//size:从内核版本2.6.8以后，可以将size设置为大于0的值即可</span></span><br><span class="line"><span class="comment">//flags:直接将其设置为0，效果与epoll_create一样</span></span><br><span class="line"><span class="comment">//返回值：成功返回文件描述符，该值是大于0的，失败返回-1</span></span><br><span class="line"><span class="comment">//以上两个函数底层会创建一个红黑树</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">//epfd:epoll_create返回的文件描述符。</span></span><br><span class="line"><span class="comment">//op:可以被设置为EPOLL_CTL_ADD(添加)/EPOLL_CTL_MOD(修改)/EPOLL_CTL_DEL(删除)</span></span><br><span class="line"><span class="comment">//fd:传递文件描述符。</span></span><br><span class="line"><span class="comment">//event:该函数是一个结构体指针。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//events:可以是EPOLLIN(读)/EPOLLOUT(写)/EPOLLERR(异常)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//epfd:epoll_create返回的文件描述符。       </span></span><br><span class="line"><span class="comment">//events:将满足条件的文件描述符存在该结构体指针中（也就是结构体数组）</span></span><br><span class="line"><span class="comment">//maxevents:前面的结构体的大小</span></span><br><span class="line"><span class="comment">//timeout:时间。timeout：是超时时间</span></span><br><span class="line"><span class="comment">//-1：阻塞</span></span><br><span class="line"><span class="comment">//=0：立即返回，非阻塞</span></span><br><span class="line"><span class="comment">//&gt;0：指定毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：成功返回有多少文件描述符就绪，出错返回-1</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2、优缺点"><a href="#3-2、优缺点" class="headerlink" title="3.2、优缺点"></a>3.2、优缺点</h5><ul>
<li>文件描述符数目没有上限：通过epoll_ctl()来注册一个文件描述符，内核中使用<strong>红黑树</strong>的数据结构来管理所有需要监控的文件描述符。</li>
<li>基于事件就绪通知方式：一旦被监听的某个文件描述符就绪，<strong>内核</strong>会采用类似于callback的<strong>回调机制</strong>，迅速激活这个文件描述符，这样随着文件描述符数量的增加，也不会影响判定就绪的性能。</li>
<li>维护就绪队列：当文件描述符就绪，就会被放到内核中的一个<strong>就绪队列</strong>中，这样调用epoll_weit获取就绪文件描述符的时候，只要取队列中的元素即可，操作的时间复杂度恒为O(1)</li>
<li>对于大量连续文件描述符活跃的时候，epoll的效果不一定就比select强</li>
</ul>
<h5 id="3-3、两种模式（-了解-）"><a href="#3-3、两种模式（-了解-）" class="headerlink" title="3.3、两种模式（&#x3D;&#x3D;了解&#x3D;&#x3D;）"></a>3.3、两种模式（&#x3D;&#x3D;了解&#x3D;&#x3D;）</h5><p>水平触发与边沿触发。</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202170954547.png" alt="image-20240202170954547"></p>
<h3 id="四、5种网络IO模型（-重要-）"><a href="#四、5种网络IO模型（-重要-）" class="headerlink" title="四、5种网络IO模型（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>四、5种网络IO模型（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h3><h4 id="1、阻塞式IO"><a href="#1、阻塞式IO" class="headerlink" title="1、阻塞式IO"></a>1、阻塞式IO</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202172235740.png" alt="image-20240202172235740"></p>
<h4 id="2、非阻塞式IO"><a href="#2、非阻塞式IO" class="headerlink" title="2、非阻塞式IO"></a>2、非阻塞式IO</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202172527923.png" alt="image-20240202172527923"></p>
<h4 id="3、IO多路复用"><a href="#3、IO多路复用" class="headerlink" title="3、IO多路复用"></a>3、IO多路复用</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202172958230.png" alt="image-20240202172958230"></p>
<h4 id="4、信号驱动IO"><a href="#4、信号驱动IO" class="headerlink" title="4、信号驱动IO"></a>4、信号驱动IO</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202173619132.png" alt="image-20240202173619132"></p>
<p>&#x3D;&#x3D;总结：以上四种同步IO而言，第一阶段“等待数据”阶段有区别，但是在第二阶段，都是阻塞的。&#x3D;&#x3D;</p>
<h4 id="5、异步IO"><a href="#5、异步IO" class="headerlink" title="5、异步IO"></a>5、异步IO</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202174052137.png" alt="image-20240202174052137"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202174205776.png" alt="image-20240202174205776"></p>
<p>在五种网络IO模型中，同步机制的时候，第二阶段都是阻塞的，但是对于异步IO而言，第二步是非阻塞的。只有异步IO才能达到真正的非阻塞的。</p>
<h3 id="五、Reactor的基本概念"><a href="#五、Reactor的基本概念" class="headerlink" title="五、Reactor的基本概念"></a>五、Reactor的基本概念</h3><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202175506878.png" alt="image-20240202175506878"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202175440399.png" alt="image-20240202175440399"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240202175520532.png" alt="image-20240202175520532"></p>
<h2 id="CppBoostDay08"><a href="#CppBoostDay08" class="headerlink" title="CppBoostDay08"></a>CppBoostDay08</h2><h3 id="一、问题回顾-3"><a href="#一、问题回顾-3" class="headerlink" title="一、问题回顾"></a>一、问题回顾</h3><p>1、端口复用、地址复用使用什么函数进行设置？参数是什么？</p>
<p>2、IO多路复用的形式有哪三种？</p>
<p>3、select对应的函数接口、使用方式如何？有什么特点？优缺点？</p>
<p>4、poll对应的函数接口、使用方式如何？有什么特点？优缺点？</p>
<p>5、epoll的函数借楼、使用方式如何？有什么特点？优缺点？</p>
<p>6、有哪五种网络IO模型？</p>
<h3 id="二、ReactorV1版本"><a href="#二、ReactorV1版本" class="headerlink" title="二、ReactorV1版本"></a>二、ReactorV1版本</h3><h4 id="1、类的设计过程"><a href="#1、类的设计过程" class="headerlink" title="1、类的设计过程"></a>1、类的设计过程</h4><p>Socket类：所有与套接字相关的操作全部封装到该类中。包括：套接字的创建、套接字的关闭、套接字的获取。</p>
<p>InetAddress类：将所有与地址相关的操作全部封装到该类中。包括：ip地址的获取、端口号的获取以及通过ip与端口号创建InetAddress类的对象、包括struct sockaddr_in变量的获取。</p>
<p>Acceptor类：将所有服务器的主要函数全部封装到该类中。包括：地址复用、端口复用、bind函数、listen函数、accept函数。只要Acceptor类调用了accept函数就表明三次握手建立成功。</p>
<p>TcpConnection类：如果Acceptor类调用accept函数有正确的返回结构，就表明三次握手建立成功，就可以创建一条连接，该连接就是TcpConnection连接，就可以用该连接发送数据，即send数据，与接收数据，即receive数据。</p>
<p>SocketIO类：该类的作用就是为了完成数据的真正的收发。也就是完成系统调用read&#x2F;recv&#x2F;write&#x2F;send的封装。还需要具体进行封装数据的收发数据量。</p>
<p>首先，客户端与服务器进行连接，就是客户端发送数据，服务器接收数据，然后服务器对数据进行处理后再发送给客户端。很明显，首先便是需要创建套接字连接，然后找到对应的ip地址和端口号，确保发送成功。然后服务器进行操作。就像bind,listen,accept函数都调用一遍，而且一般来说肯定不只是一台客户端，所以你应该支持多台客户端都可以与服务器进行连接，这样你就需要进行地址复用和端口复用。然后，建立连接后，就需要对数据进行操作，发送数据和接收数据，发送数据是send函数，接收数据是receive函数。除此之外，这些数据还需要进行处理，这个处理就是读写操作。</p>
<p>根据上面这整个流程，我们可以将它分开，比如，与套接字有关的抽象成一个类，与地址有关的抽象成一个类，还有服务器的主要函数抽象一个类，还有你建立连接的过程也抽象一个类，还有根据单一功能原则，数据的封装和修改这里最好也抽象成一个类。那么这个过程就可以根据面向对象的方法抽象成几个不同的类，然后再进行操作。</p>
<h4 id="2、类图设计-1"><a href="#2、类图设计-1" class="headerlink" title="2、类图设计"></a>2、类图设计</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240204115852087.png" alt="image-20240204115852087"></p>
<h4 id="3、重难点"><a href="#3、重难点" class="headerlink" title="3、重难点"></a>3、重难点</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240204115957833.png" alt="image-20240204115957833"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240204120028605.png" alt="image-20240204120028605"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240204120050554.png" alt="image-20240204120050554"></p>
<p>&#x3D;&#x3D;recv使用MSG_PEEK数据是从内核态缓存区拷贝到用户态缓冲区，但是数据在内核态缓冲区中还存在。如果直接使用read，那么数据会从内核态缓冲区被读取到用户态，并给数据在内核态会被清空。&#x3D;&#x3D;</p>
<h2 id="CppBoostDay09"><a href="#CppBoostDay09" class="headerlink" title="CppBoostDay09"></a>CppBoostDay09</h2><h3 id="一、ReactorV2版本（-重难点-）"><a href="#一、ReactorV2版本（-重难点-）" class="headerlink" title="一、ReactorV2版本（&#x3D;&#x3D;重难点&#x3D;&#x3D;）"></a>一、ReactorV2版本（&#x3D;&#x3D;重难点&#x3D;&#x3D;）</h3><h4 id="1、TCP网络编程最本质的是处理三个半事件"><a href="#1、TCP网络编程最本质的是处理三个半事件" class="headerlink" title="1、TCP网络编程最本质的是处理三个半事件"></a>1、TCP网络编程最本质的是处理三个半事件</h4><p><strong>连接建立</strong>：包括服务器端被动接受连接（accept）和客户端主动发起连接（connect）。TCP连接一旦建立，客户端和服务端就是平等的，可以各自收发数据。(三次握手)<br><strong>连接断开</strong>：包括主动断开（close、shutdown）和被动断开（read()返回0）。（四次挥手）<br><strong>消息到达</strong>：文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等）。<br>消息发送完毕：这算半个。对于低流量的服务，可不必关心这个事件；另外，这里的“发送完毕”是指数据写入操作系统缓冲区（内核缓冲区），将由TCP协议栈负责数据的发送与重传，不代表对方已经接收到数据。</p>
<h4 id="2、类图设计-2"><a href="#2、类图设计-2" class="headerlink" title="2、类图设计"></a>2、类图设计</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105315370.png" alt="image-20240205105315370"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105335943.png" alt="image-20240205105335943"></p>
<h4 id="3、代码难点（-重难点-）"><a href="#3、代码难点（-重难点-）" class="headerlink" title="3、代码难点（&#x3D;&#x3D;重难点&#x3D;&#x3D;）"></a>3、代码难点（&#x3D;&#x3D;重难点&#x3D;&#x3D;）</h4><h5 id="3-1、键值对的数据成员"><a href="#3-1、键值对的数据成员" class="headerlink" title="3.1、键值对的数据成员"></a>3.1、键值对的数据成员</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105433845.png" alt="image-20240205105433845"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105450179.png" alt="image-20240205105450179"></p>
<h5 id="3-2、EventLoop中三个回调数据成员"><a href="#3-2、EventLoop中三个回调数据成员" class="headerlink" title="3.2、EventLoop中三个回调数据成员"></a>3.2、EventLoop中三个回调数据成员</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105529011.png" alt="image-20240205105529011"></p>
<h5 id="3-3、EventLoop中三个回调的注册"><a href="#3-3、EventLoop中三个回调的注册" class="headerlink" title="3.3、EventLoop中三个回调的注册"></a>3.3、EventLoop中三个回调的注册</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105559220.png" alt="image-20240205105559220"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110540061.png" alt="image-20240205110540061"></p>
<h5 id="3-4、EventLoop构造函数中监听-fd"><a href="#3-4、EventLoop构造函数中监听-fd" class="headerlink" title="3.4、EventLoop构造函数中监听 fd"></a>3.4、EventLoop构造函数中监听 fd</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105707573.png" alt="image-20240205105707573"></p>
<h5 id="3-5、获取vector首元素的地址"><a href="#3-5、获取vector首元素的地址" class="headerlink" title="3.5、获取vector首元素的地址"></a>3.5、获取vector首元素的地址</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105757198.png" alt="image-20240205105757198"></p>
<h5 id="3-6、waitEpollFd的实现"><a href="#3-6、waitEpollFd的实现" class="headerlink" title="3.6、waitEpollFd的实现"></a>3.6、waitEpollFd的实现</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105829862.png" alt="image-20240205105829862"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105918402.png" alt="image-20240205105918402"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205105948324.png" alt="image-20240205105948324"></p>
<h5 id="3-7、handleNewConnection的实现（-重要-）"><a href="#3-7、handleNewConnection的实现（-重要-）" class="headerlink" title="3.7、handleNewConnection的实现（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>3.7、handleNewConnection的实现（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110153223.png" alt="image-20240205110153223"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110249423.png" alt="image-20240205110249423"></p>
<h5 id="3-8、EventLoop中的handleMessage"><a href="#3-8、EventLoop中的handleMessage" class="headerlink" title="3.8、EventLoop中的handleMessage"></a>3.8、EventLoop中的handleMessage</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110423974.png" alt="image-20240205110423974"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110445316.png" alt="image-20240205110445316"></p>
<h5 id="3-9、TcpConnection中注册回调函数做数据成员"><a href="#3-9、TcpConnection中注册回调函数做数据成员" class="headerlink" title="3.9、TcpConnection中注册回调函数做数据成员"></a>3.9、TcpConnection中注册回调函数做数据成员</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110718716.png" alt="image-20240205110718716"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110732337.png" alt="image-20240205110732337"></p>
<h5 id="3-10、TcpConnection中的三个回调函数的注册"><a href="#3-10、TcpConnection中的三个回调函数的注册" class="headerlink" title="3.10、TcpConnection中的三个回调函数的注册"></a>3.10、TcpConnection中的三个回调函数的注册</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110822359.png" alt="image-20240205110822359"></p>
<h5 id="3-11、防止智能指针的误用"><a href="#3-11、防止智能指针的误用" class="headerlink" title="3.11、防止智能指针的误用"></a>3.11、防止智能指针的误用</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110900509.png" alt="image-20240205110900509"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110913742.png" alt="image-20240205110913742"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110931953.png" alt="image-20240205110931953"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205110945743.png" alt="image-20240205110945743"></p>
<h3 id="二、ReactorV3版本"><a href="#二、ReactorV3版本" class="headerlink" title="二、ReactorV3版本"></a>二、ReactorV3版本</h3><h4 id="1、类图的设计"><a href="#1、类图的设计" class="headerlink" title="1、类图的设计"></a>1、类图的设计</h4><p>第三个版本就是在第二个版本的基础上进行了封装。</p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205151115502.png" alt="image-20240205151115502"></p>
<h4 id="2、代码解析"><a href="#2、代码解析" class="headerlink" title="2、代码解析"></a>2、代码解析</h4><h5 id="2-1、子对象的初始化"><a href="#2-1、子对象的初始化" class="headerlink" title="2.1、子对象的初始化"></a>2.1、子对象的初始化</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205151237286.png" alt="image-20240205151237286"></p>
<h5 id="2-2、服务器的启动"><a href="#2-2、服务器的启动" class="headerlink" title="2.2、服务器的启动"></a>2.2、服务器的启动</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205151256789.png" alt="image-20240205151256789"></p>
<h5 id="2-3、三个回调函数同时注册"><a href="#2-3、三个回调函数同时注册" class="headerlink" title="2.3、三个回调函数同时注册"></a>2.3、三个回调函数同时注册</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205151320549.png" alt="image-20240205151320549"></p>
<h3 id="三、ReactorV4版本"><a href="#三、ReactorV4版本" class="headerlink" title="三、ReactorV4版本"></a>三、ReactorV4版本</h3><h4 id="1、v3版本的瓶颈"><a href="#1、v3版本的瓶颈" class="headerlink" title="1、v3版本的瓶颈"></a>1、v3版本的瓶颈</h4><p>当业务逻辑比较复杂的时候，就需要CPU大量参与进来，但是本版本中，接收数据、传输数据以及发送数据是串行执行的，所以需要将业务逻辑的处理交给线程池做。</p>
<h4 id="2、V4版本的逻辑图"><a href="#2、V4版本的逻辑图" class="headerlink" title="2、V4版本的逻辑图"></a>2、V4版本的逻辑图</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205153531133.png" alt=" "></p>
<h3 id="四、eventfd的使用"><a href="#四、eventfd的使用" class="headerlink" title="四、eventfd的使用"></a>四、eventfd的使用</h3><h4 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h4><p>eventfd可以在进程或者线程之间进行通信。</p>
<h4 id="2、函数接口"><a href="#2、函数接口" class="headerlink" title="2、函数接口"></a>2、函数接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventfd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> initval, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//initval：初始化计数器值，该值保存在内核</span></span><br><span class="line"><span class="comment">//flags:如果是2.6.26或之前版本的内核，flags 必须设置为0。</span></span><br><span class="line"><span class="comment">//flags支持以下标志位：</span></span><br><span class="line"><span class="comment">//EFD_NONBLOCK      类似于使用O_NONBLOCK标志设置文件描述符。</span></span><br><span class="line"><span class="comment">//EFD_CLOEXEC  类似open以O_CLOEXEC标志打开， O_CLOEXEC 应该表示执行exec()时，之前通过open()打开的文件描述符会自动关闭.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：函数返回一个文件描述符，与打开的其他文件一样，可以进行读写操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eventfd返回的文件描述符是可以被read/write读写的，也可以被IO多路复用进行监听select/poll/epoll</span></span><br></pre></td></tr></table></figure>

<p>write操作eventfd返回的文件描述符，可以将内核计数器进行累加，但是如果只要read一次eventfd返回的文件描述符，就可以将内核计数器的值清空。</p>
<p>同时我们看成eventfd可以在进程之间进行通信。</p>
<h4 id="3、封装eventfd"><a href="#3、封装eventfd" class="headerlink" title="3、封装eventfd"></a>3、封装eventfd</h4><h5 id="3-1、类图"><a href="#3-1、类图" class="headerlink" title="3.1、类图"></a>3.1、类图</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205164631152.png" alt="image-20240205164631152"></p>
<h5 id="3-2、代码难点"><a href="#3-2、代码难点" class="headerlink" title="3.2、代码难点"></a>3.2、代码难点</h5><h6 id="3-2-1、EventFd的start函数实现"><a href="#3-2-1、EventFd的start函数实现" class="headerlink" title="3.2.1、EventFd的start函数实现"></a>3.2.1、EventFd的start函数实现</h6><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205174204399.png" alt="image-20240205174204399"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205174230633.png" alt="image-20240205174230633"></p>
<h6 id="3-2-2、自己构建新的线程，然后主子线程之间通信"><a href="#3-2-2、自己构建新的线程，然后主子线程之间通信" class="headerlink" title="3.2.2、自己构建新的线程，然后主子线程之间通信"></a>3.2.2、自己构建新的线程，然后主子线程之间通信</h6><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240205174312922.png" alt="image-20240205174312922"></p>
<h2 id="CppBoostDay10"><a href="#CppBoostDay10" class="headerlink" title="CppBoostDay10"></a>CppBoostDay10</h2><h3 id="一、ReactorV4版本"><a href="#一、ReactorV4版本" class="headerlink" title="一、ReactorV4版本"></a>一、ReactorV4版本</h3><h4 id="1、类图设计-1"><a href="#1、类图设计-1" class="headerlink" title="1、类图设计"></a>1、类图设计</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112534699.png" alt="image-20240206112534699"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112746385.png" alt="image-20240206112746385"></p>
<h4 id="2、代码难点-4"><a href="#2、代码难点-4" class="headerlink" title="2、代码难点"></a>2、代码难点</h4><h5 id="2-1、TcpConnection中的sendInLoop函数"><a href="#2-1、TcpConnection中的sendInLoop函数" class="headerlink" title="2.1、TcpConnection中的sendInLoop函数"></a>2.1、TcpConnection中的sendInLoop函数</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112848465.png" alt="image-20240206112848465"></p>
<h5 id="2-2、EventLoop中的runInLoop"><a href="#2-2、EventLoop中的runInLoop" class="headerlink" title="2.2、EventLoop中的runInLoop"></a>2.2、EventLoop中的runInLoop</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112924922.png" alt="image-20240206112924922"></p>
<h5 id="2-3、EventLoop中的doPengdingFunctors"><a href="#2-3、EventLoop中的doPengdingFunctors" class="headerlink" title="2.3、EventLoop中的doPengdingFunctors"></a>2.3、EventLoop中的doPengdingFunctors</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112959960.png" alt="image-20240206112959960"></p>
<h5 id="2-4、测试代码中的回调函数onMessage与线程池的关系"><a href="#2-4、测试代码中的回调函数onMessage与线程池的关系" class="headerlink" title="2.4、测试代码中的回调函数onMessage与线程池的关系"></a>2.4、测试代码中的回调函数onMessage与线程池的关系</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206113049008.png" alt="image-20240206113049008"></p>
<h5 id="2-5、MyTask中的process的分析"><a href="#2-5、MyTask中的process的分析" class="headerlink" title="2.5、MyTask中的process的分析"></a>2.5、MyTask中的process的分析</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206113145613.png" alt="image-20240206113145613"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206113206803.png" alt="image-20240206113206803"></p>
<p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206113312022.png" alt="image-20240206113312022"></p>
<h4 id="3、流程图"><a href="#3、流程图" class="headerlink" title="3、流程图"></a>3、流程图</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240206112144927.png" alt="image-20240206112144927"></p>
<h2 id="CppBoostDay11"><a href="#CppBoostDay11" class="headerlink" title="CppBoostDay11"></a>CppBoostDay11</h2><h3 id="一、ReactorV5版本"><a href="#一、ReactorV5版本" class="headerlink" title="一、ReactorV5版本"></a>一、ReactorV5版本</h3><h4 id="1、类图设计-2"><a href="#1、类图设计-2" class="headerlink" title="1、类图设计"></a>1、类图设计</h4><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240207102012957.png" alt="image-20240207102012957"></p>
<h3 id="二、timerfd的封装"><a href="#二、timerfd的封装" class="headerlink" title="二、timerfd的封装"></a>二、timerfd的封装</h3><h4 id="1、timerfd的基本特征"><a href="#1、timerfd的基本特征" class="headerlink" title="1、timerfd的基本特征"></a>1、timerfd的基本特征</h4><p>timerfd是Linux提供的一个<strong>定时器接口</strong>。这个接口基于文件描述符，通过文件描述符的<strong>可读事件进行超时通知</strong>，所以能够被用于select&#x2F;poll&#x2F;epoll的应用场景</p>
<h4 id="2、函数接口-1"><a href="#2、函数接口-1" class="headerlink" title="2、函数接口"></a>2、函数接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="type">int</span> clockid, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//功能：该函数生成一个定时器对象，返回与之关联的文件描述符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数详解：</span></span><br><span class="line"><span class="comment">//clockid:可设置为</span></span><br><span class="line"><span class="comment">//CLOCK_REALTIME：相对时间，从1970.1.1到目前的时间。更改系统时间 会更改获取的值，它以系统时间为坐标。</span></span><br><span class="line"><span class="comment">//CLOCK_MONOTONIC：绝对时间，获取的时间为系统重启到现在的时间，更改系统时间对齐没有影响。</span></span><br><span class="line"><span class="comment">//flags: 可设置为</span></span><br><span class="line"><span class="comment">//TFD_NONBLOCK（非阻塞），</span></span><br><span class="line"><span class="comment">//TFD_CLOEXEC（同O_CLOEXEC）</span></span><br><span class="line"><span class="comment">//linux内核2.6.26版本以上都指定为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timerfd_settime</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="keyword">struct</span> itimerspec *new_value,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">struct</span> itimerspec *old_value)</span></span>;</span><br><span class="line"><span class="comment">//功能：该函数能够启动和停止定时器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数详解：</span></span><br><span class="line"><span class="comment">//fd: timerfd_create对应的文件描述符</span></span><br><span class="line"><span class="comment">//flags: 0表示是相对定时器,TFD_TIMER_ABSTIME表示是绝对定时器</span></span><br><span class="line"><span class="comment">//new_value:设置超时时间，如果为0则表示停止定时器。</span></span><br><span class="line"><span class="comment">//old_value:一般设为NULL, 不为NULL,则返回定时器这次设置之前的超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;                <span class="comment">/* Seconds */</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec;               <span class="comment">/* Nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">itimerspec</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> it_interval;  <span class="comment">/* Interval for periodic timer */</span><span class="comment">//周期时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> it_value;     <span class="comment">/* Initial expiration */</span><span class="comment">//初始时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3、timerfd的封装"><a href="#3、timerfd的封装" class="headerlink" title="3、timerfd的封装"></a>3、timerfd的封装</h4><h5 id="3-1、封装"><a href="#3-1、封装" class="headerlink" title="3.1、封装"></a>3.1、封装</h5><p><img src="/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/image-20240207112356546-17243977773751.png" alt="image-20240207112356546"></p>

    </div>

    
    
    

    
        <div>
             <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

        </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>李新乾
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2024/07/07/C++/C++%E6%8F%90%E9%AB%98/" title="C++提高">http://example.com/2024/07/07/C++/C++提高/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/07/C++/%E5%AE%BF%E8%88%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" rel="prev" title="宿舍管理系统">
      <i class="fa fa-chevron-left"></i> 宿舍管理系统
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/07/C++/C/" rel="next" title="C">
      C <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC82MDA0OC8zNjUxNA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay01"><span class="nav-number">1.</span> <span class="nav-text">CppBoostDay01</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%90%8E%E7%BB%AD11%E5%A4%A9%E7%9A%84%E5%AE%89%E6%8E%92"><span class="nav-number">1.1.</span> <span class="nav-text">一、后续11天的安排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">二、面向对象设计的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">三、类与类之间的关系（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%85%B3%E8%81%94"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、关联</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E3%80%81%E5%8F%8C%E5%90%91%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">2.1、双向的关联关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E3%80%81%E5%8D%95%E5%90%91%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2.2、单向的关联关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%81%9A%E5%90%88"><span class="nav-number">1.3.3.</span> <span class="nav-text">3、聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%BB%84%E5%90%88"><span class="nav-number">1.3.4.</span> <span class="nav-text">4、组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E4%BE%9D%E8%B5%96"><span class="nav-number">1.3.5.</span> <span class="nav-text">5、依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">四、面向对象的设计原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0%E3%80%81%E6%80%BB%E7%BA%B2"><span class="nav-number">1.4.1.</span> <span class="nav-text">0、总纲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.2.</span> <span class="nav-text">1、单一职责原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%BC%80%E6%94%BE%E9%97%AD%E5%90%88%E5%8E%9F%E5%88%99%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">1.4.3.</span> <span class="nav-text">2、开放闭合原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay02"><span class="nav-number">2.</span> <span class="nav-text">CppBoostDay02</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">一、面向对象的设计原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">3、里氏替换原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%8E%A5%E5%8F%A3%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="nav-number">2.1.2.</span> <span class="nav-text">4、接口分离原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">2.1.3.</span> <span class="nav-text">5、依赖倒置原则（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99"><span class="nav-number">2.1.4.</span> <span class="nav-text">6、最少知识原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E7%BB%84%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-number">2.1.5.</span> <span class="nav-text">7、组合复用原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay03"><span class="nav-number">3.</span> <span class="nav-text">CppBoostDay03</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">一、线程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.1.</span> <span class="nav-text">1、进程与线程区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.2.</span> <span class="nav-text">2、线程的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">二、线程的常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">1、线程的创建（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA"><span class="nav-number">3.2.2.</span> <span class="nav-text">2、线程的退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">3.2.3.</span> <span class="nav-text">3、线程的等待（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8Bid"><span class="nav-number">3.2.4.</span> <span class="nav-text">4、获取线程id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88%EF%BC%88%E6%9D%80%E6%AD%BB%EF%BC%89"><span class="nav-number">3.2.5.</span> <span class="nav-text">5、线程的取消（杀死）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%B0%81%E8%A3%85"><span class="nav-number">3.3.</span> <span class="nav-text">三、面向对象的线程封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9B%BE"><span class="nav-number">3.3.1.</span> <span class="nav-text">1、类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9"><span class="nav-number">3.3.2.</span> <span class="nav-text">2、代码难点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E3%80%81threadFunc%E5%BF%85%E9%A1%BB%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">2.1、threadFunc必须是静态的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E3%80%81%E4%BC%A0%E9%80%92this%E6%8C%87%E9%92%88"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">2.2、传递this指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%B0%81%E8%A3%85"><span class="nav-number">3.4.</span> <span class="nav-text">四、基于对象的线程封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9B%BE-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">1、类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">2、代码难点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E3%80%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">2.1、回调函数的注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E3%80%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">2.2、回调函数的执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.5.</span> <span class="nav-text">五、互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.5.1.</span> <span class="nav-text">1、互斥锁的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.5.2.</span> <span class="nav-text">2、互斥锁的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E9%94%80%E6%AF%81"><span class="nav-number">3.5.3.</span> <span class="nav-text">3、互斥锁的销毁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%B8%8A%E9%94%81%E4%B8%8E%E8%A7%A3%E9%94%81"><span class="nav-number">3.5.4.</span> <span class="nav-text">4、互斥锁的上锁与解锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">3.5.5.</span> <span class="nav-text">互斥锁使用总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">3.6.</span> <span class="nav-text">六、条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.6.1.</span> <span class="nav-text">1、条件的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.6.2.</span> <span class="nav-text">2、条件变量的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E9%94%80%E6%AF%81"><span class="nav-number">3.6.3.</span> <span class="nav-text">3、条件变量的销毁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E7%AD%89%E5%BE%85"><span class="nav-number">3.6.4.</span> <span class="nav-text">4、条件变量的等待</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E9%80%9A%E7%9F%A5"><span class="nav-number">3.6.5.</span> <span class="nav-text">5、条件变量的通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay04"><span class="nav-number">4.</span> <span class="nav-text">CppBoostDay04</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E5%9B%9E%E9%A1%BE"><span class="nav-number">4.1.</span> <span class="nav-text">一、问题回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">二、条件变量的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E5%B0%81%E8%A3%85"><span class="nav-number">4.3.</span> <span class="nav-text">三、面向对象生产者与消费者封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">4.3.1.</span> <span class="nav-text">1、原理图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%9B%BE%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.3.2.</span> <span class="nav-text">2、类图设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">4.3.3.</span> <span class="nav-text">3、代码难点（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1%E3%80%81%E9%98%B2%E6%AD%A2%E6%AD%BB%E9%94%81"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">3.1、防止死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2%E3%80%81%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">3.2、虚假唤醒</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3%E3%80%81TaskQueue%E4%B8%AD%E7%9A%84push%E4%B8%8Epop%E5%AE%8C%E6%95%B4%E6%80%9D%E8%B7%AF"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">3.3、TaskQueue中的push与pop完整思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84run%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.3.4.</span> <span class="nav-text">3.4、生产者与消费者的run方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5%E3%80%81%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6"><span class="nav-number">4.3.3.5.</span> <span class="nav-text">3.5、禁止复制</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay05"><span class="nav-number">5.</span> <span class="nav-text">CppBoostDay05</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E5%9B%9E%E9%A1%BE-1"><span class="nav-number">5.1.</span> <span class="nav-text">一、问题回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84PC"><span class="nav-number">5.2.</span> <span class="nav-text">二、基于对象的PC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9B%BE-2"><span class="nav-number">5.2.1.</span> <span class="nav-text">1、类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9-2"><span class="nav-number">5.2.2.</span> <span class="nav-text">2、代码难点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84run%E7%9A%84%E6%94%B9%E9%80%A0"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">2.1、生产者与消费者的run的改造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">2.2、测试代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B0%81%E8%A3%85"><span class="nav-number">5.3.</span> <span class="nav-text">三、面向对象线程池封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.3.1.</span> <span class="nav-text">1、使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%9B%BE%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.3.2.</span> <span class="nav-text">2、类图的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9"><span class="nav-number">5.3.3.</span> <span class="nav-text">3、代码难点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1%E3%80%81%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E4%B8%8D%E5%AE%8C%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%B0%B1%E9%80%80%E5%87%BA%E4%BA%86"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">3.1、任务执行不完，程序就退出了</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%A0%E6%B3%95%E9%80%80%E5%87%BA"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">3.2、线程池无法退出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%8F%E5%88%97%E5%9B%BE"><span class="nav-number">5.3.4.</span> <span class="nav-text">4、面向对象的线程池序列图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay06"><span class="nav-number">6.</span> <span class="nav-text">CppBoostDay06</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B0%81%E8%A3%85"><span class="nav-number">6.1.</span> <span class="nav-text">一、基于对象的线程池封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9B%BE%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.1.1.</span> <span class="nav-text">1、类图设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9-3"><span class="nav-number">6.1.2.</span> <span class="nav-text">2、代码难点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E3%80%81doTask%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">2.1、doTask的注册与执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E3%80%81MyTask%E7%B1%BB%E4%B8%ADprocess%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">2.2、MyTask类中process的注册与执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="nav-number">6.2.</span> <span class="nav-text">二、计算机网络基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.2.1.</span> <span class="nav-text">1、协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81TCP-IP%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.2.2.</span> <span class="nav-text">2、TCP&#x2F;IP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%EF%BC%88-%E4%BA%86%E8%A7%A3-%EF%BC%89"><span class="nav-number">6.2.3.</span> <span class="nav-text">3、协议格式（&#x3D;&#x3D;了解&#x3D;&#x3D;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81TCP%E5%8D%8F%E8%AE%AE%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">6.2.4.</span> <span class="nav-text">4、TCP协议（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">6.2.4.1.</span> <span class="nav-text">三次握手（建立连接）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">6.2.4.2.</span> <span class="nav-text">四次挥手（断开连接）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E5%9B%BE%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">6.2.5.</span> <span class="nav-text">5、状态迁移图（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">6.3.</span> <span class="nav-text">三、网络编程（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80"><span class="nav-number">6.3.1.</span> <span class="nav-text">1、基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">6.3.2.</span> <span class="nav-text">2、字节序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE%EF%BC%88%E9%80%BB%E8%BE%91%E5%9B%BE%EF%BC%89"><span class="nav-number">6.3.3.</span> <span class="nav-text">3、网络通信的原理图（逻辑图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">6.3.4.</span> <span class="nav-text">4、网络通信常规函数（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1%E3%80%81socket%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.4.1.</span> <span class="nav-text">4.1、socket函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2%E3%80%81bind%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.4.2.</span> <span class="nav-text">4.2、bind函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3%E3%80%81listen%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.4.3.</span> <span class="nav-text">4.3、listen函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4%E3%80%81accept%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.4.4.</span> <span class="nav-text">4.4、accept函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5%E3%80%81close%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.4.5.</span> <span class="nav-text">4.5、close函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6%E3%80%81connect%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.4.6.</span> <span class="nav-text">4.6、connect函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7%E3%80%81%E8%AF%BB%E6%95%B0%E6%8D%AEread-recv"><span class="nav-number">6.3.4.7.</span> <span class="nav-text">4.7、读数据read&#x2F;recv</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-8%E3%80%81%E5%86%99%E6%95%B0%E6%8D%AEwrite-send"><span class="nav-number">6.3.4.8.</span> <span class="nav-text">4.8、写数据write&#x2F;send</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.5.</span> <span class="nav-text">5、代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay07"><span class="nav-number">7.</span> <span class="nav-text">CppBoostDay07</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E5%9B%9E%E9%A1%BE-2"><span class="nav-number">7.1.</span> <span class="nav-text">一、问题回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">二、端口复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E9%87%8D%E9%9A%BE%E7%82%B9"><span class="nav-number">7.3.</span> <span class="nav-text">三、IO多路复用(&#x3D;&#x3D;重难点&#x3D;&#x3D;)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0%E3%80%81%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">7.3.1.</span> <span class="nav-text">0、原理图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81select%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.2.</span> <span class="nav-text">1、select的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1%E3%80%81%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">1.1、函数接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2%E3%80%81%E4%BD%8D%E5%9B%BE"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">1.2、位图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">1.3、优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81poll%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.3.</span> <span class="nav-text">2、poll的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E3%80%81%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.3.3.1.</span> <span class="nav-text">2.1、函数接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">7.3.3.2.</span> <span class="nav-text">2.2、优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81epoll%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.4.</span> <span class="nav-text">3、epoll的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1%E3%80%81%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.3.4.1.</span> <span class="nav-text">3.1、函数接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">7.3.4.2.</span> <span class="nav-text">3.2、优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3%E3%80%81%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%88-%E4%BA%86%E8%A7%A3-%EF%BC%89"><span class="nav-number">7.3.4.3.</span> <span class="nav-text">3.3、两种模式（&#x3D;&#x3D;了解&#x3D;&#x3D;）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%815%E7%A7%8D%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">7.4.</span> <span class="nav-text">四、5种网络IO模型（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%98%BB%E5%A1%9E%E5%BC%8FIO"><span class="nav-number">7.4.1.</span> <span class="nav-text">1、阻塞式IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO"><span class="nav-number">7.4.2.</span> <span class="nav-text">2、非阻塞式IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">7.4.3.</span> <span class="nav-text">3、IO多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-number">7.4.4.</span> <span class="nav-text">4、信号驱动IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%BC%82%E6%AD%A5IO"><span class="nav-number">7.4.5.</span> <span class="nav-text">5、异步IO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81Reactor%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">7.5.</span> <span class="nav-text">五、Reactor的基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay08"><span class="nav-number">8.</span> <span class="nav-text">CppBoostDay08</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E5%9B%9E%E9%A1%BE-3"><span class="nav-number">8.1.</span> <span class="nav-text">一、问题回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81ReactorV1%E7%89%88%E6%9C%AC"><span class="nav-number">8.2.</span> <span class="nav-text">二、ReactorV1版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">8.2.1.</span> <span class="nav-text">1、类的设计过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%9B%BE%E8%AE%BE%E8%AE%A1-1"><span class="nav-number">8.2.2.</span> <span class="nav-text">2、类图设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%87%8D%E9%9A%BE%E7%82%B9"><span class="nav-number">8.2.3.</span> <span class="nav-text">3、重难点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay09"><span class="nav-number">9.</span> <span class="nav-text">CppBoostDay09</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81ReactorV2%E7%89%88%E6%9C%AC%EF%BC%88-%E9%87%8D%E9%9A%BE%E7%82%B9-%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">一、ReactorV2版本（&#x3D;&#x3D;重难点&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%80%E6%9C%AC%E8%B4%A8%E7%9A%84%E6%98%AF%E5%A4%84%E7%90%86%E4%B8%89%E4%B8%AA%E5%8D%8A%E4%BA%8B%E4%BB%B6"><span class="nav-number">9.1.1.</span> <span class="nav-text">1、TCP网络编程最本质的是处理三个半事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%B1%BB%E5%9B%BE%E8%AE%BE%E8%AE%A1-2"><span class="nav-number">9.1.2.</span> <span class="nav-text">2、类图设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9%EF%BC%88-%E9%87%8D%E9%9A%BE%E7%82%B9-%EF%BC%89"><span class="nav-number">9.1.3.</span> <span class="nav-text">3、代码难点（&#x3D;&#x3D;重难点&#x3D;&#x3D;）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1%E3%80%81%E9%94%AE%E5%80%BC%E5%AF%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">9.1.3.1.</span> <span class="nav-text">3.1、键值对的数据成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2%E3%80%81EventLoop%E4%B8%AD%E4%B8%89%E4%B8%AA%E5%9B%9E%E8%B0%83%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">9.1.3.2.</span> <span class="nav-text">3.2、EventLoop中三个回调数据成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3%E3%80%81EventLoop%E4%B8%AD%E4%B8%89%E4%B8%AA%E5%9B%9E%E8%B0%83%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">9.1.3.3.</span> <span class="nav-text">3.3、EventLoop中三个回调的注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4%E3%80%81EventLoop%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9B%91%E5%90%AC-fd"><span class="nav-number">9.1.3.4.</span> <span class="nav-text">3.4、EventLoop构造函数中监听 fd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5%E3%80%81%E8%8E%B7%E5%8F%96vector%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-number">9.1.3.5.</span> <span class="nav-text">3.5、获取vector首元素的地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6%E3%80%81waitEpollFd%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.1.3.6.</span> <span class="nav-text">3.6、waitEpollFd的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7%E3%80%81handleNewConnection%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="nav-number">9.1.3.7.</span> <span class="nav-text">3.7、handleNewConnection的实现（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8%E3%80%81EventLoop%E4%B8%AD%E7%9A%84handleMessage"><span class="nav-number">9.1.3.8.</span> <span class="nav-text">3.8、EventLoop中的handleMessage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9%E3%80%81TcpConnection%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%81%9A%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">9.1.3.9.</span> <span class="nav-text">3.9、TcpConnection中注册回调函数做数据成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-10%E3%80%81TcpConnection%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">9.1.3.10.</span> <span class="nav-text">3.10、TcpConnection中的三个回调函数的注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-11%E3%80%81%E9%98%B2%E6%AD%A2%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E8%AF%AF%E7%94%A8"><span class="nav-number">9.1.3.11.</span> <span class="nav-text">3.11、防止智能指针的误用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81ReactorV3%E7%89%88%E6%9C%AC"><span class="nav-number">9.2.</span> <span class="nav-text">二、ReactorV3版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9B%BE%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">9.2.1.</span> <span class="nav-text">1、类图的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">9.2.2.</span> <span class="nav-text">2、代码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E3%80%81%E5%AD%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">9.2.2.1.</span> <span class="nav-text">2.1、子对象的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">9.2.2.2.</span> <span class="nav-text">2.2、服务器的启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3%E3%80%81%E4%B8%89%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%90%8C%E6%97%B6%E6%B3%A8%E5%86%8C"><span class="nav-number">9.2.2.3.</span> <span class="nav-text">2.3、三个回调函数同时注册</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81ReactorV4%E7%89%88%E6%9C%AC"><span class="nav-number">9.3.</span> <span class="nav-text">三、ReactorV4版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81v3%E7%89%88%E6%9C%AC%E7%9A%84%E7%93%B6%E9%A2%88"><span class="nav-number">9.3.1.</span> <span class="nav-text">1、v3版本的瓶颈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81V4%E7%89%88%E6%9C%AC%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%BE"><span class="nav-number">9.3.2.</span> <span class="nav-text">2、V4版本的逻辑图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81eventfd%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">9.4.</span> <span class="nav-text">四、eventfd的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BD%9C%E7%94%A8"><span class="nav-number">9.4.1.</span> <span class="nav-text">1、作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.4.2.</span> <span class="nav-text">2、函数接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%B0%81%E8%A3%85eventfd"><span class="nav-number">9.4.3.</span> <span class="nav-text">3、封装eventfd</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1%E3%80%81%E7%B1%BB%E5%9B%BE"><span class="nav-number">9.4.3.1.</span> <span class="nav-text">3.1、类图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9"><span class="nav-number">9.4.3.2.</span> <span class="nav-text">3.2、代码难点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#3-2-1%E3%80%81EventFd%E7%9A%84start%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.4.3.2.1.</span> <span class="nav-text">3.2.1、EventFd的start函数实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-2-2%E3%80%81%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E6%96%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E4%B8%BB%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">9.4.3.2.2.</span> <span class="nav-text">3.2.2、自己构建新的线程，然后主子线程之间通信</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay10"><span class="nav-number">10.</span> <span class="nav-text">CppBoostDay10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81ReactorV4%E7%89%88%E6%9C%AC"><span class="nav-number">10.1.</span> <span class="nav-text">一、ReactorV4版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9B%BE%E8%AE%BE%E8%AE%A1-1"><span class="nav-number">10.1.1.</span> <span class="nav-text">1、类图设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E9%9A%BE%E7%82%B9-4"><span class="nav-number">10.1.2.</span> <span class="nav-text">2、代码难点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E3%80%81TcpConnection%E4%B8%AD%E7%9A%84sendInLoop%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.2.1.</span> <span class="nav-text">2.1、TcpConnection中的sendInLoop函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E3%80%81EventLoop%E4%B8%AD%E7%9A%84runInLoop"><span class="nav-number">10.1.2.2.</span> <span class="nav-text">2.2、EventLoop中的runInLoop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3%E3%80%81EventLoop%E4%B8%AD%E7%9A%84doPengdingFunctors"><span class="nav-number">10.1.2.3.</span> <span class="nav-text">2.3、EventLoop中的doPengdingFunctors</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0onMessage%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">10.1.2.4.</span> <span class="nav-text">2.4、测试代码中的回调函数onMessage与线程池的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5%E3%80%81MyTask%E4%B8%AD%E7%9A%84process%E7%9A%84%E5%88%86%E6%9E%90"><span class="nav-number">10.1.2.5.</span> <span class="nav-text">2.5、MyTask中的process的分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">10.1.3.</span> <span class="nav-text">3、流程图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CppBoostDay11"><span class="nav-number">11.</span> <span class="nav-text">CppBoostDay11</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81ReactorV5%E7%89%88%E6%9C%AC"><span class="nav-number">11.1.</span> <span class="nav-text">一、ReactorV5版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9B%BE%E8%AE%BE%E8%AE%A1-2"><span class="nav-number">11.1.1.</span> <span class="nav-text">1、类图设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81timerfd%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">11.2.</span> <span class="nav-text">二、timerfd的封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81timerfd%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">11.2.1.</span> <span class="nav-text">1、timerfd的基本特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3-1"><span class="nav-number">11.2.2.</span> <span class="nav-text">2、函数接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81timerfd%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">11.2.3.</span> <span class="nav-text">3、timerfd的封装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1%E3%80%81%E5%B0%81%E8%A3%85"><span class="nav-number">11.2.3.1.</span> <span class="nav-text">3.1、封装</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李新乾"
      src="/images/cat.png">
  <p class="site-author-name" itemprop="name">李新乾</p>
  <div class="site-description" itemprop="description">命由我做，福自己求</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lxq-02" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lxq-02" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://chatgpt.com/" title="Chatgpt → https:&#x2F;&#x2F;chatgpt.com" rel="noopener" target="_blank"><i class="fas fa-robot fa-fw"></i>Chatgpt</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      链接网站
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mail.qq.com/" title="https:&#x2F;&#x2F;mail.qq.com" rel="noopener" target="_blank">QQ邮箱</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://outlook.live.com/" title="https:&#x2F;&#x2F;outlook.live.com" rel="noopener" target="_blank">Outlook</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fishc.com.cn/" title="https:&#x2F;&#x2F;fishc.com.cn" rel="noopener" target="_blank">鱼C论坛</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李新乾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset);
            clearInterval(int);
        }
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据
            clearInterval(int); // 停止检测
        }
    }

});
</script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
