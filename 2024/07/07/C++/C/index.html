<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="0、简介解释：借助一个程序，这个程序能理解我的程序，然后按照我的要求来执行。下次进行的时候，再将我的程序变成这个程序，执行代码。 编译：借助一个程序，就像一个翻译，把我的程序翻译成计算机真正能懂的语言——机器语言——写的程序，然后，这个机器语言写的程序就能直接执行了。不运行我写的程序。 0.1、历史 20世纪60年代，Martin Richards开发了BCPL（Basic Combined Pr">
<meta property="og:type" content="article">
<meta property="og:title" content="C">
<meta property="og:url" content="http://example.com/2024/07/07/C++/C/index.html">
<meta property="og:site_name" content="李新乾的个人博客">
<meta property="og:description" content="0、简介解释：借助一个程序，这个程序能理解我的程序，然后按照我的要求来执行。下次进行的时候，再将我的程序变成这个程序，执行代码。 编译：借助一个程序，就像一个翻译，把我的程序翻译成计算机真正能懂的语言——机器语言——写的程序，然后，这个机器语言写的程序就能直接执行了。不运行我写的程序。 0.1、历史 20世纪60年代，Martin Richards开发了BCPL（Basic Combined Pr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220510195402458.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220510195415794.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220510195423842.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220503201747169.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220501192241059.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20211230151925588.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220502165646344.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220502165811641.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220428151351597.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220105153436668.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220105153458339.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/c-arrays-2021-1-18-4.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/c-array-2021-01-18-2.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220630165042849.png">
<meta property="og:image" content="http://example.com/2024/07/07/C++/C/image-20220630164400362.png">
<meta property="article:published_time" content="2024-07-07T04:00:00.000Z">
<meta property="article:modified_time" content="2024-09-12T01:12:22.054Z">
<meta property="article:author" content="李新乾">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/07/C++/C/image-20220510195402458.png">

<link rel="canonical" href="http://example.com/2024/07/07/C++/C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C | 李新乾的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="李新乾的个人博客" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李新乾的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/07/C++/C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="李新乾">
      <meta itemprop="description" content="命由我做，福自己求">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李新乾的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C
        </h1>

        <div class="post-meta">
	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-07-07T12:00:00+08:00">2024-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-12 09:12:22" itemprop="dateModified" datetime="2024-09-12T09:12:22+08:00">2024-09-12</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0、简介"><a href="#0、简介" class="headerlink" title="0、简介"></a>0、简介</h1><p>解释：借助一个程序，这个程序能理解我的程序，然后按照我的要求来执行。下次进行的时候，再将我的程序变成这个程序，执行代码。</p>
<p>编译：借助一个程序，就像一个翻译，把我的程序翻译成计算机真正能懂的语言——机器语言——写的程序，然后，这个机器语言写的程序就能直接执行了。不运行我写的程序。</p>
<h2 id="0-1、历史"><a href="#0-1、历史" class="headerlink" title="0.1、历史"></a>0.1、历史</h2><ul>
<li>20世纪60年代，Martin Richards开发了BCPL（Basic Combined Programming Language）</li>
<li>20世纪70年代，Ken  Thompson在继承BCPL的基础上发明了B语言</li>
<li>1972年，贝尔实验室的Dennis Ritchie和Brian kernighan在B语言的基础上,作了进一步的充实和完善，设计出了C语言。</li>
<li>C语言最开始是为了编写UNIX操作系统</li>
<li>BCPL和B斗支持指针间接方式，所以C也支持了</li>
<li>C语言还受到了PL&#x2F;I的影响，还和PDP-II的机器语言有很大的关系</li>
<li>1973年3月，第三版的Unix上出现了C语言的编辑器</li>
<li>1973年11月，第四版的Unix（System Four）发布了，这个版本是完全用C语言重新写的</li>
</ul>
<h2 id="0-2、发展和版本"><a href="#0-2、发展和版本" class="headerlink" title="0.2、发展和版本"></a>0.2、发展和版本</h2><ul>
<li>经典C<ul>
<li>又被叫做“K&amp;R the C”</li>
</ul>
</li>
<li>1989年ANSI发布了第一个标准——ANSI C</li>
<li>1990年ISO接受了ANSI的标准——C89</li>
<li>C的标准在1995年和1999年两次更新——C95和C99</li>
<li>所有当代编辑器都支持C99</li>
</ul>
<h2 id="0-3、C语言用在哪里"><a href="#0-3、C语言用在哪里" class="headerlink" title="0.3、C语言用在哪里"></a>0.3、C语言用在哪里</h2><ul>
<li>操作系统</li>
<li>嵌入式系统</li>
<li>驱动程序</li>
<li>底层驱动<ul>
<li>图形引擎、图像处理</li>
</ul>
</li>
</ul>
<h2 id="0-4、注意"><a href="#0-4、注意" class="headerlink" title="0.4、注意"></a>0.4、注意</h2><p>C语言是一种工业语言</p>
<p>开发效率》》学习过程</p>
<p>开发效率》》开发乐趣</p>
<p>日常应用很少用C语言编写</p>
<p>学习C的过程主要是写练习代码</p>
<h2 id="0-5、编辑—-运行"><a href="#0-5、编辑—-运行" class="headerlink" title="0.5、编辑—&gt;运行"></a>0.5、编辑—&gt;运行</h2><ul>
<li>C需要被编译才能运行，所以需要<ul>
<li>编辑器</li>
<li>编译器</li>
</ul>
</li>
<li>或者，IDE（集成开发环境）</li>
</ul>
<h2 id="0-6、输出的格式"><a href="#0-6、输出的格式" class="headerlink" title="0.6、输出的格式"></a>0.6、输出的格式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%d 		有符号<span class="number">10</span>进制整数 </span><br><span class="line">%<span class="number">6</span>d 	有符号<span class="number">10</span>进制整数，至少<span class="number">6</span>个字符宽 </span><br><span class="line">%i 		有符号<span class="number">10</span>进制整数 </span><br><span class="line">%o 		无符号<span class="number">8</span>进制整数 </span><br><span class="line">%u 		无符号<span class="number">10</span>进制整数 </span><br><span class="line">%x 		无符号的<span class="number">16</span>进制数字，并以小写abcdef表示</span><br><span class="line">%X 		无符号的<span class="number">16</span>进制数字，并以大写ABCDEF表示</span><br><span class="line">%F/f 	浮点数 </span><br><span class="line">%<span class="number">6f</span>		按照浮点数打印，至少<span class="number">6</span>个字符宽</span><br><span class="line">%<span class="number">.2</span>f	按照浮点数打印，小数点后有两位小数</span><br><span class="line">%<span class="number">6.2f</span> 	按照浮点数打印，至少<span class="number">6</span>个字符宽，小数点后有两位小数</span><br><span class="line">%E/e 	用科学表示格式的浮点数 </span><br><span class="line">%g 		使用%f和%e表示中的总的位数表示最短的来表示浮点数 G 同g格式，但表示为指数 </span><br><span class="line">%c 		单个字符 </span><br><span class="line">%s 		字符串</span><br><span class="line">%% 		表示百分号（%）本身</span><br></pre></td></tr></table></figure>

<h2 id="0-7、字符输入-输出"><a href="#0-7、字符输入-输出" class="headerlink" title="0.7、字符输入&#x2F;输出"></a>0.7、字符输入&#x2F;输出</h2><p>标准库的输入、输出是按照字符流的方式处理。文本流是由多行字符构成的字符序列，而每行由0个或多个字符构成，行末是一个换行符。</p>
<p>标准库提供了一次读&#x2F;写一个字符的函数。比如 getchar 和 putchar 函数。</p>
<p>每次调用时，getchar函数从文本流读入下一个输入字符，并将其作为结果值返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = getchar();</span><br></pre></td></tr></table></figure>

<p> 每次调用时，putchar函数将打印一个字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>();</span><br></pre></td></tr></table></figure>

<h3 id="1、文件复制"><a href="#1、文件复制" class="headerlink" title="1、文件复制"></a>1、文件复制</h3><p>借助 getchar 和 putchar 函数，可以输入复制到输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">    </span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c != EOF) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无论是什么字符，在机器内部都是以位模式存储。</span></span><br><span class="line"><span class="comment">//char类型专门用于存储这种字符型数据，任何整型（int）也可以存储。因为某些原因（我还不知道），使用int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在没有输入时，getchar函数会返回一个特殊值，这个值是EOF（end of file,文件结束）。</span></span><br><span class="line"><span class="comment">//EOF定义在头文件&lt;stdio.h&gt;中，是个整型数。</span></span><br><span class="line"><span class="comment">//EOF == -1</span></span><br></pre></td></tr></table></figure>

<h3 id="2、字符计数"><a href="#2、字符计数" class="headerlink" title="2、字符计数"></a>2、字符计数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//统计输入的所有字符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(getchar()!=EOF)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符的个数为：%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先输入回车，再输入Ctrl+Z，表示输入结束</p>
<p>输入缓冲是行缓冲。当从键盘上输入一串字符并按回车后，这些字符会首先被送到输入缓冲区中存储。每当按下回车键后，缓冲区中的可读的数据才会被检测。Ctrl+Z产生的不是一个普通的ASCII码值，也就是说它产生的不是一个字符，所以不会跟其它从键盘上输入的字符一样能够存放在输入缓冲区。如果输入缓冲区中有可读的数据则不会检测Ctrl+Z（因为有要读的数据，还不能认为到了流的末尾）。<br>       从键盘上输入abcd^z 加回车 之后在Windows系统上是这样处理的：由于回车的作用，前面的   abcd   等字符被送到输入缓冲区（注意：上面说过了，^z不会产生字符，所以更不会存储到输入缓冲区，缓冲区中没有   ^z   的存在）。这时，由于输入缓冲区中已经有数据存在，因此不再检查是否有   ^z   的输入，于是从缓冲中读取相应的数据。一旦都读取完了，则输入缓冲区重新变为空，进而等待新的输入。可见，尽管有   ^z   按下，但是由于在此之前还有其它输入字符（abcd），所以流也不会结束。</p>
<pre><code>    这种阻塞式的方式有一个特点：只有按下回车之后才有可能检测在此之前是否有Ctrl+Z按下。还有一个特点就是：如果输入缓冲区中有可读的数据则不会 检测Ctrl+Z（因为有要读的数据，还不能认为到了流的末尾）。还有一点需要知道：Ctrl+Z产生的不是一个普通的ASCII码值，也就是说它产生的 不是一个字符，所以不会跟其它从键盘上输入的字符一样能够存放在输入缓冲区。


     C PRIMER PLUS 第192页的解释是：   许多微型计算机系统将一行的开始位置键入的ctrl+z识别为文件尾信号，还有一些则把任意位置的ctrl+z解释成文件尾信号。 
     最后总结一下：
     windows认为，如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。
</code></pre>
<h3 id="3、行计数"><a href="#3、行计数" class="headerlink" title="3、行计数"></a>3、行计数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c, nl;</span><br><span class="line">	</span><br><span class="line">	nl = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((c = getchar()) != EOF)</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			++nl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-8、链接属性"><a href="#0-8、链接属性" class="headerlink" title="0.8、链接属性"></a>0.8、链接属性</h2><p><strong>链接属性</strong>(linkage)：决定如何处理在不同文件中出现的标识符。标识符的作用域与它的链接属性有关。</p>
<p><strong>分类：</strong></p>
<ul>
<li>external（外部）：标识符不管声明多少次、位于几个源文件都表示同一个实体</li>
<li>internal（内部）：标识符在同一个源文件内的所有声明中都指同一个实体，但位于不同源文件的多个声明则分属不同的实体</li>
<li>none（无）：当作单独的个体</li>
</ul>
<p>extern和static两个关键字可以用于设定标识符的链接属性。当没有这两个关键字时，默认的链接属性与标识符的作用域相关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c（<span class="type">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> g)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的代码块中，b、c、f有external链接属性，f在本代码中被调用，定义在其他源文件或者库中，所以也是external属性。其他的标识符都是none属性。</span></span><br></pre></td></tr></table></figure>

<p><strong>static</strong>关键字可以把一个默认为external属性的标识符改为internal，如上例中，可以把b、c的链接属性改为internal，使其在其他源文件中不可见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">c</span><span class="params">(<span class="type">int</span> d)</span>;</span><br></pre></td></tr></table></figure>

<p>extern 关键中可以把none属性改为external属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linkage_test1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a; <span class="comment">// 可选，因为默认就是external</span></span><br><span class="line">              <span class="comment">// 但是应该写上，增加程序可读性</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> b; <span class="comment">// 必需，默认为none</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，当extern关键字用于源文件中一个标识符的一次声明时，它指定该标识符具有external链接属性，但是，如果它用于该标识符的第2次或者以后的声明时，它并不会更改由第一次声明所指定的链接属性。如下例所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//i的链接属性仍然为static</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0-9、存储类型"><a href="#0-9、存储类型" class="headerlink" title="0.9、存储类型"></a>0.9、存储类型</h2><p>变量的存储类型是指存储变量值的内存类型。变量的存储类型决定变量何时创建、何时销毁以及它的值将保持多久。有三个地方可以用于存储变量：普通内存、运行时堆栈、硬件寄存器。在这三个地方存储的变量具有不同的特性。</p>
<ol>
<li><p>普通内存变量</p>
<p>变量的缺省存储类型取决于它声明的位置（作用域），凡是在任何代码块之外声明的变量总是存储与静态内存中，也就是不属于堆栈的内存，这类变量成为静态变量（static），可以通过static关键字将一个代码块内部变量由堆栈类型变为静态类型。静态类型的标识符存在ELF文件的.data（已初始化）或者.bss段（未初始化，默认值为0）。这些变量在程序未运行之前（通过内存加载）已经存在。</p>
</li>
<li><p>堆栈变量</p>
<p>在代码块内部声明的变量的默认存储类型是自动的（automatic），可以使用关键字auto指定，但它极少使用，因为完全没必要。这些自动变量存在堆栈中。</p>
</li>
<li><p>硬件寄存器变量</p>
<p>你可以通过关键字register来指定，提示程序运行时用硬件寄存器来存储该变量，但是编译器可以不鸟你，因为它认为它比你更清楚那个变量该用寄存器那个该用堆栈。</p>
</li>
</ol>
<p>变量的初始化</p>
<p>静态变量只能用常数进行初始化（其他静态变量都不行），如果未显性初始化，则默认值为0；</p>
<p>堆栈变量可以通过任何合法表达式初始化，因为它是在运行时创建，如果不初始化，其默认值为垃圾。</p>
<h1 id="一、程序结构"><a href="#一、程序结构" class="headerlink" title="一、程序结构"></a>一、程序结构</h1><h2 id="1-1、作用域与规则"><a href="#1-1、作用域与规则" class="headerlink" title="1.1、作用域与规则"></a>1.1、作用域与规则</h2><ol>
<li><p>代码块作用域<br>表示{}之间的区域，下例所示，a可以在不同代码块中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> g)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inner: %d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;outter: %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inline function:%d\n&quot;</span>, f(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*******************************************</span></span><br><span class="line"></span><br><span class="line">$ ./a.out</span><br><span class="line">inner: <span class="number">2</span></span><br><span class="line">outter: <span class="number">0</span></span><br><span class="line"><span class="keyword">inline</span> function:<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件作用域<br>任何在所有代码块之外声明的标识符都具有文件作用域（file scope）。并且，通过#include指令包含到其他文件中的声明就好像它们是直接写在那些文件中一样。它们的作用域并不局限于头文件的文件尾。</p>
</li>
<li><p>原型作用域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a)</span>;</span><br></pre></td></tr></table></figure>

<p>原型作用域（prototype scope）只适用于在函数原型中声明的参数名，将它独立出来只是为了这个名字不能与其他作用域的符号混淆，它其实没有什么用得，甚至都可以不写。事实上，唯一可能出现的冲突就是在同一个原型中不止一次使用同一个名字。</p>
</li>
<li><p>函数作用域<br>它只适用于语句标签，用于goto语句。</p>
</li>
</ol>
<hr>
<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\0’</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h2 id="1-2、头文件"><a href="#1-2、头文件" class="headerlink" title="1.2、头文件"></a>1.2、头文件</h2><p>如果一个程序很大，可以将程序分割，主函数单独放在main函数中，其他程序也单独放。其中共享的文件放在一个文件中，假设放在 calc.h中，我们可以在使用它的程序通过 <code>#include &quot;calc.h&quot;</code>包含进去</p>
<p>函数原型：</p>
<ul>
<li>如果不给出函数原型，编译器会猜测调用的函数的所有参数都是int，返回类型也是int</li>
<li>编译器在编译的时候只看当前的一个编译单元，它不会去看同一个项目中的其他编译单元</li>
</ul>
<p>头文件：</p>
<ul>
<li>把函数原型放到一个头文件（以.h结尾）中，需要调用这个函数的源代码文件（.c）</li>
</ul>
<h2 id="1-3、静态变量"><a href="#1-3、静态变量" class="headerlink" title="1.3、静态变量"></a>1.3、静态变量</h2><p>将对象指定为静态存储，可以在正常的对象声明之前加上关键字 static 作为修饰。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> bufp = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-4、寄存器变量"><a href="#1-4、寄存器变量" class="headerlink" title="1.4、寄存器变量"></a>1.4、寄存器变量</h2><p>register 声明告诉编译器，它所声明的变量在程序中的使用频率较高。其思想是，将register 变量放在机器的寄存器中，这样可以使程序更小，执行速度更快。但编译器可以忽略此选项。</p>
<p>声明格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">register</span> <span class="type">char</span> c;</span><br></pre></td></tr></table></figure>

<p>register 声明只适用用局部变量以及函数的形式参数。</p>
<p>函数的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="keyword">register</span> <span class="type">unsigned</span> m, <span class="keyword">register</span> <span class="type">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 实际使用时，底层硬件环境的实际情况对寄存器变量的使用有一些限制。每个函数中只有很少的变量可以保存在寄存器中，且只允许某些类型的变量。但是，过量的寄存器声明并没有什么坏处，这是因为编译器可以忽略过量的或不支持的寄存器变量声明。另外，无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的。不同的机器中，对寄存器变量的数目和类型的具体限制也是不同的。</p>
<h2 id="1-5、程序块结构"><a href="#1-5、程序块结构" class="headerlink" title="1.5、程序块结构"></a>1.5、程序块结构</h2><p>在函数中可以使用函数块结构的形式定义变量。变量的声明（包括初始化）除了可以紧跟在函数开始的花括号后，还可以紧跟在任何其他标识复合语句开始的左花括号之后。这样可以隐藏程序块外与之同名的变量，它们之间没有任何关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> y;</span><br><span class="line"><span class="keyword">if</span> (<span class="type">double</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6、初始化"><a href="#1-6、初始化" class="headerlink" title="1.6、初始化"></a>1.6、初始化</h2><p>在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为0，而自动变量和寄存器变量的初值则没有定义。（即初值为无用的信息）</p>
<p>定义标量变量时，可以在变量名后紧跟一个等号和一个表达式来初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> squtoa = <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line"><span class="type">long</span> day = <span class="number">1000L</span> * <span class="number">60L</span> * <span class="number">60L</span> *<span class="number">24L</span>;</span><br></pre></td></tr></table></figure>

<p>对于外部变量和静态变量来说，初始化表达式必须是常量表达式，且只初始化一次（在程序开始执行前初始化）</p>
<p>对于自动变量和寄存器变量，则在每次进入函数或程序块时都将被初始化。可以不是常量，可以包含此前已经定义过的值，包括函数调用。</p>
<p>数组的初始化可以在声明后面紧跟一个初始化表达式列表，初始化表达式用花括号括起来，各初始化表达式之间用逗号分割。比如，一年的天数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>字符数组的初始化：可以使用一个字符串来代替花括号并用逗号分割的初始化表达式序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> pattern[] = <span class="string">&quot;ould&quot;</span>;</span><br><span class="line"><span class="type">char</span> pattern[] = &#123;<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//两种声明方式等价，数组长度为5，4个字符加上一个字符串结束字符&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-7、编译预处理和宏"><a href="#1-7、编译预处理和宏" class="headerlink" title="1.7、编译预处理和宏"></a>1.7、编译预处理和宏</h2><p>C语言通过预处理器提供了一些语言功能。</p>
<p>从概念上讲，预处理器是编译过程中单独执行的第一个步骤。</p>
<p>两个最常见的预处理指令：</p>
<ul>
<li>#include 指令（用于在编译期间把指定文件的内容包含进当前文件中）</li>
<li>#define 指令（用任意字符替代一个标记）</li>
</ul>
<h3 id="1、文件包含"><a href="#1、文件包含" class="headerlink" title="1、文件包含"></a>1、文件包含</h3><p>文件包含指令（即#include指令）</p>
<p>在源文件中，任何形如：#include “文件名” 或 #include &lt;文件名&gt; 的行，都将被替换为由文件名指定的文件的内容。</p>
<p>如果文件名是用<strong>引号</strong>引起来的，则在源文件所在的位置查找该文件；</p>
<p>如果在该位置没有找到该文件，或者用尖括号括起来，则根据相应的规则查找。</p>
<p>源文件的开始通常会有多个 #include指令，它们用以包含常见的#define语句和extern声明，或从头文件中访问库函数的函数原型声明，比如&lt;stdio.h&gt;</p>
<p>#include不是用来引入库的，它是用来引入响应的函数原型的。现在的编译器默认会引入所有的标准库</p>
<p>两种插入方式</p>
<ul>
<li>“”要求首先在当前目录查找，然后再在编译器指定的目录查找</li>
<li>&lt;&gt;让编译器只在指定的目录查找</li>
<li>编译器知道自己的标注头文件在哪里</li>
</ul>
<p>extern int i;是变量的声明<br>int i;是变量的定义</p>
<h3 id="2、宏"><a href="#2、宏" class="headerlink" title="2、宏"></a>2、宏</h3><ul>
<li><p>宏定义的形式：#define 名字 替换文本</p>
</li>
<li><p>后续所有出现名字记号的地方都将被替换为 替换文本。</p>
</li>
<li><p>名字与变量名的命名方式相同，替换文本可以是任意字符串。</p>
</li>
<li><p>注意没有结尾的分号，因为不是C的语句</p>
</li>
<li><p>#define指令占一行，替换文本是这一行的所有剩余内容，但也可以把一个较长的宏定义分成若干行，这是需要在行末尾加上一个反斜杠符.</p>
</li>
<li><p>作用域从定义点开始到编译文件结束为止。</p>
</li>
</ul>
<p><strong>注意：</strong>替换只对记号进行，对括在引号中的字符串不起作用。<br>        比如：如果YES是定义过的替换文本，<code>printf(&quot;YES&quot;);</code>不会被替换</p>
<p>带参数的宏</p>
<ul>
<li><pre><code class="c">#define cube(x) ((x)*(x)*(x))
//宏也可以带参数
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 宏定义是将替换文本直接加到响应的代码处，所以一定要加括号</span><br><span class="line"></span><br><span class="line">- 可以加多个参数`#define max(A, B) ((A) &gt; (B) ? (A); (B))`，</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**取消宏定义**：通过#undef，可以保证后续的调用是函数调用，而不是宏调用</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#undef getchar	//getchar是宏定义</span><br><span class="line">int getchar(void)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="3、条件包含"><a href="#3、条件包含" class="headerlink" title="3、条件包含"></a>3、条件包含</h3><p><img src="/2024/07/07/C++/C/image-20220510195402458.png" alt="image-20220510195402458"> </p>
<p><img src="/2024/07/07/C++/C/image-20220510195415794.png" alt="image-20220510195415794"> </p>
<p><img src="/2024/07/07/C++/C/image-20220510195423842.png" alt="image-20220510195423842"> </p>
<h2 id="1-8、全局变量"><a href="#1-8、全局变量" class="headerlink" title="1.8、全局变量"></a>1.8、全局变量</h2><h3 id="1、全局变量"><a href="#1、全局变量" class="headerlink" title="1、全局变量"></a>1、全局变量</h3><p>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。</p>
<p>外部变量可以在全局范围内访问。任何函数都可以通过名字访问一个外部变量。</p>
<p>全局变量初始化：<br>没有初始化的全局变量默认会得到0值，指针会得到NULL值<br>只能用编译时刻已知的值来初始化全局变量，全局变量不能初始化全局变量</p>
<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。</p>
<p>1. </p>
<p>1. </p>
<p>全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、静态本地变量"><a href="#2、静态本地变量" class="headerlink" title="2、静态本地变量"></a>2、静态本地变量</h3><ul>
<li>在本地变量定义时，加上static修饰就成为静态本地变量</li>
<li>当函数离开的时候，静态本地变量会继续存在并保持其值</li>
<li>静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值</li>
<li>静态本地变量实际上是特殊的全局变量</li>
<li>他们位于相同的内存区域</li>
<li>静态本地变量具有全局的生存期，函数内的局部作用域<ul>
<li>static在这里的意思是局部作用域（本地可访问）</li>
</ul>
</li>
</ul>
<h3 id="3、返回指针的函数"><a href="#3、返回指针的函数" class="headerlink" title="3、返回指针的函数"></a>3、返回指针的函数</h3><ul>
<li><p>返回本地变量的地址是危险的，离开本地变量的函数后，函数就没有了，地址空间就会被其他函数所使用</p>
</li>
<li><p>返回全局变量和静态本地变量的地址是安全的</p>
</li>
<li><p>返回在函数内的malloc内存是安全的，但是容易造成问题</p>
</li>
<li><p>最好的做法是返回传入的指针</p>
</li>
<li><p>不要使用全局变量在函数间传递参数或结果</p>
</li>
</ul>
<h2 id="1-9、标准头文件结构"><a href="#1-9、标准头文件结构" class="headerlink" title="1.9、标准头文件结构"></a>1.9、标准头文件结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _NODE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	_NODE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;node.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>运用条件编译和宏，保证这个头文件在一个编译单元只会被#include一次</li>
</ul>
<h1 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h1><p>C 程序由各种令牌组成，令牌可以是<strong>关键字、标识符、常量、字符串值，或者是一个符号</strong>。例如，下面的 C 语句包括五个令牌：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这五个令牌分别是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span></span><br><span class="line">(</span><br><span class="line"><span class="string">&quot;Hello, World! \n&quot;</span></span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="2-1、分号"><a href="#2-1、分号" class="headerlink" title="2.1、分号"></a>2.1、分号</h2><p>在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p>
<p>例如，下面是两个不同的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、注释"><a href="#2-2、注释" class="headerlink" title="2.2、注释"></a>2.2、注释</h2><p><strong>C 语言有两种注释方式：</strong></p>
<p>以 <strong>&#x2F;&#x2F;</strong> 开始的单行注释，这种注释可以单独占一行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;* *&#x2F;</strong> 这种格式的注释可以单行或多行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单行注释 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3、标识符"><a href="#2-3、标识符" class="headerlink" title="2.3、标识符"></a>2.3、标识符</h2><p>C 标识符是用来标识<strong>变量</strong>、<strong>函数</strong>，或<strong>任何其他用户自定义项目的名称</strong>。</p>
<p>一个标识符以字母 ，数字以及下划线 _ 组成，第一个字母不能是数字。</p>
<p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。</p>
<p>C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，<em>Manpower</em> 和 <em>manpower</em> 是两个不同的标识符。下面列出几个有效的标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mohd       zara    abc   move_name  a_123</span><br><span class="line">myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure>

<h2 id="2-4、关键字"><a href="#2-4、关键字" class="headerlink" title="2.4、关键字"></a>2.4、关键字</h2><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th>个数</th>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">auto</td>
<td align="left">声明自动变量</td>
</tr>
<tr>
<td>2</td>
<td align="left">break</td>
<td align="left">跳出当前循环</td>
</tr>
<tr>
<td>3</td>
<td align="left">case</td>
<td align="left">开关语句分支</td>
</tr>
<tr>
<td>4</td>
<td align="left">char</td>
<td align="left">声明字符型变量或函数返回值类型</td>
</tr>
<tr>
<td>5</td>
<td align="left">const</td>
<td align="left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td>
</tr>
<tr>
<td>6</td>
<td align="left">continue</td>
<td align="left">结束当前循环，开始下一轮循环</td>
</tr>
<tr>
<td>7</td>
<td align="left">default</td>
<td align="left">开关语句中的”其它”分支</td>
</tr>
<tr>
<td>8</td>
<td align="left">do</td>
<td align="left">循环语句的循环体</td>
</tr>
<tr>
<td>9</td>
<td align="left">double</td>
<td align="left">声明双精度浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td>10</td>
<td align="left">else</td>
<td align="left">条件语句否定分支（与 if 连用）</td>
</tr>
<tr>
<td>11</td>
<td align="left">enum</td>
<td align="left">声明枚举类型</td>
</tr>
<tr>
<td>12</td>
<td align="left">extern</td>
<td align="left">声明变量或函数是在其它文件或本文件的其他位置定义</td>
</tr>
<tr>
<td>13</td>
<td align="left">float</td>
<td align="left">声明浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td>14</td>
<td align="left">for</td>
<td align="left">一种循环语句</td>
</tr>
<tr>
<td>15</td>
<td align="left">goto</td>
<td align="left">无条件跳转语句</td>
</tr>
<tr>
<td>16</td>
<td align="left">if</td>
<td align="left">条件语句</td>
</tr>
<tr>
<td>17</td>
<td align="left">int</td>
<td align="left">声明整型变量或函数</td>
</tr>
<tr>
<td>18</td>
<td align="left">long</td>
<td align="left">声明长整型变量或函数返回值类型</td>
</tr>
<tr>
<td>19</td>
<td align="left">register</td>
<td align="left">声明寄存器变量</td>
</tr>
<tr>
<td>20</td>
<td align="left">return</td>
<td align="left">子程序返回语句（可以带参数，也可不带参数）</td>
</tr>
<tr>
<td>21</td>
<td align="left">short</td>
<td align="left">声明短整型变量或函数</td>
</tr>
<tr>
<td>22</td>
<td align="left">signed</td>
<td align="left">声明有符号类型变量或函数</td>
</tr>
<tr>
<td>23</td>
<td align="left">sizeof</td>
<td align="left">计算数据类型或变量长度（即所占字节数）</td>
</tr>
<tr>
<td>24</td>
<td align="left">static</td>
<td align="left">声明静态变量</td>
</tr>
<tr>
<td>25</td>
<td align="left">struct</td>
<td align="left">声明结构体类型</td>
</tr>
<tr>
<td>26</td>
<td align="left">switch</td>
<td align="left">用于开关语句</td>
</tr>
<tr>
<td>27</td>
<td align="left">typedef</td>
<td align="left">用以给数据类型取别名<br><code>typedef int ElemType</code>就是自定义了一个类型，这个类型等价于int。</td>
</tr>
<tr>
<td>28</td>
<td align="left">unsigned</td>
<td align="left">声明无符号类型变量或函数</td>
</tr>
<tr>
<td>29</td>
<td align="left">union</td>
<td align="left">声明共用体类型</td>
</tr>
<tr>
<td>30</td>
<td align="left">void</td>
<td align="left">声明函数无返回值或无参数，声明无类型指针</td>
</tr>
<tr>
<td>31</td>
<td align="left">volatile</td>
<td align="left">说明变量在程序执行中可被隐含地改变</td>
</tr>
<tr>
<td>32</td>
<td align="left">while</td>
<td align="left">循环语句的循环条件</td>
</tr>
<tr>
<td>33</td>
<td align="left">inline</td>
<td align="left">inline关键字是用于函数声明或定义，可以把函数指定为内联函数</td>
</tr>
<tr>
<td>34</td>
<td align="left">restrict</td>
<td align="left">关键字restrict只用于限定指针，表明本指针是访问一个数据对象的惟一且初始的方式。</td>
</tr>
</tbody></table>
<h2 id="2-5、C中的空格"><a href="#2-5、C中的空格" class="headerlink" title="2.5、C中的空格"></a>2.5、C中的空格</h2><p>只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。</p>
<p>在 C 中，空格用于描述空白符、制表符(Tab)、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br></pre></td></tr></table></figure>

<p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruit = apples + oranges;   <span class="comment">// 获取水果的总数</span></span><br></pre></td></tr></table></figure>

<p>fruit 和 &#x3D;，或者 &#x3D; 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p>
<h1 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h1><ul>
<li>C语言的变量，必须<ul>
<li>在使用前定义</li>
<li>确定类型</li>
</ul>
</li>
</ul>
<p>在C语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。</p>
<p>变量的类型决定了<strong>变量存储占用的空间</strong>，以及如何解释存储的位模式。</p>
<p><strong>类型的不同</strong></p>
<p>类型名称：int、long、double<br>• 输⼊输出时的格式化：%d、%ld、%lf<br>• 所表达的数的范围：char &lt; short &lt; int &lt; float &lt; double<br>• 内存中所占据的⼤⼩：1个字节到16个字节<br>• 内存中的表达形式：⼆进制数（补码）、编码</p>
<h2 id="3-1、整数类型"><a href="#3-1、整数类型" class="headerlink" title="3.1、整数类型"></a>3.1、整数类型</h2><p>整数在计算机内部是用补码表示的，正的和负的，相加会得到一个溢出的数，但这个数的各个位置都是0，1不用管</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>输入输出形式</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td>%c,%d</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td></td>
<td align="left">1 字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">unsigned</td>
<td>%u</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">int</td>
<td>%d</td>
<td align="left">2 或 4 字节<br>取决于编译器CPU<br>通常的意义是“一个字”</td>
<td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td></td>
<td align="left">2 或 4 字节</td>
<td align="left">0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left">short</td>
<td></td>
<td align="left">2 字节</td>
<td align="left">-32,768 到 32,767</td>
</tr>
<tr>
<td align="left">unsigned short</td>
<td></td>
<td align="left">2 字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">long</td>
<td></td>
<td align="left">4 字节<br>取决于编译器CPU<br>通常的意义是“一个字”</td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>各种类型的存储大小与系统位数有关，但目前通用的以64位系统有关。</p>
<h3 id="1、unsigned"><a href="#1、unsigned" class="headerlink" title="1、unsigned"></a>1、unsigned</h3><ul>
<li>在整数类型前加上unsigned使得他们成为无符号的整数</li>
<li>内部的二进制代码没有变，变的是如何看待他们</li>
<li>11111111<ul>
<li>对于char,是-1</li>
<li>对于unsigned char,是255</li>
</ul>
</li>
<li>如果一个常数想要表达自己是unsigned,可以在后面加上u或U<ul>
<li>255U</li>
</ul>
</li>
<li>用L或l表示long(long)</li>
<li>*unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位</li>
</ul>
<h3 id="2、进制"><a href="#2、进制" class="headerlink" title="2、进制"></a>2、进制</h3><p>八进制和十六进制</p>
<ul>
<li>一个以0开始的数字是8进制的</li>
<li>一个以0x开始的数据是16进制的</li>
<li>%o用于8进制，%x用于16进制</li>
<li>8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关</li>
</ul>
<h3 id="3、选择整数类型"><a href="#3、选择整数类型" class="headerlink" title="3、选择整数类型"></a>3、选择整数类型</h3><ul>
<li>为什么要有这么多类型<ul>
<li>为了准确表达内存，做底层程序的需要</li>
</ul>
</li>
<li>没有特殊需要，就<strong>选择int</strong><ul>
<li>现在的CPU的字长普遍是32位或64位，一次内存读写就是一个int,选择更短的类型不会更快，甚至可能更慢</li>
<li>现代的编译器一般会设计内存对齐，所以更短的类型在内存中可能也占用一个int大小（虽然sizeof告诉你更小）</li>
</ul>
</li>
</ul>
<h3 id="4、char"><a href="#4、char" class="headerlink" title="4、char"></a>4、char</h3><h2 id="3-2、浮点类型"><a href="#3-2、浮点类型" class="headerlink" title="3.2、浮点类型"></a>3.2、浮点类型</h2><table>
<thead>
<tr>
<th align="left">类型</th>
<th>scanf</th>
<th>printf</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
<th align="left">精度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">float</td>
<td>%f</td>
<td>%f<br>%e，以科学计数法输出</td>
<td align="left">4 字节</td>
<td align="left">1.2E-38 到 3.4E+38</td>
<td align="left">6 位有效位</td>
</tr>
<tr>
<td align="left">double</td>
<td>%lf</td>
<td>%f<br>%e，以科学计数法输出</td>
<td align="left">8 字节</td>
<td align="left">2.3E-308 到 1.7E+308</td>
<td align="left">15 位有效位</td>
</tr>
<tr>
<td align="left">long double</td>
<td></td>
<td></td>
<td align="left">16 字节</td>
<td align="left">3.4E-4932 到 1.1E+4932</td>
<td align="left">19 位有效位</td>
</tr>
</tbody></table>
<ul>
<li><p>带小数点的数值。</p>
</li>
<li><p>浮点这个词的本意就是指小数点是浮动的，是计算机内部表达非整数（包含分数和无理数）的一种方式。</p>
</li>
<li><p>当浮点数和整数一起计算时，C会将整数化为浮点数。</p>
</li>
<li><p>在%和f之间加上.n可以指定输出小数点后几位，这样做的输出是<strong>四舍五入的</strong></p>
</li>
<li><p>printf(“%.3f\n”,-0.0049);</p>
</li>
<li><p>超出范围的浮点数</p>
<ul>
<li><p>printf输出inf表⽰超过范围的浮点数：±∞，不能用整型表达</p>
</li>
<li><pre><code class="c">printf(&quot;%f\n&quot;, 12.0/0.0);
printf(&quot;%f\n&quot;, -12.0/0.0);
//输出
//inf
//-inf
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- printf输出nan表⽰不存在的浮点数</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  printf(&quot;%f\n&quot;, 0.0/0.0);</span><br><span class="line">  //结果</span><br><span class="line">  //nan</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>浮点运算的精度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a, b, c;</span><br><span class="line">a = <span class="number">1.345f</span>;</span><br><span class="line">b = <span class="number">1.123f</span>;</span><br><span class="line">c = a + b;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">2.468</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;相等\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;不相等！c = %.10f,或%f\n&quot;</span>, c, c);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//不相等！c = 2.4679999352,或2.468000</span></span><br><span class="line"><span class="comment">/*带小数点的字面量是double，而非float</span></span><br><span class="line"><span class="comment">	float需要用f或F后缀表明身份</span></span><br><span class="line"><span class="comment">	f1 == f2可能失败，它只表示一个范围，有误差，确定的数需要用整数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//判断相等</span></span><br><span class="line"><span class="comment">//fabs(f1-f2)&lt;1e-12</span></span><br></pre></td></tr></table></figure>

<p>浮点数的内部表达</p>
<p><img src="/2024/07/07/C++/C/image-20220503201747169.png" alt="image-20220503201747169"> </p>
<ul>
<li>浮点数在计算时是由专门的硬件部件实现的</li>
<li>它不是由二进制表示的，而是由编码部件完成</li>
<li>计算double和float所用的部件是一样的</li>
</ul>
<p>选择浮点类型</p>
<ul>
<li>如果没有特殊需要，只使用double</li>
<li>现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢</li>
</ul>
<p>头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 存储最大字节数 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 最小值: %E\n&quot;</span>, FLT_MIN );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 最大值: %E\n&quot;</span>, FLT_MAX );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;精度值: %d\n&quot;</span>, FLT_DIG );</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//float   double  long doble存储最大值</span></span><br><span class="line"><span class="comment">//FLT_MAX DBL_MAX LDBL_MAX</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> 存储最大字节数 : <span class="number">4</span> </span><br><span class="line"><span class="type">float</span> 最小值: <span class="number">1.175494E-38</span></span><br><span class="line"><span class="type">float</span> 最大值: <span class="number">3.402823E+38</span></span><br><span class="line">精度值: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>%E</strong> 为以指数形式输出单、双精度实数</p>
<h2 id="3-3、逻辑类型"><a href="#3-3、逻辑类型" class="headerlink" title="3.3、逻辑类型"></a>3.3、逻辑类型</h2><p>bool</p>
<ul>
<li>#include &lt;stdbool.h&gt;</li>
<li>之后就可以使用bool、true、false</li>
<li>bool实际上还是以int的手段实现的，所以可以当做int来计算，也只能当做int来输入输出</li>
</ul>
<h2 id="3-4、typedef定义类型"><a href="#3-4、typedef定义类型" class="headerlink" title="3.4、typedef定义类型"></a>3.4、typedef定义类型</h2><p>类型说明语句<code>typedef</code></p>
<p><strong>作用：</strong>为各种数据类型定义新的名字</p>
<p>一般形式为：<code>typedef 已定义的类型 新的类型;</code></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;<span class="comment">/*指定用 INTEGER 代表 int 类型*/</span></span><br><span class="line"><span class="type">int</span> i,j; <span class="comment">/*与INTEGER i,j;等价*/</span></span><br></pre></td></tr></table></figure>

<p>最常用的作用就是给结构体变量重命名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;INFO;	<span class="comment">//INFO是struct _INFO的别名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span> <span class="title">A</span>;</span></span><br><span class="line">        INFO B;    <span class="comment">//通过typedef重命名后的名字INFO与struct _INFO完全等价！</span></span><br><span class="line">        A.num = <span class="number">2014</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(A.str,<span class="string">&quot;Welcome to dotcpp.com&quot;</span>);</span><br><span class="line">        B=A;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This year is %d %s\n&quot;</span>,A.num,A.str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This year is %d %s\n&quot;</span>,B.num,B.str);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、常量、变量和运算符"><a href="#四、常量、变量和运算符" class="headerlink" title="四、常量、变量和运算符"></a>四、常量、变量和运算符</h1><h2 id="4-1、常量"><a href="#4-1、常量" class="headerlink" title="4.1、常量"></a>4.1、常量</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> AMOUNT = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>固定不变的数，是常数。直接写在程序里，我们称为直接量（literal）</li>
<li>const 是一个修饰符，加在 int 的前面，用来给这个变量加上一个const(不变的)的属性。这个const的属性表示这个变量的值一旦初始化，就不能再更改了</li>
<li>任何变量的声明都可以使用 const 限定符。对使用的变量而言，它的值都不能改变。</li>
<li>常量最好使用大写，表示强调，放在最开始，方便修改</li>
</ul>
<p><code>int</code> 类型的整数常量 比如： 1234</p>
<p>​		如果一个整数太大，超过<code>int</code>的范围，会当做<code>long</code>类型处理</p>
<p><code>long</code>类型的常量以字母<code>l</code>或<code>L</code>结尾，比如 123456789L</p>
<p>无符号常量以字母<code>u</code>或<code>U</code>结尾。后缀 ul 或 UL表明是 unsigned long 类型</p>
<p><strong>浮点数常量</strong>包含一个小数点（123.4）或一个指数（1e-2)，也可以两者都有。没有后缀的浮点数常量为 double 类型。后缀 f 或 F 表示 float 类型，而后缀 l 或 L 表示 long double 类型。</p>
<p>整型数还可用8进制或16进制表示：</p>
<ul>
<li>八进制形式：带前缀 0 。比如十进制 31 可写作 037</li>
<li>十六进制形式：带前缀 0x 或 0X。比如十进制31可写作 0x1f 或 0X1F。</li>
<li>使用后缀 L 表示 long 。</li>
<li>使用后缀 U 表示 unsigned 类型。比如 0XFUL，表示 unsigned long 类型（无符号长整型）的常量，等于十进制15。</li>
</ul>
<h3 id="2、转义字符"><a href="#2、转义字符" class="headerlink" title="2、转义字符"></a>2、转义字符</h3><p>某些字符可以通过转义字符序列表示为字符或字符串常量。</p>
<p><code>\ooo</code>表示任意的字节大小的位模式，ooo 表示1~3个八进制数字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VTAB <span class="string">&#x27;\013&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p><code>\xhh</code>中hh表示一个或多个十六进制数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VTAB <span class="string">&#x27;\xb&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>ANSI C语言中的全部转义字符序列</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意思</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃符</td>
</tr>
<tr>
<td>\b</td>
<td>回退符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符，到每行下一个固定的制表位</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表符</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>?</td>
<td>问号</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td>\ooo</td>
<td>八进制数</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制数</td>
</tr>
</tbody></table>
<h3 id="3、常量表达式"><a href="#3、常量表达式" class="headerlink" title="3、常量表达式"></a>3、常量表达式</h3><p>常量表达式是只包含常量的表达式。这种表达式在编译时求值，而不再运行时求值。可以出现在常量出现的任意地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1000</span></span><br><span class="line"><span class="type">char</span> line[MAXLINE+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h3 id="4、字符常量和字符串常量"><a href="#4、字符常量和字符串常量" class="headerlink" title="4、字符常量和字符串常量"></a>4、字符常量和字符串常量</h3><p>一个字符常量是一个整数，书写时将一个字符括在单括号中，如<code>&#39;x&#39;</code>。字符在机器字符集中的数值就是字符常量的值。例如，在 ASCII字符集中，字符<code>&#39;0&#39;</code>的值为48，它与字符 0 没有关系。字符常量一般用来与其他字符进行比较，但也可以像其他整型一样参与数值运算。</p>
<p>字符常量 <code>\0</code>表示值为 0 的字符，也就是空字符（null）。我们通常用 <code>\0</code>的形式代替 0 。</p>
<p>字符串常量也叫字符串面量，是由双括号括起来的 0 个或多个字符组成的字符序列。例如<code>&quot;I am a string&quot;</code>或<code>&quot;&quot;</code>（空字符串）</p>
<p>字符串常量就是字符数组。字符串的内部提供了一个空字符<code>\0</code>作为串的结尾。因此，存储字符串的物理存储单元比字符数多了一个。可以使用标准库函数 strlen(s)返回字符串参数 s 的长度，但长度不包括末尾的空字符 <code>\0</code>。</p>
<p>标准头文件&lt;string.h&gt;中声明了 strlen和其他字符串函数。</p>
<p>字符常量和仅包含一个字符的字符串是不同的。比如<code>&#39;x&#39;</code>和<code>&quot;x&quot;</code>，前者是一个整数，是字母x在机器字符集中对应的数值（内部表示值）；后者是包含一个字符x和一个结束符<code>\0</code>的字符数组。 </p>
<h3 id="5、枚举常量"><a href="#5、枚举常量" class="headerlink" title="5、枚举常量"></a>5、枚举常量</h3><p><img src="/2024/07/07/C++/C/image-20220501192241059.png" alt="image-20220501192241059"></p>
<h3 id="6、符号常量"><a href="#6、符号常量" class="headerlink" title="6、符号常量"></a>6、符号常量</h3><p>#define 指令可以把符号名（或称为符号常量）定义为一个特定的字符串：</p>
<p>#define 名字 替换文本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOWER 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPPER 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP 20</span></span><br></pre></td></tr></table></figure>

<p>名字都是以<strong>字母</strong>打头的字母和数字序列，</p>
<p>经常使用大写字母表示，与变量相区分</p>
<h2 id="4-2、变量"><a href="#4-2、变量" class="headerlink" title="4.2、变量"></a>4.2、变量</h2><p>变量的名字是“<strong>标识（shi）符</strong>”，意思是用来识别不同数据的名字。是用来保存数据的地方。</p>
<p>由<strong>字母、数字、下划线</strong>组成，数字不能出现在第一个位置上，C语言的关键字，不能做标识符</p>
<p>变量定义的一般形式就是：**&lt;类型名称&gt;&lt;变量名称&gt;&#x3D; &lt;初始值&gt;;**</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> price = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> price = <span class="number">0</span>, amount = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//这一行，定义了一个变量。变量的名字是 price，类型是int，初始值是0.</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//读数据    </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price);</span><br><span class="line"></span><br><span class="line"><span class="comment">//要求 scanf 这个函数读入下一个整数，读到的结果赋值到变量 price</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小心 price 前面的 &amp;</span></span><br></pre></td></tr></table></figure>

<p>“&#x3D;”是赋值运算符，有运算符的式子就是 表达式。</p>
<p>一个表达式是一系列运算符和算子的组合，用来计算。</p>
<ul>
<li>price &#x3D; 0;</li>
<li>change &#x3D; 100 - price;</li>
</ul>
<h2 id="4-3、运算符"><a href="#4-3、运算符" class="headerlink" title="4.3、运算符"></a>4.3、运算符</h2><ul>
<li>运算符（operator）是指进行运算的动作，比如加法运算的“+”</li>
<li>算子（operand）是参与运算的值，这个值可能是常数，也可能是变量，还可能是一个方法的返回值</li>
</ul>
<p><img src="/2024/07/07/C++/C/image-20211230151925588.png" alt="image-20211230151925588"></p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h3 id="1、算术运算符"><a href="#1、算术运算符" class="headerlink" title="1、算术运算符"></a>1、算术运算符</h3><p>下表显示了 C 语言支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<p>结合规则：从左到右</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">把两个操作数相加</td>
<td align="left">A + B 将得到 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">从第一个操作数中减去第二个操作数</td>
<td align="left">A - B 将得到 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">把两个操作数相乘</td>
<td align="left">A * B 将得到 200</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">分子除以分母</td>
<td align="left">B &#x2F; A 将得到 2</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取模运算符，整除后的余数<br>不能应用于浮点数<br>在有负数的情况下，结果取决于机器</td>
<td align="left">B % A 将得到 0</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left">自增运算符，整数值增加 1（只能作用于变量）</td>
<td align="left">A++ 将得到 11</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">自减运算符，整数值减少 1（只能作用于变量）</td>
<td align="left">A– 将得到 9</td>
</tr>
</tbody></table>
<h3 id="2、关系运算符"><a href="#2、关系运算符" class="headerlink" title="2、关系运算符"></a>2、关系运算符</h3><p>下表显示了 C 语言支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<p>关系运算符的优先级比算数运算符低</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="left">(A &#x3D;&#x3D; B) 为假。</td>
</tr>
<tr>
<td align="left">!&#x3D;</td>
<td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td align="left">(A !&#x3D; B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &gt; B) 为假。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &lt; B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &gt;&#x3D; B) 为假。</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &lt;&#x3D; B) 为真。</td>
</tr>
</tbody></table>
<h3 id="3、逻辑运算符"><a href="#3、逻辑运算符" class="headerlink" title="3、逻辑运算符"></a>3、逻辑运算符</h3><p>按从左到右的顺序进行求值，在知道结果为真或假后立即停止计算。</p>
<p>逻辑与的优先级比逻辑或的优先级高，但比关系运算符和相等运算符（&#x3D;&#x3D;，！&#x3D;）低</p>
<p>下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td align="left">(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td align="left">(A || B) 为真。</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td align="left">!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
<h3 id="4、位运算符"><a href="#4、位运算符" class="headerlink" title="4、位运算符"></a>4、位运算符</h3><p>下表显示了 C 语言支持的位运算符。只能作用于整型操作数，即只能作用于带符号或无符号 char, short, int, long类型。</p>
<p>假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与（AND），按二进制位进行”与”运算。<br>运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td>
<td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或（OR），按二进制位进行”或”运算。<br>运算规则：&#96;0</td>
<td align="left">0&#x3D;0;    0</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或（XOR），按二进制位进行”异或”运算。<br>运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td>
<td align="left">(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">取反运算符，按二进制位进行”取反”运算。<br>运算规则：<code>~1=-2;    ~0=-1;</code></td>
<td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td>
<td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td>
<td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
<p>按位与运算符&amp;经常用于屏蔽某些二进制位，</p>
<p><img src="/2024/07/07/C++/C/image-20220502165646344.png" alt="image-20220502165646344"> </p>
<p><img src="/2024/07/07/C++/C/image-20220502165811641.png" alt="image-20220502165811641"> </p>
<h3 id="5、赋值运算符"><a href="#5、赋值运算符" class="headerlink" title="5、赋值运算符"></a>5、赋值运算符</h3><ul>
<li><p>赋值也是运算，也有结果</p>
</li>
<li><p><code>a=6</code>的结果是  a 被赋予6</p>
</li>
<li><p><code>a=b=6 -&gt; a=(b=6)</code></p>
</li>
<li><p>复合赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total += (sum+<span class="number">100</span>)/<span class="number">2</span>;</span><br><span class="line">total = total +(sum+<span class="number">100</span>)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td align="left">C &#x3D; A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td align="left">+&#x3D;</td>
<td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td align="left">C +&#x3D; A 相当于 C &#x3D; C + A</td>
</tr>
<tr>
<td align="left">-&#x3D;</td>
<td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td align="left">C -&#x3D; A 相当于 C &#x3D; C - A</td>
</tr>
<tr>
<td align="left">*&#x3D;</td>
<td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td align="left">C *&#x3D; A 相当于 C &#x3D; C * A</td>
</tr>
<tr>
<td align="left">&#x2F;&#x3D;</td>
<td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td align="left">C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td align="left">%&#x3D;</td>
<td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td align="left">C %&#x3D; A 相当于 C &#x3D; C % A</td>
</tr>
<tr>
<td align="left">&lt;&lt;&#x3D;</td>
<td align="left">左移且赋值运算符</td>
<td align="left">C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td align="left">&gt;&gt;&#x3D;</td>
<td align="left">右移且赋值运算符</td>
<td align="left">C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td align="left">&amp;&#x3D;</td>
<td align="left">按位与且赋值运算符</td>
<td align="left">C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>
</tr>
<tr>
<td align="left">^&#x3D;</td>
<td align="left">按位异或且赋值运算符</td>
<td align="left">C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>
</tr>
<tr>
<td align="left">|&#x3D;</td>
<td align="left">按位或且赋值运算符</td>
<td align="left">C |&#x3D; 2 等同于 C &#x3D; C | 2</td>
</tr>
</tbody></table>
<h3 id="6、杂项运算符↦-sizeof-三元"><a href="#6、杂项运算符↦-sizeof-三元" class="headerlink" title="6、杂项运算符↦ sizeof &amp; 三元"></a>6、杂项运算符↦ sizeof &amp; 三元</h3><p>下表列出了 C 语言支持的其他一些重要的运算符，包括 <strong>sizeof</strong> 和 **? :**。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sizeof()</td>
<td align="left">返回某个类型或变量在内存中所占据的字节数</td>
<td align="left">sizeof(a) 将返回 4，其中 a 是整数。<br>sizeof(int)返回int的字节数</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">返回变量的地址。</td>
<td align="left">&a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">指向一个变量。</td>
<td align="left">*a; 将指向一个变量。</td>
</tr>
<tr>
<td align="left">Exp1 ? X : Y;</td>
<td align="left">条件表达式(三元运算符)</td>
<td align="left">如果条件为真 ? 则值为 X : 否则值为 Y</td>
</tr>
</tbody></table>
<h4 id="①、sizeof"><a href="#①、sizeof" class="headerlink" title="①、sizeof"></a>①、sizeof</h4><ul>
<li>静态运算符，它的结果在编译时刻就决定了</li>
<li>不要在sizeof的括号里面做运算，这些运算是不会做的</li>
</ul>
<p>表达式*sizeof(type)*得到对象或类型的存储字节大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;int 存储大小 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 存储大小 : <span class="number">4</span> </span><br></pre></td></tr></table></figure>

<p><strong>%lu</strong> 为 32 位无符号整数</p>
<h3 id="7、运算符优先级"><a href="#7、运算符优先级" class="headerlink" title="7、运算符优先级"></a>7、运算符优先级</h3><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">()  []  -&gt;  .</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘除</td>
<td align="left">* &#x2F; %</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">加减</td>
<td align="left">+ -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&lt;&lt; &gt;&gt;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位与 AND</td>
<td align="left">&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位异或 XOR</td>
<td align="left">^</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位或 OR</td>
<td align="left">|</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑与 AND</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑或 OR</td>
<td align="left">||</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">?:</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">,</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<p>逗号用来连接两个表达式，并以右边的表达式的值作为它的结果。逗号的优先级在所有运算符中是最低的，所以它两边的运算符会先计算；逗号的组合关系是自左向右，所以左边的表达式会先计算，右边的表达式也会计算，但没有输入给任何值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>+<span class="number">4</span>, <span class="number">5</span>+<span class="number">6</span>;</span><br><span class="line"><span class="comment">//i的结果是7</span></span><br><span class="line"><span class="comment">//一个用处</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ,j++) </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-4、类型转换"><a href="#4-4、类型转换" class="headerlink" title="4.4、类型转换"></a>4.4、类型转换</h2><h3 id="1、自动类型转换"><a href="#1、自动类型转换" class="headerlink" title="1、自动类型转换"></a>1、自动类型转换</h3><ul>
<li>当运算符两边出现不一样的类型时，会自动转换为较大的类型</li>
<li>大的意思是表达的数的范围更大</li>
<li>char -&gt; short -&gt; int -&gt; long -&gt; long long</li>
<li>int -&gt; float -&gt;double</li>
<li>对于printf，任何小于int的类型会被转换成int；float会被转换成double</li>
<li>但是scanf不会，要输入 short，需要%hd</li>
</ul>
<h3 id="2、强制类型转换"><a href="#2、强制类型转换" class="headerlink" title="2、强制类型转换"></a>2、强制类型转换</h3><p>（类型名） 表达式</p>
<p>表达式首先被赋值给类型名指定的类型的某个变量，然后再用该变量替换上述整条语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>((<span class="type">double</span>) n)</span><br><span class="line"><span class="comment">//强制类型转换只是生成一个指定类型的n的值，n本身的值并没有改变</span></span><br></pre></td></tr></table></figure>

<p>在通常情况下，参数是通过函数原型声明的。这样，当函数被调用时，声明将对参数进行自动类型转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span>)</span>;</span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line">root2 = <span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//不使用强制类型转换符就可以自动将整数2转换为 double 类型的 2.0</span></span><br></pre></td></tr></table></figure>

<p>标准库包含一个可移植的实现伪随机数发生器的函数 rand 以及一个初始化种子数的函数 srand。前一个函数 rand 使用了强制类型转换。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rand: return pseudo-random integer on 0..32767 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* srand: set seed for rand() */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span><br><span class="line">&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、语句"><a href="#五、语句" class="headerlink" title="五、语句"></a>五、语句</h1><p>程序语言中的控制流语句用于控制各计算操作执行的次序。</p>
<h2 id="5-1、语句和程序块"><a href="#5-1、语句和程序块" class="headerlink" title="5.1、语句和程序块"></a>5.1、语句和程序块</h2><p>在表达式后面加上一个分号，就变成了一个语句。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(...);</span><br></pre></td></tr></table></figure>

<p>用一对花括号“{”与“}”把一组声明和语句括在一起就构成了一个复合语句（也叫做程序块），复合语句在语法上等价于单条语句。右花括号用于结束程序块，其后不需要分号。</p>
<h2 id="5-2、if-else语句"><a href="#5-2、if-else语句" class="headerlink" title="5.2、if-else语句"></a>5.2、if-else语句</h2><p>if-else用于条件判定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)&#123;</span><br><span class="line">	语句<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 条件成立，执行语句1；不成立，执行语句2 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 if 或 else 后总是用 {}</li>
<li>else 部分是可选的</li>
</ul>
<p><strong>常见错误</strong></p>
<ul>
<li>忘了大括号<ul>
<li>永远在if和else后面加上大括号，即使只有一条语句</li>
</ul>
</li>
<li>if 后面的分号<ul>
<li>if后面的判断语句后 不用加分号</li>
</ul>
</li>
<li>错误使用 &#x3D;&#x3D;和&#x3D;</li>
<li>使人困惑的else</li>
</ul>
<p>代码风格</p>
<ul>
<li>在if和else之后必须加上大括号形成语句块</li>
<li>大括号内的语句缩进一个tab的位置</li>
</ul>
<h2 id="5-3、else-if-语句"><a href="#5-3、else-if-语句" class="headerlink" title="5.3、else-if 语句"></a>5.3、else-if 语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式)</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (表达式)</span><br><span class="line">	语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (表达式)</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (表达式)</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>



<h2 id="5-4、多路分支（switch-case"><a href="#5-4、多路分支（switch-case" class="headerlink" title="5.4、多路分支（switch-case)"></a>5.4、多路分支（switch-case)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(控制表达式)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span> 常量：</span><br><span class="line">            语句</span><br><span class="line">            ···</span><br><span class="line">        <span class="keyword">case</span> 常量：</span><br><span class="line">        	语句</span><br><span class="line">            ···</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    		语句</span><br><span class="line">            ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;早上好&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;晚上好&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;再见&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;啊，什么啊？&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制表达式只能是<strong>整数型</strong>的结果</p>
<p>常量可以是常数，也可以是常数计算的表达式</p>
<p>根据表达式的结果，寻找匹配的case，并执行case后面的语句，一直到break为止</p>
<p>如果所有的case都不匹配，那么就执行default后面的语句；如果没有default，那么就什么都不做</p>
<p>break语句可以看作是一种基于计算的跳转，计算控制表达式的值后，程序会跳转到相匹配的case（分支标号）处。分支标号只是说明switch内部位置的路标，在执行玩分支中的最后一条语句后，如果后面没有break，就会顺序执行到下面的case里去，直到遇到一个break,或者switch结束为止</p>
<h2 id="5-5、while循环"><a href="#5-5、while循环" class="headerlink" title="5.5、while循环"></a>5.5、while循环</h2><p><img src="/2024/07/07/C++/C/image-20220428151351597.png" alt="image-20220428151351597"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">    语句</span><br><span class="line"><span class="comment">//首先求表达式的值。如果其值非0，则执行语句，并再次求表达式的值。</span></span><br><span class="line"><span class="comment">//循环下去，一直到表达式的值为0为止，随后执行语句后面的部分。</span></span><br></pre></td></tr></table></figure>



<p>如果我们把while翻译作“当”，那么⼀个while循环的意思就是：当条件满⾜时，不断地重复循环体内的语句。<br>• 循环执⾏之前判断是否继续循环，所以有可能循环⼀次也没有被执⾏；<br>• 条件成⽴是循环继续的条件。</p>
<h2 id="5-6、do-while循环"><a href="#5-6、do-while循环" class="headerlink" title="5.6、do-while循环"></a>5.6、do-while循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">while</span> (表达式);</span><br><span class="line"><span class="comment">//在循环体结束后测试终止条件</span></span><br><span class="line"><span class="comment">//先执行循环体中的语句部分，然后再求表达式的值。</span></span><br><span class="line"><span class="comment">//如果表达式的值为真，则再执行语句，以此类推；</span></span><br><span class="line"><span class="comment">//当表达式的值变为假，则循环终止</span></span><br></pre></td></tr></table></figure>

<h2 id="5-7、for-循环"><a href="#5-7、for-循环" class="headerlink" title="5.7、for 循环"></a>5.7、for 循环</h2><p>for循环像⼀个计数循环：设定⼀个计数器，初始化它，然后在计数器到达某值之前，重复执⾏循环体，⽽每执⾏⼀轮循环，计数器值以⼀定步进进⾏调整，⽐如加1或者减1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//做求和程序时，记录结果的变量应该初始化为0</span></span><br><span class="line"><span class="comment">//做求积程序时，记录结果的变量应该初始化为1</span></span><br><span class="line"><span class="comment">//可以省略表达式1和表达式3，但分号必须保留</span></span><br></pre></td></tr></table></figure>



<p><strong>tips:</strong></p>
<ul>
<li>如果有固定次数，用for</li>
<li>如果必须执行一次，用 do-while</li>
<li>其他情况用while</li>
</ul>
<h2 id="5-8、break语句和continue语句"><a href="#5-8、break语句和continue语句" class="headerlink" title="5.8、break语句和continue语句"></a>5.8、break语句和continue语句</h2><p><strong>1、break语句</strong></p>
<p>跳出循环</p>
<p>只能跳出最近的一层循环</p>
<p><strong>2、continue语句</strong></p>
<p>跳过循环这一轮剩下的语句，进入下一轮</p>
<p>只能跳出最近的一层循环</p>
<h2 id="5-9、goto语句"><a href="#5-9、goto语句" class="headerlink" title="5.9、goto语句"></a>5.9、goto语句</h2><p>标号的命名同变量名的形式相同，标号的后面要紧跟一个冒号。</p>
<p>标号可以位于对应的goto语句所在函数的任何语句的前面。标号的作用域是整个函数。</p>
<p>可以调到goto所定义的地方，跳出多层循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> one, two, five;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">for</span>( one = <span class="number">1</span>; one &lt; x*<span class="number">10</span>; one++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>( two = <span class="number">1</span>; two &lt; x*<span class="number">10</span>/<span class="number">2</span>; two++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span>( five = <span class="number">1</span>; five &lt; x*<span class="number">10</span>/<span class="number">5</span>; five++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span>( one + two*<span class="number">2</span> + five*<span class="number">5</span> == x*<span class="number">10</span> ) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out;	<span class="comment">//执行这一语句后，可以直接调到19行的out</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><p>函数是一组一起执行一个任务的语句。每个C程序都至少有一个函数，即主函数**main()**，所有简单的程序都可怀疑定义其他额外的函数。</p>
<p>你可以把代码划分到不同的函数中。如何划分到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。</p>
<p>C标准库提供了大量的程序可以调用的内置函数。</p>
<h2 id="6-1、定义函数"><a href="#6-1、定义函数" class="headerlink" title="6.1、定义函数"></a>6.1、定义函数</h2><p>函数定义的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name( parameter list)</span><br><span class="line">&#123;</span><br><span class="line">	body of the function</span><br><span class="line">&#125;</span><br><span class="line">返回值类型 函数名（参数声明表）</span><br><span class="line">&#123;</span><br><span class="line">	声明和语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。如果省略，默认为int。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
<li>调用函数可以省略返回值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数返回两个数中较大的那个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2、返回非整型值的函数"><a href="#6-2、返回非整型值的函数" class="headerlink" title="6.2、返回非整型值的函数"></a>6.2、返回非整型值的函数</h2><p>头文件&lt;stdlib.h&gt;中声明了函数返回非整型值的方法atof(s),该函数将字符串s转换为相应的双精度浮点数。</p>
<h2 id="6-4、调用函数"><a href="#6-4、调用函数" class="headerlink" title="6.4、调用函数"></a>6.4、调用函数</h2><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>
<p>调用函数时，永远只能传值给函数</p>
<p>每个函数都有自己的变量空间，参数也独立于这个空间，和其他函数没有关系</p>
<ul>
<li>函数名（参数值）</li>
<li>()起到了表示函数调用的重要作用<ul>
<li>即使没有参数，也需要写括号</li>
<li>如果有参数，需要给出正确的数量和顺序</li>
<li>这些参数会按照顺序依次用来初始化函数中的参数</li>
</ul>
</li>
<li>return可以停止函数的执行，并返回一个值<ul>
<li>return;</li>
<li>return 表达式;</li>
</ul>
</li>
<li>一个函数中可以出现多个return</li>
</ul>
<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>
<p>函数中的返回值</p>
<ul>
<li>可以赋值给变量</li>
<li>可以再传递给函数</li>
<li>可以丢弃，也就是不使用，但有时候可能有副作用</li>
<li>void类型的函数，不可以使用return</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 调用函数来获取最大值 */</span></span><br><span class="line">   ret = max(a, b);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Max value is : %d\n&quot;</span>, ret );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数返回两个数中较大的那个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5、本地变量（局部变量）"><a href="#6-5、本地变量（局部变量）" class="headerlink" title="6.5、本地变量（局部变量）"></a>6.5、本地变量（局部变量）</h2><p>函数的每次运行，就产生了一个独立的变量空间，在这个空间里的变量，是函数的这次运行所独有的，称作本地变量。</p>
<p>定义在函数内部的变量就是本地变量。</p>
<p>参数也是本地变量</p>
<p><strong>变量的生存期和作用域</strong></p>
<ul>
<li>生存期：什么时候这个变量开始出现了，到什么时候消亡了</li>
<li>作用域：在（代码的）什么范围内可以访问到这个变量（这个变量可以起作用）</li>
<li>在大括号内——块起作用</li>
</ul>
<p><strong>本地变量的规则：</strong></p>
<ul>
<li>本地变量是定义在块内的	<ul>
<li>可以在函数的块内</li>
<li>可以在语句的块内</li>
<li>也可以随便拉一对大括号定义</li>
</ul>
</li>
<li>程序进入这个块之前，其中的变量不存在；离开这个块，其中的变量就消失了</li>
<li>块外边定义的变量在里面同样生效</li>
<li>块里面定义了外面的同名变量，就掩盖了外边的变量</li>
<li>不能在一个块内定义同名变量</li>
<li>本地变量不会被默认初始化</li>
<li>参数在进入这个函数时，已经初始化了</li>
</ul>
<h2 id="6-6、函数参数"><a href="#6-6、函数参数" class="headerlink" title="6.6、函数参数"></a>6.6、函数参数</h2><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">传值调用</td>
<td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>
</tr>
<tr>
<td align="left">引用调用</td>
<td align="left">通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>
</tr>
</tbody></table>
<p>默认情况下，C 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p>
<p>函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。</p>
<p><strong>全局变量与局部变量在内存中的区别</strong>：</p>
<ul>
<li>全局变量保存在内存的全局存储区中，占用静态的存储单元；</li>
<li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</li>
</ul>
<h1 id="七、指针"><a href="#七、指针" class="headerlink" title="七、指针"></a>七、指针</h1><p>指针是一种保存变量地址的变量</p>
<p><strong>变量不一定按照声明的顺序保存在内存中</strong></p>
<p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用 <strong>&amp;</strong> 运算符访问的地址，它表示了在内存中的一个地址。</p>
<h2 id="7-1、定义"><a href="#7-1、定义" class="headerlink" title="7.1、定义"></a>7.1、定义</h2><p>指针也就是内存地址，指针变量是用来存放内存地址的变量。</p>
<p>指针变量声明的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type *var-name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 ***** 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。</p>
<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。</p>
<p>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<p>分布空间的意思是给予内存空间的使用权限，</p>
<p>地址：</p>
<ol>
<li>内存单元的编号</li>
<li>从0开始的非负整数</li>
<li>范围：0——（16G-1）</li>
</ol>
<p>指针：指针就是地址，地址就是指针</p>
<p>​			指针变量是存放内存单元地址的变量</p>
<p>​			指针的本质是一个操作受限的非负整数</p>
<h2 id="7-2、-NULL-指针"><a href="#7-2、-NULL-指针" class="headerlink" title="7.2、 NULL 指针"></a>7.2、 NULL 指针</h2><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。符号常量NULL定义在标准头文件&lt;stddef.h&gt;中</p>
<p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ptr 的地址是 %p\n&quot;</span>, ptr  );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr 的地址是 <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p>
<p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr)     <span class="comment">/* 如果 p 非空，则完成 */</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)    <span class="comment">/* 如果 p 为空，则完成 */</span></span><br></pre></td></tr></table></figure>

<h2 id="7-3、数组"><a href="#7-3、数组" class="headerlink" title="7.3、数组"></a>7.3、数组</h2><p>数组变量的特殊的指针</p>
<ul>
<li><p>数组变量本身表示地址，所以</p>
<ul>
<li><pre><code class="c">int a[10]; int *p = a;	//无需用&amp;取地址符号
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 但是数组单元表示的变量，需要用&amp;取地址符号</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  a == &amp;a[0]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>数组变量是const的指针，所以不能被赋值</p>
<ul>
<li><pre><code class="c">int a[] &lt;==&gt; int * const a = ...
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 7.4、const</span><br><span class="line"></span><br><span class="line">### 1、指针常量</span><br><span class="line"></span><br><span class="line">- 表示一旦得到某个变量的地址，不能再指向其他变量</span><br><span class="line">  - `int * const q = &amp;i;	//q是const`</span><br><span class="line">  - `*q = 26;   //OK`</span><br><span class="line">  - `q++;  //ERROR`</span><br><span class="line"></span><br><span class="line">### 2、常量指针</span><br><span class="line"></span><br><span class="line">- 表示不能通过这个指针去修改那个变量（并不能使那个变量成为const）</span><br><span class="line">  - `const int *p = &amp;i;`</span><br><span class="line">  - `*q = 26;   //ERROR (*p)是const`</span><br><span class="line">  - `i = 26;  //OK`</span><br><span class="line">  - `p = &amp;j; //OK`</span><br><span class="line"></span><br><span class="line"> ## 7.5、指针运算</span><br><span class="line"></span><br><span class="line">如果指针不是指向一片连续分配的空间，如数组，这些运算没有意义。</span><br><span class="line"></span><br><span class="line">- 可以对指针进行算术运算</span><br><span class="line"></span><br><span class="line">  - 加减一个整数</span><br><span class="line"></span><br><span class="line">  - 递增递减</span><br><span class="line"></span><br><span class="line">  - 两个指针相减</span><br><span class="line"></span><br><span class="line">  - 这些运算是对变量进行计算，而不是存储单元</span><br><span class="line"></span><br><span class="line">    - ```c</span><br><span class="line">      int a[10];</span><br><span class="line">      int *p = a;</span><br><span class="line">      *(p+1)--&gt;a[1];</span><br><span class="line">      //int是四个字节，指针加1就是到下一个变量，而不是下一个存储单元，他们中间差4个存储单元</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>*p++</p>
<ul>
<li>取出p所指的那个数据来，完事之后顺便把p移到下一个位置去</li>
<li>++的优先级比*高</li>
<li>常用于数组类的连续空间操作</li>
<li>在某些CPU中，这可以直接翻译成一条汇编指令</li>
</ul>
</li>
<li><p>0地址</p>
<ul>
<li>0地址通常不可以碰</li>
<li>指针不应该具有0值</li>
<li>因此可以用0地址表示特殊的事情：<ul>
<li>返回的地址无效</li>
<li>指针没有被真正初始化（先初始化为0）</li>
</ul>
</li>
<li>NULL是一个预定定义的地址，表示0地址</li>
</ul>
</li>
</ul>
<h2 id="7-6、指针的类型"><a href="#7-6、指针的类型" class="headerlink" title="7.6、指针的类型"></a>7.6、指针的类型</h2><p>无论指向什么类型，所有的指针的大小是一样的，但是指向不同类型的指针是不能互相赋值的，这是为了避免用错指针。比如，int类型的地址指向Int，有4个字节；而char类型的指针指向的char数据，只有一个字节，不能互用。</p>
<ul>
<li><p>指针的类型转换</p>
<ul>
<li><p>void*表示不知道指向什么东西的指针</p>
</li>
<li><pre><code class="c">int *p = &amp;i;
void *q = (void*)p;
//这样并没有改变p所指变量的类型
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 7.7、malloc</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void* malloc(size_t size);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>向malloc申请的空间的大小是以字节为单位的</p>
</li>
<li><p>返回的结果是void*，需要类型转换为自己需要的类型</p>
<ul>
<li><code>(int*)malloc(n*sizeof(int))</code></li>
</ul>
</li>
<li><p>空间申请失败则返回0，或者NULL</p>
</li>
<li><p>free()</p>
<ul>
<li>申请的空间需要还给系统</li>
<li>只能归还申请来的空间首地址</li>
</ul>
</li>
</ul>
<h2 id="7-8、字符串操作"><a href="#7-8、字符串操作" class="headerlink" title="7.8、字符串操作"></a>7.8、字符串操作</h2><h3 id="1、单字符输入输出"><a href="#1、单字符输入输出" class="headerlink" title="1、单字符输入输出"></a>1、单字符输入输出</h3><p>putchar</p>
<ul>
<li>int putchar(int c)</li>
<li>向标准输出（程序结果那个黑色的页面）写一个字符</li>
<li>返回写了几个字符，EOF(-1)表示写失败</li>
</ul>
<p>getchar</p>
<ul>
<li>int getchar(void)</li>
<li>从标准输入读一个字符</li>
<li>返回类型是int，是为了返回EOF(-1)<ul>
<li>Windows –&gt; Ctrl-Z：退出</li>
</ul>
</li>
</ul>
<h3 id="2、字符串数组"><a href="#2、字符串数组" class="headerlink" title="2、字符串数组"></a>2、字符串数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *a[];</span><br><span class="line"><span class="comment">//表示a[]是一个一维数组，每个数组指向一个地址，那个地址存放响应的字符串，不用担心字符串太长</span></span><br></pre></td></tr></table></figure>

<h2 id="7-9、字符串函数"><a href="#7-9、字符串函数" class="headerlink" title="7.9、字符串函数"></a>7.9、字符串函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">strlen</span>		<span class="comment">//求长度</span></span><br><span class="line"><span class="built_in">strcmp</span>		<span class="comment">//比较字符串</span></span><br><span class="line"><span class="built_in">strcpy</span>		<span class="comment">//复制字符串</span></span><br><span class="line"><span class="built_in">strcat</span></span><br><span class="line"><span class="built_in">strchr</span></span><br><span class="line"><span class="built_in">strstr</span></span><br></pre></td></tr></table></figure>

<h3 id="1、strlen"><a href="#1、strlen" class="headerlink" title="1、strlen"></a>1、strlen</h3><ul>
<li>size_t strlen(const char *s)</li>
<li>后面这个const表示通过这个指针不会修改数组</li>
<li>返回字符串s的长度（不包含结尾的’\0’）</li>
</ul>
<h3 id="2、strcmp"><a href="#2、strcmp" class="headerlink" title="2、strcmp"></a>2、strcmp</h3><ul>
<li>int strcmp(const char *s1, const char *s2)</li>
<li>比较两个字符串，返回<ul>
<li>0：s1 &#x3D;&#x3D; s2</li>
<li>1：s1 &gt;    s2</li>
<li>-1：s1 &lt;  s2</li>
</ul>
</li>
</ul>
<h3 id="3、strcpy"><a href="#3、strcpy" class="headerlink" title="3、strcpy"></a>3、strcpy</h3><ul>
<li><p>char *strcpy(char *restrict dst, const char *restrict src)</p>
</li>
<li><p>把src的字符串拷贝到dst</p>
<ul>
<li>restrict表明src和dst不重叠</li>
</ul>
</li>
<li><p>返回dst</p>
</li>
<li><p>复制一个字符串</p>
<ul>
<li><pre><code class="c">char *dst = (char*)malloc(strlen(src)+1);
strcpy(dst, src);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">### 4、strchr</span><br><span class="line"></span><br><span class="line">- 字符串中找字符 </span><br><span class="line">- char * strchr(const char *s, int c)</span><br><span class="line">  - 从左边开始找和右边的字符一样的指针</span><br><span class="line">- char * strrchr(const char *s, int c)</span><br><span class="line">- 返回NULL表示没有找到 </span><br><span class="line">- 字符串中找字符串</span><br><span class="line">  - char * strstr(const char *s1, const char *s2);</span><br><span class="line">  - char * strcasestr(const char *s1,const char *s2);</span><br><span class="line"></span><br><span class="line"># 八、数组</span><br><span class="line"></span><br><span class="line">数组可以存储一个固定大小的相同类型元素的顺序集合。</span><br><span class="line"></span><br><span class="line">## 8.1、定义</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">type arrayName [ arraySize ];</span><br><span class="line">int grades[10];</span><br><span class="line">double balance[10];</span><br><span class="line"></span><br><span class="line">//type数据类型</span><br><span class="line">//arrayName数组名字</span><br><span class="line">//arraySize数组大小，需要大于0,必须是整数</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>数组的声明是声明一个数组变量，比如 runoob[100]，然后使用 runoob[0]、runoob[1]、…、runoob[99] 来代表一个个单独的变量。</p>
<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<p><img src="/2024/07/07/C++/C/image-20220105153436668.png" alt="image-20220105153436668"></p>
<p>数组中的特定元素可以通过索引访问，第一个索引值为 0。</p>
<p><img src="/2024/07/07/C++/C/image-20220105153458339.png" alt="image-20220105153458339"></p>
<h2 id="8-2、初始化数组"><a href="#8-2、初始化数组" class="headerlink" title="8.2、初始化数组"></a>8.2、初始化数组</h2><ul>
<li>直接用大括号给出所有元素的初始值，</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> balance[] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化数量小于数组的大小，其后的元素自动赋值为0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">20</span>] = &#123;<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>



<p>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</p>
<p><img src="/2024/07/07/C++/C/c-arrays-2021-1-18-4.png" alt="数组表示"></p>
<p>下图是一个长度为 <strong>10</strong> 的数组，第一个元素的索引值为 <strong>0</strong>，第九个元素 <strong>runoob</strong> 的索引值为 <strong>8</strong>:</p>
<p><img src="/2024/07/07/C++/C/c-array-2021-01-18-2.png" alt="img"></p>
<h2 id="8-3、访问数组元素"><a href="#8-3、访问数组元素" class="headerlink" title="8.3、访问数组元素"></a>8.3、访问数组元素</h2><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> salary = balance[<span class="number">9</span>];</span><br></pre></td></tr></table></figure>

<p>上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> n[ <span class="number">10</span> ]; <span class="comment">/* n 是一个包含 10 个整数的数组 */</span></span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 初始化数组元素 */</span>         </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      n[ i ] = i + <span class="number">100</span>; <span class="comment">/* 设置元素 i 为 i + 100 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Element[%d] = %d\n&quot;</span>, j, n[j] );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Element[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">Element[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">Element[<span class="number">2</span>] = <span class="number">102</span></span><br><span class="line">Element[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">Element[<span class="number">4</span>] = <span class="number">104</span></span><br><span class="line">Element[<span class="number">5</span>] = <span class="number">105</span></span><br><span class="line">Element[<span class="number">6</span>] = <span class="number">106</span></span><br><span class="line">Element[<span class="number">7</span>] = <span class="number">107</span></span><br><span class="line">Element[<span class="number">8</span>] = <span class="number">108</span></span><br><span class="line">Element[<span class="number">9</span>] = <span class="number">109</span></span><br></pre></td></tr></table></figure>

<h2 id="8-4、特点"><a href="#8-4、特点" class="headerlink" title="8.4、特点"></a>8.4、特点</h2><p>数组是一种容器（放东西的东西），特点是</p>
<ul>
<li>所有元素具有相同的数据类型</li>
<li>一旦创建，不能改变大小</li>
<li>数组中的元素在内存中是联系排列的</li>
</ul>
<h2 id="8-5、报错"><a href="#8-5、报错" class="headerlink" title="8.5、报错"></a>8.5、报错</h2><p>有效的下标范围</p>
<p>编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写</p>
<p>一旦程序运行，数组的越界访问可能造成问题，导致程序崩溃</p>
<ul>
<li>segmentation fault</li>
<li>但也可能运气好，可以正常运行</li>
</ul>
<h2 id="8-6、二维数组"><a href="#8-6、二维数组" class="headerlink" title="8.6、二维数组"></a>8.6、二维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[i][j];</span><br></pre></td></tr></table></figure>

<h3 id="1、二维数组的初始化"><a href="#1、二维数组的初始化" class="headerlink" title="1、二维数组的初始化"></a>1、二维数组的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>列数是必须给出的，行数可以由编译器来数</p>
<p>每行一个{}，逗号 分割</p>
<p>最后一个逗号可以存在，有古老的传统</p>
<p>如果省略，表示补零</p>
<h1 id="九、结构类型"><a href="#九、结构类型" class="headerlink" title="九、结构类型"></a>九、结构类型</h1><h2 id="9-1、枚举"><a href="#9-1、枚举" class="headerlink" title="9.1、枚举"></a>9.1、枚举</h2><p>枚举是一种用户定义的数据类型</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名 &#123;</span>枚举元素<span class="number">1</span>，枚举元素<span class="number">2</span>，......&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br></pre></td></tr></table></figure>

<p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<blockquote>
<p>可以在定义枚举类型时改变枚举元素的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span>spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure>

<p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p>
</blockquote>
<h3 id="1、枚举变量的定义"><a href="#1、枚举变量的定义" class="headerlink" title="1、枚举变量的定义"></a>1、枚举变量的定义</h3><p>我们可以通过以下三种方式来定义枚举变量</p>
<p><strong>1.先定义枚举类型，再定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、定义枚举类型的同时定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<p><strong>3、省略枚举名称，直接定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br><span class="line">    day = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p>
<p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p>
<p>以下实例使用 for 来遍历枚举的元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">枚举元素：<span class="number">1</span> </span><br><span class="line">枚举元素：<span class="number">2</span> </span><br><span class="line">枚举元素：<span class="number">3</span> </span><br><span class="line">枚举元素：<span class="number">4</span> </span><br><span class="line">枚举元素：<span class="number">5</span> </span><br><span class="line">枚举元素：<span class="number">6</span> </span><br><span class="line">枚举元素：<span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="2、将整数转换为枚举"><a href="#2、将整数转换为枚举" class="headerlink" title="2、将整数转换为枚举"></a>2、将整数转换为枚举</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">day</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        saturday,</span><br><span class="line">        sunday,</span><br><span class="line">        monday,</span><br><span class="line">        tuesday,</span><br><span class="line">        wednesday,</span><br><span class="line">        thursday,</span><br><span class="line">        friday</span><br><span class="line">    &#125; workday;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">weekend</span>;</span></span><br><span class="line">    weekend = ( <span class="keyword">enum</span> day ) a;  <span class="comment">//类型转换</span></span><br><span class="line">    <span class="comment">//weekend = a; //错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;weekend:%d&quot;</span>,weekend);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weekend:<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="9-2、结构"><a href="#9-2、结构" class="headerlink" title="9.2、结构"></a>9.2、结构</h2><p><strong>结构</strong>是 C 编程中用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span> </span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span> </span><br><span class="line">    member-<span class="built_in">list</span>  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br></pre></td></tr></table></figure>

<p><strong>tag</strong> 是结构体标签。是结构</p>
<p><strong>member-list</strong> 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</p>
<p><strong>variable-list</strong> 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。</p>
<h3 id="2、表示方法"><a href="#2、表示方法" class="headerlink" title="2、表示方法"></a>2、表示方法</h3><p>方法一：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p1</span>,<span class="title">p2</span>;</span></span><br><span class="line"><span class="comment">//p1,p2都是结构类point里面的变量名字</span></span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"><span class="comment">//p1,p2都是一种无名结构，里面有x,y</span></span><br></pre></td></tr></table></figure>

<p>方法三：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"><span class="comment">//p1,p2都是结构类point里面的变量</span></span><br></pre></td></tr></table></figure>

<h3 id="3、结构的初始化"><a href="#3、结构的初始化" class="headerlink" title="3、结构的初始化"></a>3、结构的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">today</span> =</span> &#123;<span class="number">04</span>,<span class="number">02</span>,<span class="number">2022</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">thismonth</span> =</span> &#123;.month = <span class="number">2</span>, .year = <span class="number">2022</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Today&#x27;s data is %i-%i-%i.\n&quot;</span>,today.year,today.month,today.day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This month is %i-%i-%i.\n&quot;</span>,thismonth.year,thismonth.month,thismonth.day);</span><br><span class="line">    <span class="comment">//结构体的赋值和数组类似，赋值的填进去，没赋值的自动为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体成员变量可以直接将结构变量内的所有变量赋值</span></span><br><span class="line"><span class="comment">//thismonth = today</span></span><br><span class="line"><span class="comment">//等效为</span></span><br><span class="line"><span class="comment">//thismonth.day = today.day</span></span><br><span class="line"><span class="comment">//thismonth.month = today.month</span></span><br><span class="line"><span class="comment">//thismonth.year = today.year</span></span><br></pre></td></tr></table></figure>



<h3 id="4、结构体指针"><a href="#4、结构体指针" class="headerlink" title="4、结构体指针"></a>4、结构体指针</h3><p>当一个指针用来指向一个结构体变量时，称之为结构体指针变量。</p>
<p>结构体指针变量中的值是所指向的结构变量的首地址，通过结构指针即可访问该结构变量。</p>
<p><strong>一般形式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类姓名 *结构指针变量名;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pDate</span> =</span> &amp;today;</span><br></pre></td></tr></table></figure>

<p>结构体指针是通过箭头（-&gt;)来访问成员的。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">        <span class="comment">/*姓名,字符数组作为结构体中的成员 */</span></span><br><span class="line">        <span class="type">char</span> street[<span class="number">40</span>]; <span class="comment">/*街道*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tel; <span class="comment">/*电话,无符号长整型作为结构体中的成员 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> zip; <span class="comment">/*邮政编码*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address</span> <span class="title">A</span>[3]=</span>&#123;</span><br><span class="line">     &#123;<span class="string">&quot;Zhang&quot;</span>,<span class="string">&quot;Road NO.1&quot;</span>,<span class="number">111111</span>,<span class="number">4444</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot; Road NO.2&quot;</span>,<span class="number">222222</span>,<span class="number">5555</span>&#125;,</span><br><span class="line">	 &#123;<span class="string">&quot;Li&quot;</span>,<span class="string">&quot; Road NO.3&quot;</span>,<span class="number">333333</span>,<span class="number">6666</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address</span> *<span class="title">p</span>;</span></span><br><span class="line">    p=&amp;A[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s %u %u\n&quot;</span>,p-&gt;name,p-&gt;street,p-&gt;tel,p-&gt;zip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、结构作为函数参数"><a href="#5、结构作为函数参数" class="headerlink" title="5、结构作为函数参数"></a>5、结构作为函数参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">number0fDays</span><span class="params">(<span class="keyword">struct</span> date d)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	整个结构可以作为参数的值传入函数</span></span><br><span class="line"><span class="comment">	这时候是在函数内新建一个结构变量，并复制调用者的结构的值</span></span><br><span class="line"><span class="comment">	也可以返回一个结构</span></span><br><span class="line"><span class="comment">	这与数组完全不同</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="6、结构数组"><a href="#6、结构数组" class="headerlink" title="6、结构数组"></a>6、结构数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2005</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="7、结构中的结构"><a href="#7、结构中的结构" class="headerlink" title="7、结构中的结构"></a>7、结构中的结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dateAndTime</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">sdate</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">time</span> <span class="title">stime</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pr2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">r</span>;</span></span><br><span class="line"><span class="comment">//有下面这些</span></span><br><span class="line">r.pt1.x</span><br><span class="line">r.pt1.y</span><br><span class="line">r.pt2.x</span><br><span class="line">r.put2.y</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果有变量定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">r</span>, *<span class="title">rp</span>;</span></span><br><span class="line">rp = &amp;r;</span><br><span class="line"><span class="comment">//下面四种形式的等价的</span></span><br><span class="line">r.pt1.x</span><br><span class="line">rp-&gt;pt1.x</span><br><span class="line">(r.pt1).x</span><br><span class="line">(rp-&gt;pt1).x</span><br><span class="line"><span class="comment">//注意没有rp-&gt;pt1-&gt;x(因为pt1不是指针)</span></span><br></pre></td></tr></table></figure>

<h2 id="9-3、联合"><a href="#9-3、联合" class="headerlink" title="9.3、联合"></a>9.3、联合</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">AnElt</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; elt1, elt2;</span><br><span class="line"></span><br><span class="line">elt1.i = <span class="number">4</span>;</span><br><span class="line">elt2.c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">elt2.i = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">union</span>...) = <span class="keyword">sizeof</span>(每个成员)的最大值</span><br></pre></td></tr></table></figure>

<ul>
<li>存储<ul>
<li>所有的成员共享一个空间</li>
<li>空间大小按照存储大小最大的数据算，并且需要是每个数据类型的整数倍</li>
<li>同一时间只有一个成员是有效的</li>
<li>union的大小是其最大的成员</li>
</ul>
</li>
<li>初始化<ul>
<li>对第一个成员做初始化</li>
</ul>
</li>
</ul>
<p>我们的x86电脑的CPU是小端的，小的先放进去</p>
<p><img src="/2024/07/07/C++/C/image-20220630165042849.png" alt="image-20220630165042849"></p>
<p><img src="/2024/07/07/C++/C/image-20220630164400362.png" alt="image-20220630164400362"></p>
<h1 id="十、链表"><a href="#十、链表" class="headerlink" title="十、链表"></a>十、链表</h1><h2 id="10-1、可变数组"><a href="#10-1、可变数组" class="headerlink" title="10.1、可变数组"></a>10.1、可变数组</h2><p>一个可变包括数组的创建，内存的释放，数组大小，访问并修改数组中的某个元素，加上可变数组的生长。</p>
<p>首先定义一个结构体，其中包含数组和大小。</p>
<p>array.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ARRAY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ARRAY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; Array;	<span class="comment">//为什么不用指针</span></span><br><span class="line">			<span class="comment">//如果使用指针的话，后面定义的时候无法定义一个本地变量，直接就是指针；代码不明了，容易混淆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span>;	   			<span class="comment">//创建一个数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span>;						<span class="comment">//释放空间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span>;					<span class="comment">//数组有多大</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a, <span class="type">int</span> index)</span>;				<span class="comment">//访问数组中某个单元：可以读也可以写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a, <span class="type">int</span> more_size)</span>;	<span class="comment">//数组增容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_set</span><span class="params">(Array *a, <span class="type">int</span> index, <span class="type">int</span> value)</span>;	<span class="comment">//向数组中写入东西</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;array.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> BLOCK_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个数组</span></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array a;</span><br><span class="line">    a.<span class="built_in">array</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*init_size);</span><br><span class="line">    a.size = init_size;</span><br><span class="line">    <span class="keyword">return</span> a;	</span><br><span class="line">    <span class="comment">//Why Array not Array *?</span></span><br><span class="line">    <span class="comment">//如果用指针型数组，在程序中如果输入的是一个空值NULL或者输入一个已经定义过的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">    a-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">    a-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组包含多少个空间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;size;		<span class="comment">//不用一个定值，是因为这个数组的大小是可变的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问数组中的某个单元：可以读也可以写</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= a-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        array_inflate(a, (index / BLOCK_SIZE + <span class="number">1</span>) * BLOCK_SIZE - a-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;(a-&gt;<span class="built_in">array</span>[index]);		<span class="comment">//Why int* not int?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组增容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a, <span class="type">int</span> more_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(a-&gt;size+more_size));	<span class="comment">//开辟一段空间</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//将原空间的内容全部拷贝到新空间</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = a-&gt;<span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放原空间</span></span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="comment">//新的数组</span></span><br><span class="line">    a-&gt;<span class="built_in">array</span> = p;</span><br><span class="line">    a-&gt;size = a-&gt;size + more_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Array a = array_create(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, array_size(&amp;a));	<span class="comment">//之所以采用这一种而不是下一行这种，因为如果程序复杂之后，下一行这种很容易出错</span></span><br><span class="line">    *array_at(&amp;a, <span class="number">0</span>) = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *array_at(&amp;a), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)</span><br><span class="line">        	*array_at(&amp;a, cnt++) = number</span><br><span class="line">    &#125;</span><br><span class="line">    array_free(&amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-2、链表"><a href="#10-2、链表" class="headerlink" title="10.2、链表"></a>10.2、链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span> &#123;</span>	<span class="comment">//这样做方便工程管理，以为操作更好</span></span><br><span class="line">    Node* head;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List* pList, <span class="type">int</span> number)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(List *pList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>.head = <span class="literal">NULL</span>;	<span class="comment">//头结点</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> ( number != <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            head = add(&amp;<span class="built_in">list</span>, number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( number != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历输出</span></span><br><span class="line">    print(&amp;<span class="built_in">list</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表的搜索，查找</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="type">int</span> isFound = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( p=<span class="built_in">list</span>.head; p; p=p-&gt;next )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;value == number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到了\n&quot;</span>);</span><br><span class="line">            isFound = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !isFound )</span><br><span class="line">    &#123;</span><br><span class="line">        pirntf(<span class="string">&quot;没找到\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表对应数据的删除</span></span><br><span class="line">    Node *q;</span><br><span class="line">    <span class="keyword">for</span> ( q=<span class="literal">NULL</span>, p=<span class="built_in">list</span>.head; p; q=p, p=p-&gt;next )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;value == number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( q )	<span class="comment">//考虑q是不是为空，也就是第一个数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                q-next = p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">list</span>-&gt;head = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表的清除，释放空间</span></span><br><span class="line">    <span class="keyword">for</span> ( p=head; p; p=q )</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的添加</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List* pList, <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// add to linked-list</span></span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));	<span class="comment">//分配地址空间</span></span><br><span class="line">    p-&gt;value = number;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//	find the last</span></span><br><span class="line">    Node *last = pList-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> ( last )	<span class="comment">//头结点不为空的话，（头结点==首结点）？</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">while</span> ( last-&gt;next )</span><br><span class="line">         &#123;</span><br><span class="line">              last = last-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">    <span class="comment">// attach</span></span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">         head = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(List *pList)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历输出</span></span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">for</span> ( p=<span class="built_in">list</span>.head; p; p=p-&gt;next )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十一、文件操作"><a href="#十一、文件操作" class="headerlink" title="十一、文件操作"></a>十一、文件操作</h1><p>文件的操作分为三个步骤：</p>
<ol>
<li>打开文件<ul>
<li>用到fopen函数来实现，主要是建立程序和文件的关系，获取文件在内存中的文件指针，方便后面两步</li>
</ul>
</li>
<li>读写文件<ul>
<li>fprintf、fscanf或者fwrite、fread或者fputs、getss等多组函数来实现</li>
<li>每组函数都分别是写和读文件，这里的读写是面向文件的</li>
</ul>
</li>
<li>关闭文件<ul>
<li>需要fclose函数实现</li>
<li>切断文件指针和文件的关联，避免误操作。</li>
</ul>
</li>
</ol>
<h2 id="11-1、fopen函数"><a href="#11-1、fopen函数" class="headerlink" title="11.1、fopen函数"></a>11.1、fopen函数</h2><p>对文件操作之前，需要打开文件，使用的是fopen函数，它的作用是打开文件，获取该文件的文件指针，方便后续操作。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;	</span><br></pre></td></tr></table></figure>

<p>该函数需要两个字符串类型的参数，第一个是文件名，既要操作的文件对象。第二个是打开方式，这里的打开方式只是，对文件以何种模式打开，包括文本模式打开还是二进制打开、是读还是写等等。如下表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>r+</td>
<td>以读&#x2F;写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>rb+</td>
<td>以读&#x2F;写方式打开一个二进制文件，只允许读&#x2F;写数据。</td>
</tr>
<tr>
<td>rt+</td>
<td>以读&#x2F;写方式打开一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读&#x2F;写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。</td>
</tr>
<tr>
<td>a+</td>
<td>以附加方式打开可读&#x2F;写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。</td>
</tr>
<tr>
<td>wb</td>
<td>以只写方式打开或新建一个二进制文件，只允许写数据。</td>
</tr>
<tr>
<td>wb+</td>
<td>以读&#x2F;写方式打开或新建一个二进制文件，允许读和写。</td>
</tr>
<tr>
<td>wt+</td>
<td>以读&#x2F;写方式打开或新建一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>at+</td>
<td>以读&#x2F;写方式打开一个文本文件，允许读或在文本末追加数据。</td>
</tr>
<tr>
<td>ab+</td>
<td>以读&#x2F;写方式打开一个二进制文件，允许读或在文件末追加数据。</td>
</tr>
</tbody></table>
<p>函数的返回值则表示打开成功后的文件指针，格式为FILE类型，是一个结构体类型，供后面使用，如果打开失败，则返回NULL。</p>
<p><strong>FILE结构体定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">　　<span class="type">int</span> level;　　　　　　　　　　　<span class="comment">/* fill/empty level of buffer */</span> </span><br><span class="line">　　<span class="type">unsigned</span> flags; 　　　　　　 <span class="comment">/* File status flags */</span> </span><br><span class="line">　　<span class="type">char</span> fd;　　　　　　　　　　　 <span class="comment">/* File descriptor */</span> </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> hold;　　　　  <span class="comment">/* Ungetc char if no buffer */</span> </span><br><span class="line">　　<span class="type">int</span> bsize;　　　　　　　　　　 <span class="comment">/* Buffer size */</span> </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> _FAR *buffer;　<span class="comment">/* Data transfer buffer */</span> </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> _FAR *curp;　　<span class="comment">/* Current active pointer */</span> </span><br><span class="line">　　<span class="type">unsigned</span> istemp;　　　　　　<span class="comment">/* Temporary file indicator */</span> </span><br><span class="line">　　<span class="type">short</span> token;　　　　　　　　  <span class="comment">/* Used for validity checking */</span> </span><br><span class="line">&#125; FILE;　</span><br></pre></td></tr></table></figure>

<p>比如，如果我们打开一个D盘根目录下的abc.dat,并且想读出该文件里面的数据，代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(<span class="string">&quot;d:\\abc.dat&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="comment">//后面通过fp指针开始读文件</span></span><br></pre></td></tr></table></figure>

<p>注意：.路径中的反斜杠虽然只有一个，但这里打了两个，原因在于C语言字符串中对反斜杠要当作转义字符处理，因此要用两个反斜杠才能表示一个。</p>
<h2 id="11-2、fprintf"><a href="#11-2、fprintf" class="headerlink" title="11.2、fprintf"></a>11.2、fprintf</h2><p>如果打开模式是写，那么可以用fprintf函数来写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span>*format, [argument])</span></span><br></pre></td></tr></table></figure>

<p>该函数是一个格式化写入的库函数，可以看到，出了长得和printf函数很像外，后面的参数和printf一样，按照指定的格式将数据写入文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;www.dotcpp.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这句代码的意思是将字符串”<a target="_blank" rel="noopener" href="http://www.dotcpp.com/">www.dotcpp.com</a>“ 以%s的格式写入fp所指向的文件中</p>
<table>
<thead>
<tr>
<th>控制符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%d 或 %i</td>
<td>有符号十进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>使用 e 字符的科学科学记数法（尾数和指数）</td>
</tr>
<tr>
<td>%E</td>
<td>使用 E 字符的科学科学记数法（尾数和指数）</td>
</tr>
<tr>
<td>%f</td>
<td>十进制浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>自动选择 %e 或 %f 中合适的表示法</td>
</tr>
<tr>
<td>%G</td>
<td>自动选择 %E 或 %f 中合适的表示法</td>
</tr>
<tr>
<td>%o</td>
<td>有符号八进制</td>
</tr>
<tr>
<td>%s</td>
<td>字符的字符串</td>
</tr>
<tr>
<td>%u</td>
<td>无符号十进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>无符号十六进制整数</td>
</tr>
<tr>
<td>%X</td>
<td>无符号十六进制整数（大写字母）</td>
</tr>
<tr>
<td>%p</td>
<td>指针地址</td>
</tr>
<tr>
<td>%n</td>
<td>无输出</td>
</tr>
<tr>
<td>%</td>
<td>字符</td>
</tr>
</tbody></table>
<h2 id="11-3、fscanf"><a href="#11-3、fscanf" class="headerlink" title="11.3、fscanf"></a>11.3、fscanf</h2><p>fscanf可以从文件里读数据</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">char</span> *format[,argument...])</span>;</span><br></pre></td></tr></table></figure>

<p>作为格式化写数据函数，它的参数同样比scanf也多一个参数，即第一个参数文件指针，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure>

<p>则表示从fp所指向的文件中进行读数据，与空格或换行结束，将结果保存到str数组中</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>读入一个十进制整数</td>
</tr>
<tr>
<td>%i</td>
<td>读入十进制，八进制，十六进制整数，与%d类似，但是在编译时通过数据前置或后置来区分进制，如加入“0x”则是十六进制，加入“0”则为八进制。例如串“031”使用%d时会被算作31，但是使用%i时会算作25</td>
</tr>
<tr>
<td>%u</td>
<td>读入一个无符号十进制整数</td>
</tr>
<tr>
<td>%f %F %g %G</td>
<td>用来输入实数，可以用小数形式或指数形式输入</td>
</tr>
<tr>
<td>%x %x</td>
<td>读入十六进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>读入八进制整数</td>
</tr>
<tr>
<td>%s</td>
<td>直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td>
</tr>
</tbody></table>
<h2 id="11-3、fwrite"><a href="#11-3、fwrite" class="headerlink" title="11.3、fwrite"></a>11.3、fwrite</h2><p>写文件的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<p>第一个ptr是要写入的数据的头指针，无符号类型；</p>
<p>第二个参数size是大小，表示每个写入元素的大小，单位是字节；</p>
<p>第三个参数nmemb是个数，以上一个参数为单位的个数；</p>
<p>第四个参数stream就是文件指针，表示往哪里写。</p>
<p>至于返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;www.dotcpp.com&quot;</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;dotcpp.dat&quot;</span> , <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fwrite(str, <span class="keyword">sizeof</span>(str), <span class="number">1</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如代码所示，程序运行后，并不会在屏幕上有任何显示，而是将str中的字符串写入了dotcpp.dat这个文件中，待程序运行结束退出后，大家可以打开程序同级目录下的dotcpp.dat文件对比</p>
<h2 id="11-4、fread"><a href="#11-4、fread" class="headerlink" title="11.4、fread"></a>11.4、fread</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<p>fread函数的作用是从文件里读内容到程序中，它的参数意思是：</p>
<p>第一个参数ptr表示盛放内容的首地址</p>
<p>第二个参数size表示每个元素的大小，单位还是字节</p>
<p>第三个参数nmem表示要读取的元素个数</p>
<p>第四个参数stream表示的是文件指针，即从哪个文件中读取</p>
<p>返回值则是表示读取元素的个数，与nmemb一致表示读取成功，否则失败</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/* 首先打开文件，读写都可以，假设文件中已经有内容为www.dotcpp.com */</span></span><br><span class="line">   fp = fopen(<span class="string">&quot;dotcpp.dat&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/* 读取并显示数据 */</span></span><br><span class="line">   fread(buffer, <span class="number">1</span>, <span class="number">15</span>, fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">   fclose(fp);</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-5、fclose"><a href="#11-5、fclose" class="headerlink" title="11.5、fclose"></a>11.5、fclose</h2><p>对于文件操作的最后一步，这一步的作用主要是断开程序与文件关联，切断IO数据流，释放文件不在占用，结束文件按操作</p>
<p>这一步的操作很简单，用fclose函数完成。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>其中fp为第一步fopen时成功打开文件后的文件指针；返回值为整型，如成功关闭则返回0，失败则返回-1</p>
<p>如果本步骤不执行，前面的读写文件，可能不会有效果。同时，对win7系统之前，如若不执行本步骤，当试图再次修改如移动打开等操作这个文件的时候就会蹦出“无法修改该文件，该文件已经被xxx打开”的提示，这下我们明白是什么原因</p>

    </div>

    
    
    

    
        <div>
             <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

        </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>李新乾
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2024/07/07/C++/C/" title="C">http://example.com/2024/07/07/C++/C/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/07/Linux/Linux%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="prev" title="Linux_基础(二)-系统软件安装">
      <i class="fa fa-chevron-left"></i> Linux_基础(二)-系统软件安装
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/07/Linux/Linux%E5%9F%BA%E7%A1%80/" rel="next" title="Linux_基础(二)">
      Linux_基础(二) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC82MDA0OC8zNjUxNA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0%E3%80%81%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">0、简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-1%E3%80%81%E5%8E%86%E5%8F%B2"><span class="nav-number">1.1.</span> <span class="nav-text">0.1、历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-2%E3%80%81%E5%8F%91%E5%B1%95%E5%92%8C%E7%89%88%E6%9C%AC"><span class="nav-number">1.2.</span> <span class="nav-text">0.2、发展和版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-3%E3%80%81C%E8%AF%AD%E8%A8%80%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">1.3.</span> <span class="nav-text">0.3、C语言用在哪里</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-4%E3%80%81%E6%B3%A8%E6%84%8F"><span class="nav-number">1.4.</span> <span class="nav-text">0.4、注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-5%E3%80%81%E7%BC%96%E8%BE%91%E2%80%94-%E8%BF%90%E8%A1%8C"><span class="nav-number">1.5.</span> <span class="nav-text">0.5、编辑—&gt;运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-6%E3%80%81%E8%BE%93%E5%87%BA%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">0.6、输出的格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-7%E3%80%81%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="nav-number">1.7.</span> <span class="nav-text">0.7、字符输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">1.7.1.</span> <span class="nav-text">1、文件复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0"><span class="nav-number">1.7.2.</span> <span class="nav-text">2、字符计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%A1%8C%E8%AE%A1%E6%95%B0"><span class="nav-number">1.7.3.</span> <span class="nav-text">3、行计数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-8%E3%80%81%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.</span> <span class="nav-text">0.8、链接属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-9%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.</span> <span class="nav-text">0.9、存储类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">一、程序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A7%84%E5%88%99"><span class="nav-number">2.1.</span> <span class="nav-text">1.1、作用域与规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">1.2、头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">1.3、静态变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F"><span class="nav-number">2.4.</span> <span class="nav-text">1.4、寄存器变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5%E3%80%81%E7%A8%8B%E5%BA%8F%E5%9D%97%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.</span> <span class="nav-text">1.5、程序块结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.6.</span> <span class="nav-text">1.6、初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7%E3%80%81%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86%E5%92%8C%E5%AE%8F"><span class="nav-number">2.7.</span> <span class="nav-text">1.7、编译预处理和宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="nav-number">2.7.1.</span> <span class="nav-text">1、文件包含</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%8F"><span class="nav-number">2.7.2.</span> <span class="nav-text">2、宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="nav-number">2.7.3.</span> <span class="nav-text">3、条件包含</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">2.8.</span> <span class="nav-text">1.8、全局变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">2.8.1.</span> <span class="nav-text">1、全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%9D%99%E6%80%81%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="nav-number">2.8.2.</span> <span class="nav-text">2、静态本地变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.3.</span> <span class="nav-text">3、返回指针的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9%E3%80%81%E6%A0%87%E5%87%86%E5%A4%B4%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.9.</span> <span class="nav-text">1.9、标准头文件结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">二、基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E3%80%81%E5%88%86%E5%8F%B7"><span class="nav-number">3.1.</span> <span class="nav-text">2.1、分号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E3%80%81%E6%B3%A8%E9%87%8A"><span class="nav-number">3.2.</span> <span class="nav-text">2.2、注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">3.3.</span> <span class="nav-text">2.3、标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.4.</span> <span class="nav-text">2.4、关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5%E3%80%81C%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="nav-number">3.5.</span> <span class="nav-text">2.5、C中的空格</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">三、数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E3%80%81%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">3.1、整数类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81unsigned"><span class="nav-number">4.1.1.</span> <span class="nav-text">1、unsigned</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%BF%9B%E5%88%B6"><span class="nav-number">4.1.2.</span> <span class="nav-text">2、进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%80%89%E6%8B%A9%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.3.</span> <span class="nav-text">3、选择整数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81char"><span class="nav-number">4.1.4.</span> <span class="nav-text">4、char</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E3%80%81%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">3.2、浮点类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3%E3%80%81%E9%80%BB%E8%BE%91%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.3.</span> <span class="nav-text">3.3、逻辑类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4%E3%80%81typedef%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">3.4、typedef定义类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">四、常量、变量和运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E3%80%81%E5%B8%B8%E9%87%8F"><span class="nav-number">5.1.</span> <span class="nav-text">4.1、常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-number">5.1.2.</span> <span class="nav-text">2、转义字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.1.3.</span> <span class="nav-text">3、常量表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">5.1.4.</span> <span class="nav-text">4、字符常量和字符串常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F"><span class="nav-number">5.1.5.</span> <span class="nav-text">5、枚举常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E7%AC%A6%E5%8F%B7%E5%B8%B8%E9%87%8F"><span class="nav-number">5.1.6.</span> <span class="nav-text">6、符号常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2%E3%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text">4.2、变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.</span> <span class="nav-text">4.3、运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.1.</span> <span class="nav-text">1、算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.2.</span> <span class="nav-text">2、关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.3.</span> <span class="nav-text">3、逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.4.</span> <span class="nav-text">4、位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.5.</span> <span class="nav-text">5、赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6%E2%86%A6-sizeof-%E4%B8%89%E5%85%83"><span class="nav-number">5.3.6.</span> <span class="nav-text">6、杂项运算符↦ sizeof &amp; 三元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81sizeof"><span class="nav-number">5.3.6.1.</span> <span class="nav-text">①、sizeof</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">5.3.7.</span> <span class="nav-text">7、运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.4.</span> <span class="nav-text">4.4、类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.4.1.</span> <span class="nav-text">1、自动类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.4.2.</span> <span class="nav-text">2、强制类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.</span> <span class="nav-text">五、语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E3%80%81%E8%AF%AD%E5%8F%A5%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%9D%97"><span class="nav-number">6.1.</span> <span class="nav-text">5.1、语句和程序块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2%E3%80%81if-else%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.2.</span> <span class="nav-text">5.2、if-else语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3%E3%80%81else-if-%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.3.</span> <span class="nav-text">5.3、else-if 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4%E3%80%81%E5%A4%9A%E8%B7%AF%E5%88%86%E6%94%AF%EF%BC%88switch-case"><span class="nav-number">6.4.</span> <span class="nav-text">5.4、多路分支（switch-case)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5%E3%80%81while%E5%BE%AA%E7%8E%AF"><span class="nav-number">6.5.</span> <span class="nav-text">5.5、while循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6%E3%80%81do-while%E5%BE%AA%E7%8E%AF"><span class="nav-number">6.6.</span> <span class="nav-text">5.6、do-while循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7%E3%80%81for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">6.7.</span> <span class="nav-text">5.7、for 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8%E3%80%81break%E8%AF%AD%E5%8F%A5%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.8.</span> <span class="nav-text">5.8、break语句和continue语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9%E3%80%81goto%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.9.</span> <span class="nav-text">5.9、goto语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">六、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1%E3%80%81%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.</span> <span class="nav-text">6.1、定义函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2%E3%80%81%E8%BF%94%E5%9B%9E%E9%9D%9E%E6%95%B4%E5%9E%8B%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">6.2、返回非整型值的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4%E3%80%81%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">6.4、调用函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5%E3%80%81%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%EF%BC%88%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">7.4.</span> <span class="nav-text">6.5、本地变量（局部变量）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">7.5.</span> <span class="nav-text">6.6、函数参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%8C%87%E9%92%88"><span class="nav-number">8.</span> <span class="nav-text">七、指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">8.1.</span> <span class="nav-text">7.1、定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2%E3%80%81-NULL-%E6%8C%87%E9%92%88"><span class="nav-number">8.2.</span> <span class="nav-text">7.2、 NULL 指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">8.3.</span> <span class="nav-text">7.3、数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6%E3%80%81%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.4.</span> <span class="nav-text">7.6、指针的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-number">8.5.</span> <span class="nav-text">7.8、字符串操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">8.5.1.</span> <span class="nav-text">1、单字符输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84"><span class="nav-number">8.5.2.</span> <span class="nav-text">2、字符串数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">8.6.</span> <span class="nav-text">7.9、字符串函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81strlen"><span class="nav-number">8.6.1.</span> <span class="nav-text">1、strlen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81strcmp"><span class="nav-number">8.6.2.</span> <span class="nav-text">2、strcmp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81strcpy"><span class="nav-number">8.6.3.</span> <span class="nav-text">3、strcpy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="nav-number">8.7.</span> <span class="nav-text">8.2、初始化数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3%E3%80%81%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-number">8.8.</span> <span class="nav-text">8.3、访问数组元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4%E3%80%81%E7%89%B9%E7%82%B9"><span class="nav-number">8.9.</span> <span class="nav-text">8.4、特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5%E3%80%81%E6%8A%A5%E9%94%99"><span class="nav-number">8.10.</span> <span class="nav-text">8.5、报错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">8.11.</span> <span class="nav-text">8.6、二维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.11.1.</span> <span class="nav-text">1、二维数组的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.</span> <span class="nav-text">九、结构类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="nav-number">9.1.</span> <span class="nav-text">9.1、枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">9.1.1.</span> <span class="nav-text">1、枚举变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%B0%86%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9E%9A%E4%B8%BE"><span class="nav-number">9.1.2.</span> <span class="nav-text">2、将整数转换为枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2%E3%80%81%E7%BB%93%E6%9E%84"><span class="nav-number">9.2.</span> <span class="nav-text">9.2、结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-1"><span class="nav-number">9.2.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="nav-number">9.2.2.</span> <span class="nav-text">2、表示方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">9.2.3.</span> <span class="nav-text">3、结构的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-number">9.2.4.</span> <span class="nav-text">4、结构体指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">9.2.5.</span> <span class="nav-text">5、结构作为函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="nav-number">9.2.6.</span> <span class="nav-text">6、结构数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">9.2.7.</span> <span class="nav-text">7、结构中的结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3%E3%80%81%E8%81%94%E5%90%88"><span class="nav-number">9.3.</span> <span class="nav-text">9.3、联合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">10.</span> <span class="nav-text">十、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1%E3%80%81%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84"><span class="nav-number">10.1.</span> <span class="nav-text">10.1、可变数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">10.2.</span> <span class="nav-text">10.2、链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">11.</span> <span class="nav-text">十一、文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1%E3%80%81fopen%E5%87%BD%E6%95%B0"><span class="nav-number">11.1.</span> <span class="nav-text">11.1、fopen函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2%E3%80%81fprintf"><span class="nav-number">11.2.</span> <span class="nav-text">11.2、fprintf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3%E3%80%81fscanf"><span class="nav-number">11.3.</span> <span class="nav-text">11.3、fscanf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3%E3%80%81fwrite"><span class="nav-number">11.4.</span> <span class="nav-text">11.3、fwrite</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4%E3%80%81fread"><span class="nav-number">11.5.</span> <span class="nav-text">11.4、fread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5%E3%80%81fclose"><span class="nav-number">11.6.</span> <span class="nav-text">11.5、fclose</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李新乾"
      src="/images/cat.png">
  <p class="site-author-name" itemprop="name">李新乾</p>
  <div class="site-description" itemprop="description">命由我做，福自己求</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lxq-02" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lxq-02" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://chatgpt.com/" title="Chatgpt → https:&#x2F;&#x2F;chatgpt.com" rel="noopener" target="_blank"><i class="fas fa-robot fa-fw"></i>Chatgpt</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      链接网站
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mail.qq.com/" title="https:&#x2F;&#x2F;mail.qq.com" rel="noopener" target="_blank">QQ邮箱</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://outlook.live.com/" title="https:&#x2F;&#x2F;outlook.live.com" rel="noopener" target="_blank">Outlook</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fishc.com.cn/" title="https:&#x2F;&#x2F;fishc.com.cn" rel="noopener" target="_blank">鱼C论坛</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李新乾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset);
            clearInterval(int);
        }
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据
            clearInterval(int); // 停止检测
        }
    }

});
</script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
