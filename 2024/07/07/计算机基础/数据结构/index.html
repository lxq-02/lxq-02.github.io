<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、绪论线性结构是一个*有序*数据元素的*集合，元素之间具有一对一的线性关系* 线性结构：线性表、栈、队列、双队列、数组、串 非线性结构：二维数组、多维数组、广义表、树，图 程序不一定满足有穷性，如死循环、操作系统等；而算法必须有穷 算法的五个基本特性：①有穷性②确定性③可行性④输入⑤输出     数据结构中，数据从存储结构上可以分成顺序、链接索引与散列存储方法 1.1、数据结构的基本概念1.1.">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="李新乾的个人博客">
<meta property="og:description" content="一、绪论线性结构是一个*有序*数据元素的*集合，元素之间具有一对一的线性关系* 线性结构：线性表、栈、队列、双队列、数组、串 非线性结构：二维数组、多维数组、广义表、树，图 程序不一定满足有穷性，如死循环、操作系统等；而算法必须有穷 算法的五个基本特性：①有穷性②确定性③可行性④输入⑤输出     数据结构中，数据从存储结构上可以分成顺序、链接索引与散列存储方法 1.1、数据结构的基本概念1.1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217214018703.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217214216943.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217163656719.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217214427128.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217215220757.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217215348912.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217215359651.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217215922730.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220302203523040.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220302203531019.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220544100.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220840975.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220915022.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220937724.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220951366.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217221008668.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217221025002.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217221111085.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217221346443.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220304190319097.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220304190525056.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309201510278-16468281114641.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309201619591.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309201745130.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309201830626.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309202103149.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309202142377.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220331142715683.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220331143016713.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309202839799.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309202856189.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203010006.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203055324.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203129973.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220402150932798.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220402151316623.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203414139.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203420408.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203449108.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203457379.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203503918.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203510588.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203517057.png">
<meta property="og:image" content="http://example.com/2024/07/Blogs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220309203524847.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203533625-16468293383074.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203548685.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203555052.png">
<meta property="og:image" content="http://example.com/2024/07/Blogs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220309203602245.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203609324.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203616972.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203623781.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203630741.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203639092.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203646217.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203657516.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203705818.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203712953.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps5.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps6.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309204045836.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309204138724.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309204148492.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316104300445.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220403144003173.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327152317009.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327152356188.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327153249582.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327153339878.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316111013699.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316111213152.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316111353122.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327153755871.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327153853518.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316111520306.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154149019.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154317159.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154615934.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154701766.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154713370.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154817603.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154931802.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155028385.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155136786.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155226310.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155255984.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155358833.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155546656.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155600385.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114140768.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114214687.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114237997.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114309300.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155913383.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155927065.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114904281.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220321152336259.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220403154358925.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220403160454429.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170203169.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170235754.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170258322.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170542192.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170608731.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170719251.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170954589.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171056495.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171334573.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171410926.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171635426.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171743169.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171751450.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171807278.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327172701573.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327172743231.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327172756188.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327173543865.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327173927558.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327173940590.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174000521.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174206566.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174239629.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174357071.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174406061.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174417550.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174429047.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174439669.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174502319.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174534416.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404152845227.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090447281.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090557224.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090706818.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090805422.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090855626.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430091243914.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430091605053.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430092121426.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404173500963.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430092329950.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430092348976.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430092437872.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404174422580.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430093123892.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430093140292.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175020977.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175159469.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175315291.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175625621.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175741363.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175837135.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175856214.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404180004795.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404180027557.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404180227105.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194743210.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194751615.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194819897.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194832691.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194845128.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406190524283.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191106932.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191430680.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191751823.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191854055.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191913744.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192017584.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192138400.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192153848.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192517644.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192621446.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102236456.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102622939.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102633779.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102844707.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102958350.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430103044415.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430103125103.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430103218439.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430103509094.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430104205487.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps7.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps8.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps9.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110715720.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110808521.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110835529.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110903433.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110920824.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111035849.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111106995.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111144420.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111204265.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111223604.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111306241.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111322153.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111451262.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111509376.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111724769.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111756707.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111909537.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111940388.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430112028973.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430112257750.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430112309304.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220413113228766.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430142807444.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220413113352259.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430143559376.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430143812780.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430195437441.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430195559031.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430144655044.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430145224262.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430145410474.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430145516259.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150108280.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150119115.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150257167.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150343993.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150755428.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150917956.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150935416.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150943502.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150953443.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164007717.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164017785.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164035944.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164302741.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164407858.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164719709.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164755835.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164850493.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165047893.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165142884.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165319197.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165354172.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165703818.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165859604.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170040399.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170121008.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170242138.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170353523.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170401143.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170409771.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170418570.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170425487.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170432964.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170441800.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170450624.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170458012.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170505956.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170513278.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170521632.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170531876.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170540047.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170547751.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170554459.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170651120.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170950439.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171047640.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171115419.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171126419.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171207128.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171225781.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171234043.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171311781.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171318970.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171357627.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171617193.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171639931.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171647183.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171835596.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171916368.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184858197.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184913353.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184951612.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185002186.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185009768.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185038845.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185047042.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185129792.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171935232.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171943188.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171950080.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430172049809.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430172531696.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184607768.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184617351.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184710915.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184735896.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185312519.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185359040.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185550175.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185600049.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185610759.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185708137.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185746384.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185802631.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185811811.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185818382.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps10.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps11.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps12.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps13.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504103935453.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504104551916.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504104602459.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504104854120.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504104907204.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504105013204.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504105328481.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504105826544.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504105934646.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504110257288.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504111200323.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504111751944.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504112059071.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504112257436.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504114400573.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504114415100.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504120843315.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504140837162.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504140918776.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504141943569.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504141657987.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504175405148.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504180124222.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504180704782.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504181214554.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504181416383.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504181628550.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504182015539.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509152819840.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509153932738.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509155333937.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509161105059.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509163412556.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509164258769.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509164439582.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509164506200.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509164831118.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509165121272.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509165128684.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509165226936.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509171745984.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509172458434.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509173010636.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509173739332.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509173946932.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174002829.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174022264.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174035459.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174109174.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174126383.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174135039.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174231260.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174239167.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174247474.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174258722.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174310847.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174335574.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174348675.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174403187.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174417743.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174428749.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174440302.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174455323.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102039773.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102119621.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102318940.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102343523.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102350987.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102358743.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102410532.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102420210.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102439266.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102456385.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102509575.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102551920.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102610247.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102627857.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102647776.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102713721.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102724770.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102742984.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102948722.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103011043.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103019840.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103030076.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103213539.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103222239.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103247960.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103257749.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103316292.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103322658.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103331936.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103339002.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103353804.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103400761.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103410064.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103418843.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103447552.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103513116.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103523636.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103537133.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103553020.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103611913.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103622128.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103633222.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103647320.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103716614.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103658852.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103806632.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103823863.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103841173.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103851483.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps14.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps15.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps16.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps17.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps18.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps19.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps20.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps21.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps22.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps23.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps24.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps25.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps26.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps27.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps28.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps1.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2510762-20220326104341352-1854258240.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2510762-20220326104604748-268284983.png">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps2.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps3.jpg">
<meta property="og:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps4.jpg">
<meta property="article:published_time" content="2024-07-07T04:00:00.000Z">
<meta property="article:modified_time" content="2024-08-23T06:51:34.326Z">
<meta property="article:author" content="李新乾">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217214018703.png">

<link rel="canonical" href="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构 | 李新乾的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="李新乾的个人博客" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李新乾的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="李新乾">
      <meta itemprop="description" content="命由我做，福自己求">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李新乾的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构
        </h1>

        <div class="post-meta">
	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-07-07T12:00:00+08:00">2024-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-23 14:51:34" itemprop="dateModified" datetime="2024-08-23T14:51:34+08:00">2024-08-23</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><p>线性结构是一个<em><strong>*有序*<em><strong>数据元素的</strong></em>*集合，元素之间具有一对一的线性关系*</strong></em></p>
<p>线性结构：线性表、栈、队列、双队列、数组、串</p>
<p>非线性结构：二维数组、多维数组、广义表、树，图</p>
<p>程序不一定满足有穷性，如死循环、操作系统等；而算法必须有穷</p>
<p>算法的五个基本特性：①有穷性②确定性③可行性④输入⑤输出</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217214018703.png" alt="image-20230217214018703"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217214216943.png" alt="image-20230217214216943"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217163656719.png" alt="image-20230217163656719"></p>
<p>数据结构中，数据从存储结构上可以分成<strong>顺序、链接索引与散列</strong>存储方法</p>
<h2 id="1-1、数据结构的基本概念"><a href="#1-1、数据结构的基本概念" class="headerlink" title="1.1、数据结构的基本概念"></a>1.1、数据结构的基本概念</h2><h3 id="1-1-1、基本概念和术语"><a href="#1-1-1、基本概念和术语" class="headerlink" title="1.1.1、基本概念和术语"></a>1.1.1、基本概念和术语</h3><p><strong>数据（data）</strong>是描述客观事物的数和字符的集合。</p>
<p><strong>数据元素（data element）</strong>是数据的基本单位。<br><strong>数据项（data item）</strong>是具有独立含义是数据最小单位，也称为字段或域。<br><strong>数据对象（data object）</strong>是指性质相同的数据元素的集合，它是数据的一个子集。<br><strong>数据结构（data structure）</strong>是指所有数据元素以及数据元素之间的关系。也就是带结构的数据的集合。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217214427128.png" alt="image-20230217214427128"></p>
<p>比如，20级3班所有学生的所有信息的整体就是数据对象，每个人的所有数据称为数据元素，个人是身高、男女等称作数据项</p>
<h3 id="1-1-2、数据结构的三要素"><a href="#1-1-2、数据结构的三要素" class="headerlink" title="1.1.2、数据结构的三要素"></a>1.1.2、数据结构的三要素</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217215220757.png" alt="image-20230217215220757"></p>
<p>数据结构包括3个方面</p>
<ol>
<li>数据的逻辑结构（logical structure）：数据元素之间的关系</li>
<li>数据的存储结构（storage structure）：在计算机存储器上，数据及其关系的表示</li>
<li>数据的运算（operation）：对数据的操作</li>
</ol>
<h4 id="1、逻辑结构"><a href="#1、逻辑结构" class="headerlink" title="1、逻辑结构"></a>1、逻辑结构</h4><ol>
<li>集合</li>
<li>线性结构：一对一</li>
<li>树形结构：一对多</li>
<li>图形结构：多对多</li>
</ol>
<p>同一个集合可以有多种逻辑结构</p>
<h4 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h4><p>数据在计算机中的存储方式就是存储结构，逻辑结构映射为存储结构</p>
<p>①顺序存储结构（sequential storage structure）<br>②链式存储结构（linked storage strucrure）<br>③索引存储结构（indexed storage structure）<br>④哈希（散列）存储结构（hashed storage structure）</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217215348912.png" alt="image-20230217215348912"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217215359651.png" alt="image-20230217215359651"> </p>
<h2 id="1-2、数据类型和抽象数据类型"><a href="#1-2、数据类型和抽象数据类型" class="headerlink" title="1.2、数据类型和抽象数据类型"></a>1.2、数据类型和抽象数据类型</h2><h3 id="1-2-1、数据类型"><a href="#1-2-1、数据类型" class="headerlink" title="1.2.1、数据类型"></a>1.2.1、数据类型</h3><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称</p>
<ol>
<li>原子类型。其值不可再分的数据类型</li>
<li>结构类型。其值可以再分解为若干成分（分量）的数据类型</li>
</ol>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217215922730.png" alt="image-20230217215922730"></p>
<h3 id="1-2-2、抽象数据类型"><a href="#1-2-2、抽象数据类型" class="headerlink" title="1.2.2、抽象数据类型"></a>1.2.2、抽象数据类型</h3><p>抽象数据类型（Abstract Data Type,ADT）指从求解问题的数学模型中抽象出来的<strong>逻辑数据结构</strong>和<strong>运算</strong>，而不考虑计算机的具体实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类姓名</span><br><span class="line">&#123;</span><br><span class="line">	数据对象：数据对象的声明</span><br><span class="line">	数据关系：数据关系的声明</span><br><span class="line">	基本运算：基本运算的声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220302203523040.png" alt="image-20220302203523040"><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220302203531019.png" alt="image-20220302203531019"></p>
<h2 id="1-3、算法"><a href="#1-3、算法" class="headerlink" title="1.3、算法"></a>1.3、算法</h2><h3 id="1-3-1、算法的基本概念"><a href="#1-3-1、算法的基本概念" class="headerlink" title="1.3.1、算法的基本概念"></a>1.3.1、算法的基本概念</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220544100.png" alt="image-20230217220544100"></p>
<p>算法（Algorithm）</p>
<ol>
<li>有穷性：在有穷步之后结束</li>
<li>确定性：没有歧义，相同的输入可以得到相同的输出</li>
<li>可行性：基本运算可以有限次执行，每个动作可以机械执行</li>
<li>有输入：零个或多个</li>
<li>有输出：一个或多个</li>
</ol>
<p>好的算法的特质</p>
<ul>
<li>正确性。算法能够正确地求解问题</li>
<li>可读性：算法具有良好的可读性，以帮助人们理解</li>
<li>健壮性：输入非法数据时，算法可以适当地做出反应，而不会产生莫名其妙的输出结果</li>
<li>高效率与低存储需求</li>
<li>*<em>空间复杂度</em>S(n)<em><strong>——根据算法写成的程序在执行时</strong>占用存储单元的长度。</em>*这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</li>
<li>*<em>时间复杂度</em>T(n)<em><strong>——根据算法写成的程序在执行时</strong>耗费时间的长度</em>*。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。</li>
</ul>
<h3 id="1-3-2、时间复杂度"><a href="#1-3-2、时间复杂度" class="headerlink" title="1.3.2、时间复杂度"></a>1.3.2、时间复杂度</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220840975.png" alt="image-20230217220840975"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220915022.png" alt="image-20230217220915022"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220937724.png" alt="image-20230217220937724"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217220951366.png" alt="image-20230217220951366"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217221008668.png" alt="image-20230217221008668"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217221025002.png" alt="image-20230217221025002"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217221111085.png" alt="image-20230217221111085"> </p>
<h3 id="1-3-3、空间复杂度"><a href="#1-3-3、空间复杂度" class="headerlink" title="1.3.3、空间复杂度"></a>1.3.3、空间复杂度</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230217221346443.png" alt="image-20230217221346443"> </p>
<h1 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h1><p>线性表是一种典型的线性结构，也是一种常用的数据结构。</p>
<p>一个线性表是n个具有相同特性的****数据元素****的有限序列</p>
<p>数据项：一个数据元素由若干数据项组成</p>
<p>数据元素：组成数据对象的基本单位</p>
<p>数据对象：性质相同的数据元素的集合（类似数组）</p>
<h2 id="2-1、基本概念"><a href="#2-1、基本概念" class="headerlink" title="2.1、基本概念"></a>2.1、基本概念</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p><strong>线性表（linear list）是具有相同特性的数据元素的一个有限序列。</strong></p>
<p><strong>相同特性</strong>：所有元素属于同一数据类型。<br><strong>有限</strong>：数据元素个数是有限的。<br><strong>序列</strong>：数据元素由逻辑序号唯一确定。一个线性表中可以有相同值的元素。</p>
<p>该序列所含元素的个数叫做线性表的长度，用n表示,n &geq; 0。当 n&#x3D;0 时，表示线性表是一个空表，不含任何元素。</p>
<p>线性表的每个数据元素由逻辑序号确定，设序列中的第 <em>i</em>（<em>i</em> 表示逻辑序号）个元素为 <em>a<sub>i</sub></em> (1&leq; i &leq; n)，则线性表的一般表示为$(a_1,a_2,···,a_n)$</p>
<h3 id="2、运算"><a href="#2、运算" class="headerlink" title="2、运算"></a>2、运算</h3><p>线性表的9个基本运算</p>
<ol>
<li>初始化线性表 **InitList(&amp;L)**：构造一个空的线性表L</li>
<li>销毁线性表 **DestroyList(&amp;L)**：释放线性表L占用的内存空间</li>
<li>判断线性表是否为空表 **ListEmpty(L)**：若L 为空表，返回真；反之，返回假</li>
<li>求线性表的长度 **ListLength(L)**：返回L中元素个数n</li>
<li>输出线性表 **DispList(L)**：输出线性表每个节点的值域</li>
<li>求线性表L 中指定位置的某个数据元素 **GetElem(L, i, &amp;e)**：用e返回L 中第i个元素的值</li>
<li>定位查找 **LocateElem(L, e)**：返回L 中第一个值域与 e 相等的逻辑位序，若不存在，返回0</li>
<li>插入一个数据元素 **ListInsert(&amp;L, i, e)**：在L 的第i 个元素之前插入新的元素 e，L长度加1</li>
<li>删除数据元素 **ListDelete(&amp;L, i, &amp;e)**：删除第i个元素，并用 e 返回其值，L的长度减1</li>
</ol>
<p>线性表的作用：</p>
<ol>
<li>程序员可以直接用它来存放数据，即作为存放数据的容器</li>
<li>可以使用它的基本运算来完成更复杂的功能</li>
</ol>
<h3 id="3、知识结构"><a href="#3、知识结构" class="headerlink" title="3、知识结构"></a>3、知识结构</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220304190319097.png" alt="image-20220304190319097"></p>
<p>线性表的重要知识点：</p>
<ul>
<li>线性表两类存储结构的差异。</li>
<li>每种存储结构中基本运算的实现算法。</li>
<li>利用线性表求解实际问题。</li>
<li>利用有序表特性设计高效算法。</li>
</ul>
<h2 id="2-2、顺序表"><a href="#2-2、顺序表" class="headerlink" title="2.2、顺序表"></a>2.2、顺序表</h2><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><p>线性表的顺序存储结构：把线性表中的所有元素按照逻辑顺序依次存储到从计算机存储器中指定存储位置开始的一块连续的存储空间中。</p>
<p>线性表逻辑上相邻的两个元素在对应的顺序表中存储位置也相邻，称为<strong>直接映射</strong></p>
<p><strong>随机存取</strong>的存储结构，就是可以通过首地址加逻辑序号直接在某个位置，存储或取出数据</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220304190525056.png" alt="image-20220304190525056"></p>
<p>顺序表类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MaxSize];	<span class="comment">//ElemType是自定义数据类型，是自己定义的，可以是int ,char等等</span></span><br><span class="line">    <span class="type">int</span> length;		<span class="comment">//length成员存放线性表的实际长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//data成员存放元素</span></span><br><span class="line"><span class="comment">//逻辑位序和物理位序相差1</span></span><br></pre></td></tr></table></figure>



<h3 id="2、运算的实现"><a href="#2、运算的实现" class="headerlink" title="2、运算的实现"></a>2、运算的实现</h3><p>建立顺序表</p>
<p>a[0..n-1]——整体创建顺序表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList</span><span class="params">(SqLiST *&amp;L,ElemType a[],<span class="type">int</span> n)</span>	<span class="comment">//由a中的n个元素建立顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>,k = <span class="number">0</span>;	<span class="comment">//k表示L中的元素个数，初始值为0</span></span><br><span class="line">    L = (SqList * )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqList));	<span class="comment">//分配存放线性表的空间</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)	<span class="comment">//i扫描数字a的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[k] = a[i];	<span class="comment">//将元素a[i]存放到L中</span></span><br><span class="line">        k++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length = k;	<span class="comment">//设置L的长度k</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *&amp;L是引用类型指针，它代表的是原指针，它和原指针的关系 就相当于 两台手机共用一个账号，信息是共享的</span></span><br><span class="line"><span class="comment">//	*L是指针变量，存放的是内存地址，在函数中，它是形参，是单方向的，它的修改，改变了内存地址，但不会对原地址进行修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof是一个操作符，返回一个内存空间的大小</span></span><br><span class="line"><span class="comment">//sizeof(SqList)返回SqList的内存空间大小</span></span><br><span class="line"><span class="comment">//malloc(sizeof(SqList))是分配一个这样的内存空间，并返回首地址</span></span><br><span class="line"><span class="comment">//(SqList * )malloc(sizeof(SqList)):将这个首地址作为SqList的指针</span></span><br></pre></td></tr></table></figure>



<h3 id="3、基本运算算法"><a href="#3、基本运算算法" class="headerlink" title="3、基本运算算法"></a>3、基本运算算法</h3><p>（1）初始化线性表<strong>InitList(&amp;L)</strong></p>
<p>该运算的结构是构建一个空的线性表 L。实际上只需将 length 成员设置为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *&amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分配线性表的存储空间</span></span><br><span class="line">    L = (SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）销毁线性表 <strong>DestroyList(L)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(SqList *&amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(L);	<span class="comment">//释放线性表L 的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）判定是否为空表 <strong>ListEmpty(L)</strong></p>
<p>该运算返回一个值表示L是否为空表。若L 是空表，返回true, 否则返回 false.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListEmpty</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(L-&gt;length == <span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）求线性表的长度 <strong>ListLength(L)</strong></p>
<p>该运算返回顺序表L的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）输出线性表 <strong>DispList(L)</strong></p>
<p>该运算当线性表L不为空时，顺序显示 L 中各元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DispList</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(ListEmpty(L))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, L-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）求线性表L 中指定位置的某个数据元素 **GetElem(L, i, &amp;e)**：用e返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(SqList *L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本算法的时间复杂度为 O(1),体现了顺序表的随机存取特性</span></span><br></pre></td></tr></table></figure>

<p>（7）L中第i个元素的值定位查找 **LocateElem(L, e)**：返回L 中第一个值域与 e 相等的逻辑位序，若不存在，返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList *L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; L-&gt;length &amp;&amp; L-&gt;data[i] != e)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（8）插入一个数据元素 <strong>ListInsert(&amp;L, i, e)</strong></p>
<p>在顺序表的第 <em>i</em> 个位置插入新元素 e。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList *&amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;    <span class="type">int</span> j;    </span><br><span class="line"> 	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>)    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//如果 i 值不正确，返回 false,    </span></span><br><span class="line">    &#125;    </span><br><span class="line"> 	i--;    </span><br><span class="line"> 	<span class="keyword">for</span>(j = L-&gt;length; j &gt; i; j--)    </span><br><span class="line">    &#123;        </span><br><span class="line">        L-&gt;data[j] = L-&gt;data[j - <span class="number">1</span>];	<span class="comment">//插入位置后面的元素向后移一个位置    </span></span><br><span class="line">    &#125;    </span><br><span class="line"> 	L-&gt;data[i] = e;    </span><br><span class="line"> 	L-&gt;length++;    </span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="comment">//平均时间复杂度为 O(n)</span></span><br></pre></td></tr></table></figure>



<p>（9）删除数据元素<em><em>ListDelete</em>(&amp;L,i,&amp;e)</em>**</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList *&amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="type">int</span> j;    </span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//参数错误时返回false    </span></span><br><span class="line">    i--;		<span class="comment">//将顺序表逻辑序号 转化为 物理序号    </span></span><br><span class="line">    e=L-&gt;data[i];    </span><br><span class="line">    <span class="keyword">for</span>(j=i;i&lt;L-&gt;length<span class="number">-1</span>;j++)        </span><br><span class="line">        L-&gt;data[j]=L-&gt;data[j+<span class="number">1</span>];    </span><br><span class="line">    L-&gt;length--;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="comment">//平均时间复杂度为 O(n)</span></span><br></pre></td></tr></table></figure>



<h3 id="4、算法设计"><a href="#4、算法设计" class="headerlink" title="4、算法设计"></a>4、算法设计</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309201510278-16468281114641.png" alt="image-20220309201510278"></p>
<p>空间复杂度与临时变量有关，一个临时变量，空间复杂度为O(1)</p>
<p><strong>解法一：（重建法）</strong>设删除A中所有值等于x元素后的顺序表为 A1，显然A1包含在A中，为此A1重建A的空间</p>
<p>思路：扫描顺序表A，重建A只包含不等于x的元素</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309201619591.png" alt="image-20220309201619591"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delnode1</span><span class="params">(SqList *&amp;A, ElemType x)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i;	<span class="comment">//k记录值不等于X的元素个数    </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A-&gt;length; i++)    </span><br><span class="line">    &#123;		</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;data[i] != x)	<span class="comment">//若当前元素不为x，将其插入A中        </span></span><br><span class="line">        &#123;			</span><br><span class="line">            A-&gt;data[k] = A-&gt;data[i];             </span><br><span class="line">            k++;	<span class="comment">//不等于x的元素增1        </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    A-&gt;length = k;	<span class="comment">//顺序表A的长度等于k&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>解法二（前移法）：</strong>用k记录顺序表A中等于x的元素个数，一边扫描A一边统计k值。</p>
<p>思路：将不为x的元素前移k 个位置，最后修改A的长度。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309201745130.png" alt="image-20220309201745130"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delnode2</span><span class="params">(SqList *&amp;A, ElemType x)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>;	<span class="comment">//k记录值等于x的元素个数    </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; A-&gt;length)    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span>(A-&gt;data[i] == x)        </span><br><span class="line">        &#123;            </span><br><span class="line">            k++;	<span class="comment">//当前元素值为x时，k增1        </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;            </span><br><span class="line">            A-&gt;data[i - k] = A-&gt;data[i];	<span class="comment">//当前元素不为x时将其前移k个位置        </span></span><br><span class="line">        &#125;        </span><br><span class="line">        i++;	</span><br><span class="line">    &#125;    </span><br><span class="line">    A-&gt;length -= k;	<span class="comment">//顺序表A的长度减K</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3、链表"><a href="#2-3、链表" class="headerlink" title="2.3、链表"></a>2.3、链表</h2><p>线性表的链式存储结构</p>
<p>链表是数据结构之一，其中的数据呈线性排列。在链表中，数据的添加和删除都较为方便，就是访问比较耗费时间。</p>
<ul>
<li>每个数据都有一个指针</li>
<li>数据分散在内存中，无需存储在连续空间中</li>
<li>访问时，只能从第一个数据开始，一一向下访问</li>
<li>添加数据时，只需要改变添加位置前后的指针就可以了，删除也是</li>
</ul>
<h3 id="1、定义-2"><a href="#1、定义-2" class="headerlink" title="1、定义"></a>1、定义</h3><p>线性表的链式存储结构称为<strong>链表</strong>（linked list）</p>
<p>线性表中每个结点有唯一的前驱结点和后继结点。</p>
<p><strong>数据域</strong>：存储结点中元素本身的信息</p>
<p><strong>指针域</strong>：元素之间的逻辑关系，用指针表示</p>
<p><strong>单链表：</strong>每个物理结点增加一个指向后继结点的指针域</p>
<p><strong>双链表：</strong>每个物理结点增加一个指向后继结点的指针域和一个指向前驱结点的指针域</p>
<p><strong>头指针（head pointer）</strong>：每个链表都带有一个头结点，头结点的指针指向这个链表，头结点的指针就是头指针</p>
<p><strong>首指针（first pointer）</strong>：首结点的指针</p>
<p><strong>尾指针（tail pointer）</strong>：尾结点的指针</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309201830626.png" alt="image-20220309201830626"></p>
<p>单链表增加一个头结点的优点：</p>
<ul>
<li>第一个结点的操作和表中其他结点的操作相一致，无需进行特殊处理</li>
<li>无论链表是否为空，都有一个头结点，因此空表和非空表的处理也统一了</li>
</ul>
<p><strong>存储密度</strong>是指 结点数据本身所占的空间 和 整个结点结构中所占的空间之比。</p>
<p>存储密度越大，存储空间的利用率就越高。显然，顺序表的存储密度为1，而链表的存储密度小于1.</p>
<h3 id="2、单链表"><a href="#2、单链表" class="headerlink" title="2、单链表"></a>2、单链表</h3><p>结点类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;	<span class="comment">//存放元素值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>		<span class="comment">//指向后继结点</span></span><br><span class="line">&#125;LinkNode;		<span class="comment">//单链表结点类型</span></span><br></pre></td></tr></table></figure>

<p>单链表访问过一个结点后，只能接着访问它的后继结点，而无法访问它的前驱结点。</p>
<h4 id="①、插入结点和删除结点操作"><a href="#①、插入结点和删除结点操作" class="headerlink" title="①、插入结点和删除结点操作"></a>①、<strong>插入结点和删除结点操作</strong></h4><p>1）插入结点</p>
<p>插入操作：将值为x的新结点 *s 插入到 *p结点之后</p>
<p>特点：只需修改相关结点的指针域，不需要移动结点</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309202103149.png" alt="image-20220309202103149"></p>
<p>2）删除结点</p>
<p>删除操作：删除*p结点之后的一个结点</p>
<p>特点：只需修改相关结点的指针域，不需要移动结点</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309202142377.png" alt="image-20220309202142377"></p>
<h4 id="②、建立单链表"><a href="#②、建立单链表" class="headerlink" title="②、建立单链表"></a>②、建立单链表</h4><p>（1）头插法建表</p>
<ul>
<li>从一个空表开始，创建一个头结点</li>
<li>依次读取字符数组a中的元素，生成新结点</li>
<li>将新结点插入到当前链表的<strong>表头</strong>上，直到结束为止</li>
<li>注意：链表的顺序与逻辑顺序 相反</li>
<li><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220331142715683.png" alt="image-20220331142715683"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法算法如下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListF</span><span class="params">(LinkNode *&amp;L, ElemType a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkNode *s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;	<span class="comment">//创建头结点，其next域置为NULL</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//循环建立数据结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">        s-&gt;data = a[i];		<span class="comment">//建立数据结点*s</span></span><br><span class="line">        s-&gt;next = L-&gt;next;	<span class="comment">//将*s插在原开始结点之前，头结点之后</span></span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）尾插法建表</p>
<ul>
<li>从一个空表开始，创建一个头结点</li>
<li>依次读取字符数组a中的元素，生成新结点</li>
<li>将新结点插入到当前链表的表尾上，直到结束</li>
<li>链表的结点顺序与逻辑次序<strong>相同</strong></li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220331143016713.png" alt="image-20220331143016713"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateListR</span><span class="params">(LinkNode *&amp;L, ElemType a[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkNode *s, *r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));	<span class="comment">//创建头结点</span></span><br><span class="line">    r = L;	<span class="comment">//r始终指向尾结点，开始时指向头结点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//循环建立数据结点</span></span><br><span class="line">    &#123;</span><br><span class="line">		s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">         s-&gt;data = a[i]; 	<span class="comment">//创建数据结点 *s</span></span><br><span class="line">         r-&gt;next = s;	<span class="comment">//将*s 插入 *r之后</span></span><br><span class="line">         r = s;		<span class="comment">//s就是新的r，r的指针右移了</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;		<span class="comment">//尾结点next域置为NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="③、线性表基本运算在单链表上的实现"><a href="#③、线性表基本运算在单链表上的实现" class="headerlink" title="③、线性表基本运算在单链表上的实现"></a>③、线性表基本运算在单链表上的实现</h4><p>（1）初始化线性表 InitList(L)</p>
<p>该运算建立一个空的单链表，即创建一个头结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkNode *&amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">	L = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));	<span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）销毁线性表 DestroyList(L)</p>
<p>释放单链表L占用的空间。即逐一释放全部结点的空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(LinkNode *&amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkNode *pre = L, *p = L-&gt;next;	<span class="comment">//pre指向*p的前驱结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)	<span class="comment">//扫描单链表L</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pre);	<span class="comment">//释放*pre结点</span></span><br><span class="line">        pre = p;	<span class="comment">//pre、p同步后移一个结点</span></span><br><span class="line">        p = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pre);	<span class="comment">//循环结束时，p为NULL，pre指向尾结点，释放它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）判断线性表是否为空表 ListEmpty(L)</p>
<p>若单链表L 没有数据结点，则返回真，否则返回假。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListEmpty</span><span class="params">(LinkNode *L)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(L-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（4）求线性表的长度 ListLength(L)</p>
<p>返回单链表L中数据结点的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListLenth</span><span class="params">(LinkNode *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    LinkNode *p = L;	<span class="comment">//p指向头结点，n置为0（头结点的序号为0）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(n);	<span class="comment">//循环结束，p指向尾结点，其序号n为结点个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）输出线性表 DispList(L)</p>
<p>逐一扫描单链表L 的每个数据结点，并显示各结点的 data域值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DispList</span><span class="params">(LinkNode *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkNode *p = L-&gt;next; 	<span class="comment">//p指向开始结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)	<span class="comment">//p不为NULL，输出 *p 结点的 data域</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;	<span class="comment">//p移向下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    pirintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（6）求线性表L中位置 i 的数据元素 GetElme(L, i, &amp;e)</p>
<p>思路： 在单链表L中从头开始找到第 i 个结点，若存在第 i 个数据结点，则将其 data 域值赋给变量 e。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(LinkNode *L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LinkNode *p = L;	<span class="comment">//p指向头结点，j置为0（即头结点的序号为0）</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; i &amp;&amp; p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;	<span class="comment">//找出第i个结点*p</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//不存在第i个数据结点，返回false</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        e = p-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//存在第 i个数据结点，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（7）按元素值查找 LocateElem(L, e)</p>
<p>思路：在单链表L中从头开始找第1个值域与e相等的结点，若存在这样的结点，则返回位置，否则返回0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(LinkNode *L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    LinkNode *p = L-&gt;next;	<span class="comment">//p指向开始结点，i置为1</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;	<span class="comment">//查找data值为e的结点，其序号为i</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">0</span>);		<span class="comment">//不存在元素值为e的结点，返回0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(i);	<span class="comment">//存在元素值为e的结点，返回其逻辑序号i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法的时间复杂度为O(n)，不具有随机存取特性</span></span><br></pre></td></tr></table></figure>

<p>（8）插入数据元素 ListInsert(&amp;L, i, e)</p>
<p>思路：先在单链表L中找到第 i-1 个结点 *p,若存在这样的结点，将值为e的结点 *s 插入到其后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkNode *&amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LinkNode *P = L, *s;	<span class="comment">//p指向头结点，j置为0</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;	<span class="comment">//查找第 i-1个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)	<span class="comment">//未找到第 i-1 个结点，返回false</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到第 i-1个结点 *p,插入新结点并返回true</span></span><br><span class="line">        s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">        s-&gt;data = e;	<span class="comment">//创建新结点 *s, 其 data 域置为 e </span></span><br><span class="line">        s-&gt;next = p-&gt;next;	<span class="comment">//将 *s 插入到 *p 之后</span></span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（9）删除数据元素 ListDelete(&amp;L, i, &amp;e)</p>
<p>思路：先在单链表 L中找到第 i-1 个结点 *p,若存在这样的结点，且也存在后继结点，则删除该后继结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkNode *&amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LinkNode *p = L, *q;	<span class="comment">//p指向头结点，j置为0</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>)	<span class="comment">//查找第 i-1 个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)	<span class="comment">//未找到第 i-1 个结点，返回false</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到第 i-1 个结点*p</span></span><br><span class="line">        q = p-&gt;next;	<span class="comment">//q指向第i 个结点</span></span><br><span class="line">        <span class="keyword">if</span>(q == <span class="literal">NULL</span>)	<span class="comment">//若不存在第 i 个结点，返回false</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e = q-&gt;data;</span><br><span class="line">        p-&gt;next = q-&gt;next;	<span class="comment">//从单链表中删除 *q结点</span></span><br><span class="line">        <span class="built_in">free</span>(q);	<span class="comment">//释放*q结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//返回true表示成功删除第 i 个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="④、单链表的算法设计方法"><a href="#④、单链表的算法设计方法" class="headerlink" title="④、单链表的算法设计方法"></a>④、<strong>单链表的算法设计方法</strong></h4><p>Ⅰ、以查找为基础的算法设计</p>
<ul>
<li>按照条件进行结点查找</li>
<li>进行插入或者删除操作</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309202839799.png" alt="image-20220309202839799"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delmaxnode</span><span class="params">(LinkNode *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkNode *p = L-&gt;next, *pre = L, *maxp = p, *maxpre = pre;</span><br><span class="line">    <span class="comment">//查找最大值结点的前驱结点*maxpre</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxp-&gt;data &lt; p-&gt;data)	<span class="comment">//若找到一个更大的结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            maxp = p;	<span class="comment">//更改maxp</span></span><br><span class="line">            maxpre = pre;	<span class="comment">//更改maxpre</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;		<span class="comment">//p,pre同步后移一个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    maxpre-&gt;next = maxp-&gt;next;	<span class="comment">//删除*maxp结点</span></span><br><span class="line">    <span class="built_in">free</span>(maxp);	<span class="comment">//释放*maxp结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309202856189.png" alt="image-20220309202856189"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(LinkNode *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkNode *p, *pre, *q;</span><br><span class="line">    p = L-&gt;next-&gt;next;	<span class="comment">//p指向L的第2个数据结点</span></span><br><span class="line">    L-&gt;next-&gt;next = <span class="literal">NULL</span>;	<span class="comment">//构造只含一个数据结点的有序表</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;	<span class="comment">//q保持*p结点后继结点的指针</span></span><br><span class="line">        pre = L;	<span class="comment">//从有序表开头进行比较，pre指向插入*p的前驱结点</span></span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next != <span class="literal">NULL</span> &amp;&amp; pre-&gt;next-&gt;data &lt; p-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;	<span class="comment">//在有序表中找插入*p的前驱结点*pre</span></span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-next = p;</span><br><span class="line">        p = q;	<span class="comment">//扫描原单链表余下的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ⅱ、以建表算法为基础的算法设计</p>
<ul>
<li>单链表有尾插法和头插法两种建表算法</li>
</ul>
<h3 id="3、双链表"><a href="#3、双链表" class="headerlink" title="3、双链表"></a>3、双链表</h3><p>在线性表的链式存储结构中，每个物理结点增加一个指向后继结点的指针域和一个指向前驱结点的指针域。</p>
<p>优点：</p>
<ul>
<li>从任一结点出发可以快速找到其前驱结点和后继结点</li>
<li>从任一结点出发可以访问其他结点</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203010006.png" alt="image-20220309203010006"></p>
<p>类型定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>	<span class="comment">//双链表结点类型</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior;	<span class="comment">//指向前驱结点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *next;		<span class="comment">//指向后继结点</span></span><br><span class="line">&#125;DLinkNode;</span><br><span class="line"><span class="comment">//数据 前驱结点 后继结点</span></span><br></pre></td></tr></table></figure>

<h4 id="①、双链表中结点的插入和删除"><a href="#①、双链表中结点的插入和删除" class="headerlink" title="①、双链表中结点的插入和删除"></a>①、双链表中结点的插入和删除</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203055324.png" alt="image-20220309203055324"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203129973.png" alt="image-20220309203129973"></p>
<h4 id="②、建立双链表"><a href="#②、建立双链表" class="headerlink" title="②、建立双链表"></a>②、建立双链表</h4><p>整体建立双链表也有两种方法：头插法和尾插法。</p>
<p>与单链表的建表算法相似主要是插入和删除的不同。</p>
<p><strong>头插法</strong>建立双链表：由含有n个元素的数组a创建带头结点的双链表L。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListF</span><span class="params">(DLinkNode *&amp;L, ElemType a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLinkNode *s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L = (DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));	<span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;prior = L-&gt;next = <span class="literal">NULL</span>;	<span class="comment">//前后指针域置为NULL</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//循环建立数据结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        s =(DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">        s-&gt;data= a[i];	<span class="comment">//创建结点*s</span></span><br><span class="line">        s-&gt;next = L-&gt;next;	<span class="comment">//将*s 插入到头结点之后</span></span><br><span class="line">        <span class="keyword">if</span>(L-&gt;next != <span class="literal">NULL</span>)		<span class="comment">//若L存在数据结点，修改前驱指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;next-&gt;prior = s;</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        s-&gt;prior = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尾插法</strong>建立双链表：由含有n个元素的数组a创建带头结点的双链表L。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListR</span><span class="params">(DLinkNode *&amp;L, ElemType a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLinkNode *s, *r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L = (DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));	<span class="comment">//创建头结点</span></span><br><span class="line">    r = L;	<span class="comment">//r始终指向尾结点，开始时指向头结点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)	<span class="comment">//循环建立数据结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">        s-&gt;data = a[i];	<span class="comment">//	创建数据结点*s</span></span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        s-&gt;prior = r;	<span class="comment">//将*s 插入 *r之后</span></span><br><span class="line">        r = s;	<span class="comment">//r指向尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-next = <span class="literal">NULL</span>;	<span class="comment">//尾结点next域置为NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="③、线性表基本运算在双链表中的实现"><a href="#③、线性表基本运算在双链表中的实现" class="headerlink" title="③、线性表基本运算在双链表中的实现"></a>③、线性表基本运算在双链表中的实现</h4><p>和单链表相比，双链表主要是<strong>插入和删除</strong>运算不同</p>
<p><strong>插入算法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(DLinkNode *&amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    DLinkNode *p = L, *s;	<span class="comment">//p指向头结点，j置为0</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>)	<span class="comment">//查找第 i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)	<span class="comment">//未找到第 i-1 个结点，返回false</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;		<span class="comment">//找到第 i-1 个结点，在其后插入新结点 *s</span></span><br><span class="line">        s = (DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">        s-&gt;data = e;	<span class="comment">//创建新结点 *s</span></span><br><span class="line">        s-&gt;next = p-&gt;next;	<span class="comment">//在*p结点之后插入 *s结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)	<span class="comment">//并存在后继结点，修改其前驱指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next-&gt;prior = s;</span><br><span class="line">        &#125;</span><br><span class="line">        s-prior = p;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除算法</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(DLinkNode *&amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    DLinkNode *p = L, *q;	<span class="comment">//p指向头结点，j设置为0</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; i - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>)	<span class="comment">//查找第 i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)	<span class="comment">//未找到第 i-1 个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;		<span class="comment">//找到第 i-1 个结点</span></span><br><span class="line">        q = p-&gt;next;	<span class="comment">//q指向第 i个结点</span></span><br><span class="line">        <span class="keyword">if</span>(q == <span class="literal">NULL</span>)	<span class="comment">//当不存在第 i个结点时返回false</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e = q-&gt;data;</span><br><span class="line">        p-&gt;next = q-&gt;next;	<span class="comment">//删除*q结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)		<span class="comment">//修改前驱指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next-&gt;prior = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(q);		<span class="comment">//释放*q结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<p>有一个带头结点的双链表L，设计一个算法将其所有元素逆置，即第一个元素变为最后一个元素，。。。最后一个变为第一个。</p>
<p>采用头插法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(DLinkNode *&amp;L)</span>	<span class="comment">//双链表结点逆置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLinkNOde *p = L-&gt;next, *q;	<span class="comment">//p指向头结点后的第一个结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;	<span class="comment">//构造只有头结点的双链表</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)	<span class="comment">//扫描L的数据结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;	<span class="comment">//用q保存其后继结点</span></span><br><span class="line">        p-&gt;next = L-&gt;next;		<span class="comment">//采用头插法将 *p 结点插入</span></span><br><span class="line">        <span class="keyword">if</span>(L-&gt;next != <span class="literal">NULL</span>)		<span class="comment">//修改其前驱指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            L-next-&gt;piror = p;</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;next = p;	<span class="comment">//将新结点作为首结点</span></span><br><span class="line">        p-&gt;prior = L;</span><br><span class="line">        p = q;		<span class="comment">//让p 重新指向其后继指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、循环链表"><a href="#4、循环链表" class="headerlink" title="4、循环链表"></a>4、循环链表</h3><p><strong>循环单链表：</strong>将表中尾结点的指针域改为指向表头结点，整个链表形成一个环。</p>
<p><strong>循环双链表：</strong>形成两个环</p>
<p>结点的类型都相同</p>
<h4 id="①循环单链表"><a href="#①循环单链表" class="headerlink" title="①循环单链表"></a>①循环单链表</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220402150932798.png" alt="image-20220402150932798"></p>
<p>与非循环单链表相比，循环单链表：</p>
<ul>
<li>链表中没有空指针域</li>
<li>p所指结点为尾结点的条件：<code>p-&gt;next == L</code></li>
</ul>
<h4 id="②、循环双链表"><a href="#②、循环双链表" class="headerlink" title="②、循环双链表"></a>②、循环双链表</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220402151316623.png" alt="image-20220402151316623"></p>
<p>与非循环双链表相比，循环双链表：</p>
<ul>
<li>链表中没有空指针域</li>
<li>p所指结点为尾结点的条件：<code>p-&gt;next == L</code></li>
<li>一步操作即<code>L-&gt;prior</code>可以找到尾结点</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203414139.png" alt="image-20220309203414139"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203420408.png" alt="image-20220309203420408"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Equal</span><span class="params">(DLinkNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> same = <span class="number">1</span>;</span><br><span class="line">    DLinkNode *p = L-&gt;next;	<span class="comment">//p指向第一个数据结点</span></span><br><span class="line">    DLinkNode *q = L-&gt;prior;	<span class="comment">//q指向最后数据结点</span></span><br><span class="line">    <span class="keyword">while</span>(same == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data != q-data)</span><br><span class="line">        &#123;</span><br><span class="line">            same = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="number">1</span> || p == q-&gt;prior)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                q = q-&gt;prior;	<span class="comment">//q迁移</span></span><br><span class="line">                p = p-&gt;next;	<span class="comment">//p后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> same;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、应用"><a href="#2-4、应用" class="headerlink" title="2.4、应用"></a>2.4、应用</h2><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203449108.png" alt="image-20220309203449108"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203457379.png" alt="image-20220309203457379"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203503918.png" alt="image-20220309203503918"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203510588.png" alt="image-20220309203510588"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203517057.png" alt="image-20220309203517057"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/../../../Blogs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220309203524847.png" alt="image-20220309203524847"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203533625-16468293383074.png" alt="image-20220309203533625"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203548685.png" alt="image-20220309203548685"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203555052.png" alt="image-20220309203555052"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/../../../Blogs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220309203602245.png" alt="image-20220309203602245"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203609324.png" alt="image-20220309203609324"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203616972.png" alt="image-20220309203616972"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203623781.png" alt="image-20220309203623781"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203630741.png" alt="image-20220309203630741"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203639092.png" alt="image-20220309203639092"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203646217.png" alt="image-20220309203646217"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203657516.png" alt="image-20220309203657516"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203705818.png" alt="image-20220309203705818"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309203712953.png" alt="image-20220309203712953"></p>
<h1 id="三、栈和队列"><a href="#三、栈和队列" class="headerlink" title="三、栈和队列"></a>三、栈和队列</h1><h3 id="3-1、栈"><a href="#3-1、栈" class="headerlink" title="3.1、栈"></a><strong>3.1、栈</strong></h3><p>栈和队列的逻辑结构相同，都是线性结构</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps5.jpg" alt="img"> </p>
<p>标识符只能以字母或下划线开头</p>
<h3 id="3-2、队列"><a href="#3-2、队列" class="headerlink" title="3.2、队列"></a><strong>3.2、队列</strong></h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps6.jpg" alt="img"> </p>
<p>链式队列指针是从队首指向队尾的</p>
<p>如果是循环单链表，只需要一个队尾指针就可以了</p>
<h2 id="3-1、栈-1"><a href="#3-1、栈-1" class="headerlink" title="3.1、栈"></a>3.1、栈</h2><p>栈也是一种线性排列，但是只能访问最新的数据。</p>
<ul>
<li>添加数据时，新数据会放在最上面，添加数据称为入栈</li>
<li>取出数据时，这个操作称为出栈</li>
<li>“后进先出”的结构，称为<strong>Last In First Out</strong>，简称<strong>LIFO</strong></li>
</ul>
<h3 id="1、定义-3"><a href="#1、定义-3" class="headerlink" title="1、定义"></a>1、定义</h3><ul>
<li>栈顶：允许进行插入、删除操作的一端</li>
<li>表的另一端成为栈底</li>
<li>空栈：栈中没有数据元素</li>
<li>插入数据：入栈（Push）</li>
<li>删除数据：出栈（Pop）</li>
</ul>
<p>设计基本运算算法</p>
<p>①CreateTable(HList *&amp;L):交互式创建单链表</p>
<p>②DestroyTable(HList *&amp;L):销毁单链表</p>
<p>③DispTable(HList *h):输出单链表</p>
<p>④LinkTable(HList *h1, HList *h2, HList *&amp;h):实现两个单链表的自然选择运算</p>
<img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309204045836.png" alt="image-20220309204045836" style="zoom:150%;">

<h3 id="2、栈的顺序存储结构及其基本运算实现"><a href="#2、栈的顺序存储结构及其基本运算实现" class="headerlink" title="2、栈的顺序存储结构及其基本运算实现"></a>2、栈的顺序存储结构及其基本运算实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309204138724.png"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220309204148492.png" alt="image-20220309204148492"></p>
<p>顺序栈4要素：</p>
<ul>
<li>栈空条件：top&#x3D;-1</li>
<li>栈满条件：top&#x3D;MaxSize-1</li>
<li>进栈e操作：top++；将e放在top 处</li>
<li>退栈操作：从top处取出元素e；top–;</li>
</ul>
<p><strong>基本运算算法</strong></p>
<p>（1）初始化栈 InitStack(&amp;s)</p>
<p>建立一个新的空栈s,实际上是将栈顶指针指向 -1 即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack *&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s = (SqStack *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqStack));</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）销毁栈 DestroyStack(&amp;s)</p>
<p>释放栈s占用的存储空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(SqStack *&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）判断栈是否为空 StackEmpty(s)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈空的条件是 s-&gt;top == -1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(s-&gt;top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）进栈Push(&amp;s, e)</p>
<p>在栈不满的条件下，先将栈指针增1，然后在该位置上插入元素e.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack *&amp;s, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == MaxSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//栈满的情况，即栈上溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top++;	<span class="comment">//栈顶指针增1</span></span><br><span class="line">    s-&gt;data[s-&gt;top] = e;	<span class="comment">//元素e放在栈顶指针处</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）出栈Pop(&amp;s, &amp;e)</p>
<p>在栈不为空的条件下，先将栈顶元素赋给e,然后将栈顶指针减1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack *&amp;s, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//栈为空的情况，即栈下溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    e = s-&gt;data[s-top];	<span class="comment">//取栈顶指针元素的元素</span></span><br><span class="line">    s-&gt;top--;	<span class="comment">//栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（6）取栈顶元素 GetTop(s, &amp;e)</p>
<p>在栈不为空的条件下，将栈顶元素赋给e。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack *s, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//栈为空的情况下，即栈下溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    e = s-&gt;data[s-&gt;top];	<span class="comment">//取栈顶指针元素的元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：判断一个字符串对称</p>
<p>算法设计思路：字符串str 的所有元素依次进栈，产生的出栈序列正好与 str的顺序相反</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">symmetry</span><span class="params">(ElemType str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ElemType e;</span><br><span class="line">    SqStack *st;</span><br><span class="line">    <span class="built_in">InitStack</span>(st);	<span class="comment">//初始化栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++)		<span class="comment">//将串所有元素进栈</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Push</span>(st, str[i]);		<span class="comment">//元素进栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Pop</span>(st, e);		<span class="comment">//退栈元素e</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] != e)		<span class="comment">//若e与当前串元素不同则不是对称串</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DestroyStack</span>(st);	<span class="comment">//销毁栈</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DestroyStack</span>(st);	<span class="comment">//销毁栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316104300445.png" alt="image-20220316104300445"></p>
<h3 id="3、栈的链式存储结构及其基本运算的实现"><a href="#3、栈的链式存储结构及其基本运算的实现" class="headerlink" title="3、栈的链式存储结构及其基本运算的实现"></a>3、栈的链式存储结构及其基本运算的实现</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220403144003173.png" alt="image-20220403144003173"></p>
<p>链栈的4要素：</p>
<ul>
<li>栈空条件：s-&gt;next &#x3D; NULL</li>
<li>栈满条件：不考虑</li>
<li>进栈e操作：将包含e的结点插入到头结点之后</li>
<li>退栈操作：取出头结点之后结点的元素并删除之</li>
</ul>
<p><strong>数据结点的类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">linknode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linknode</span> *next;	<span class="comment">//指针域</span></span><br><span class="line">&#125;LinkStNode;</span><br></pre></td></tr></table></figure>

<p><strong>基本运算算法</strong></p>
<p>（1）初始化栈 initStack(&amp;s)</p>
<p>建立一个空栈s。实际上是创建链栈的头结点，并将其next域置为 NULL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LinkStNode *&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s = (LiStaInitStack *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkStNode));</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）销毁栈 DestroyStack(&amp;s)</p>
<p>释放栈s占用的全部存储空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(LinkStNode *&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkStNode *p = s, *q = s-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);		<span class="comment">//此时p指向尾结点，释放其空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）判断栈是否为空 StackEmpty(s)</p>
<p>栈S为空的条件是 s-&gt;next &#x3D;&#x3D; NULL,即单链表中没有数据结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LinkStNode *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(s-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）进栈 Push(&amp;s, e)</p>
<p>将新数据结点插入到头结点之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(LinkStNode *&amp;s, ElmeType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStNode *p;</span><br><span class="line">    p = (LinkStNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkStNode));</span><br><span class="line">    p-&gt;data = e;	<span class="comment">//新建元素e对应的结点*p</span></span><br><span class="line">    p-&gt;next = s-&gt;next;	<span class="comment">//插入*p结点作为开始结点</span></span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）出栈 Pop(&amp;s, &amp;e)</p>
<p>在栈不为空的条件下，将头结点后继数据结点的数据域赋给e，然后将其删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LinkStNode *&amp;s, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStNode *p;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;next == <span class="literal">NULL</span>)	<span class="comment">//栈空的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = s-&gt;next;	<span class="comment">//p指向开始结点</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    s-&gt;next = p-&gt;next;	<span class="comment">//删除*p结点</span></span><br><span class="line">    <span class="built_in">free</span>(p);	<span class="comment">//释放*p结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）取栈顶元素 GetTop(s, e)</p>
<p>在栈不为空的条件下，将头结点后继数据结点的数据域赋给e。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(LinkStNode *s, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;next == <span class="literal">NULL</span>)	<span class="comment">//栈空的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = s-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子：编写一个算法判断输入的表达式中括号是否配对（假设只含有左、右圆括号）</strong></p>
<p>算法设计思路：</p>
<p>一个表达式中的左右括号是按<strong>最近位置配对</strong>的。所以利用一个栈来进行求解。这里采用链栈。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327152317009.png" alt="image-20220327152317009"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327152356188.png" alt="image-20220327152356188"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">char</span> exp[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> e;</span><br><span class="line">    <span class="type">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    LinkStNode *st;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">InitStack</span>(st);		<span class="comment">//初始化栈</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; match)	<span class="comment">//扫描exp中所有字符。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(exp[i] = <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">Push</span>(st, exp[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exp[i] == <span class="string">&#x27;)&#x27;</span>)	<span class="comment">//当前括号为右括号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">GetTop</span>(st, e) == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(e != <span class="string">&#x27;(&#x27;</span>)	<span class="comment">//当栈顶元素不为左括号时，表示不匹配</span></span><br><span class="line">                &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">Pop</span>(st, e);		<span class="comment">//将栈顶元素出栈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                match = <span class="literal">false</span>;		<span class="comment">//无法取栈顶元素时表示不匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;		<span class="comment">//继续处理其他字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">StackEmpty</span>(st))		<span class="comment">//栈不空时表示不匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            match = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">DestroyStack</span>(st);</span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、应用"><a href="#4、应用" class="headerlink" title="4、应用"></a>4、应用</h3><h5 id="简单表达式求值"><a href="#简单表达式求值" class="headerlink" title="简单表达式求值"></a>简单表达式求值</h5><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327153249582.png" alt="image-20220327153249582"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327153339878.png" alt="image-20220327153339878"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316111013699.png" alt="image-20220316111013699"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316111213152.png" alt="image-20220316111213152"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316111353122.png" alt="image-20220316111353122"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327153755871.png" alt="image-20220327153755871"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327153853518.png" alt="image-20220327153853518"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316111520306.png" alt="image-20220316111520306"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154149019.png" alt="image-20220327154149019"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154317159.png" alt="image-20220327154317159"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154615934.png" alt="image-20220327154615934"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154701766.png" alt="image-20220327154701766"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154713370.png" alt="image-20220327154713370"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154817603.png" alt="image-20220327154817603"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327154931802.png" alt="image-20220327154931802"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155028385.png" alt="image-20220327155028385"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155136786.png" alt="image-20220327155136786"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155226310.png" alt="image-20220327155226310"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155255984.png" alt="image-20220327155255984"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155358833.png" alt="image-20220327155358833"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155546656.png" alt="image-20220327155546656"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155600385.png" alt="image-20220327155600385"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114140768.png" alt="image-20220316114140768"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114214687.png" alt="image-20220316114214687"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114237997.png" alt="image-20220316114237997"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114309300.png" alt="image-20220316114309300"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155913383.png" alt="image-20220327155913383"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327155927065.png" alt="image-20220327155927065"></p>
<h3 id="5、链栈"><a href="#5、链栈" class="headerlink" title="5、链栈"></a>5、链栈</h3><p>存储类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">	ElemType data;			<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>	 <span class="comment">//指针域</span></span><br><span class="line">&#125;*LiStack;					<span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>

<p> 初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LiStack <span class="title function_">Init_LiStack</span><span class="params">()</span>&#123;</span><br><span class="line">    LiStack top = (Linknode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linknode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (top != null)&#123;</span><br><span class="line">        top-&gt;next = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断栈是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">LiStack_Empty</span><span class="params">(L)</span></span><br></pre></td></tr></table></figure>





<h2 id="3-2、队列-1"><a href="#3-2、队列-1" class="headerlink" title="3.2、队列"></a>3.2、队列</h2><p>队列也是线性结构，但是添加和删除都是在两端进行。</p>
<ul>
<li>“先进先出”的结构，称为<strong>First In First Out</strong>,简称<strong>FIFO</strong></li>
</ul>
<h3 id="1、定义-4"><a href="#1、定义-4" class="headerlink" title="1、定义"></a>1、定义</h3><p>只能选取一个端点进行插入操作，另一个端点进行删除操作。</p>
<p><strong>队尾</strong>（rear）：进行插入的一端</p>
<p><strong>队首</strong>或<strong>队头</strong>（front）：进行删除的一端</p>
<p><strong>进队</strong>或<strong>入队</strong>：向队列中插入新元素</p>
<p><strong>出队</strong>或<strong>离队</strong>：从队列中删除元素</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220316114904281.png" alt="image-20220316114904281"></p>
<h3 id="2、顺序队及实现"><a href="#2、顺序队及实现" class="headerlink" title="2、顺序队及实现"></a>2、顺序队及实现</h3><p>顺序队类型SqQueue 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front,rear;		<span class="comment">//队首和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="comment">//因为队列两端都在变化，所以需要两个指针来标识队列的状态。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220321152336259.png" alt="image-20220321152336259"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220403154358925.png" alt="image-20220403154358925"></p>
<p>总结：</p>
<ul>
<li>约定rear总是指向队尾元素</li>
<li>元素进队，rear增1</li>
<li>约定front指向当前队中队头元素的前一位置</li>
<li>当rear&#x3D;MaxSize-1时不能再进队</li>
</ul>
<p>顺序队的4要素（初始时front&#x3D;rear&#x3D;-1）</p>
<ul>
<li>队空条件：front &#x3D; rear</li>
<li>队满条件：rear &#x3D; MaxSize - 1</li>
<li>元素e进队：rear++; data[rear]&#x3D;e;</li>
<li>元素e出队：front++;  e&#x3D;data[front];</li>
</ul>
<p><strong>基本运算实现</strong></p>
<p>（1）初始化队列 InitQueue(q)</p>
<p>构造一个空队列q。将front和rear指针均设置成初始状态即-1值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue *&amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q = (SqQueue *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqQueue));</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）销毁队列 DestroyQueue(q)</p>
<p>释放队列q占用的存储空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue *&amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）判断队列是否为空 QueueEmpty(q)</p>
<p>若队列q满足q-&gt;front &#x3D;&#x3D; q-&gt;rear条件，则返回true;否则返回false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(q-&gt;front == q-&gt;rear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）进队列enQueue(q,e)</p>
<p>在队列不满的条件下，先将队尾指针rear循环增1，然后将元素添加到该位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue *&amp;q, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear == MaxSize<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队列上溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear++;</span><br><span class="line">    q-&gt;data[q-rear] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）出队列deQueue(q,e)</p>
<p>在队列q不为空的条件下，将队首指针front循环增1，开始将该位置的元素值赋给e。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue *&amp;q,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队列下溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;front++;</span><br><span class="line">    e = q-&gt;data[q-&gt;front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、环形队列"><a href="#3、环形队列" class="headerlink" title="3、环形队列"></a>3、环形队列</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220403160454429.png" alt="image-20220403160454429"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170203169.png" alt="image-20220327170203169"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170235754.png" alt="image-20220327170235754"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170258322.png" alt="image-20220327170258322"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170542192.png" alt="image-20220327170542192"></p>
<p>环形队列的四要素：</p>
<ul>
<li>队空条件：front &#x3D; rear</li>
<li>队满条件：(rear + 1) % MaxSize &#x3D; front</li>
<li>进队e操作：rear &#x3D; (rear + 1) % MaxSize;将e放在rear处</li>
<li>出队操作：front &#x3D; (front + 1) % MaxSize; 取出front处元素e</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170608731.png" alt="image-20220327170608731"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170719251.png" alt="image-20220327170719251"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327170954589.png" alt="image-20220327170954589"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171056495.png" alt="image-20220327171056495"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171334573.png" alt="image-20220327171334573"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171410926.png" alt="image-20220327171410926"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171635426.png" alt="image-20220327171635426"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171743169.png" alt="image-20220327171743169"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171751450.png" alt="image-20220327171751450"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327171807278.png" alt="image-20220327171807278"></p>
<h3 id="4、链队"><a href="#4、链队" class="headerlink" title="4、链队"></a>4、链队</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327172701573.png" alt="image-20220327172701573"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327172743231.png" alt="image-20220327172743231"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327172756188.png" alt="image-20220327172756188"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327173543865.png" alt="image-20220327173543865"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327173927558.png" alt="image-20220327173927558"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327173940590.png" alt="image-20220327173940590"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174000521.png" alt="image-20220327174000521"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174206566.png" alt="image-20220327174206566"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174239629.png" alt="image-20220327174239629"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174357071.png" alt="image-20220327174357071"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174406061.png" alt="image-20220327174406061"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174417550.png" alt="image-20220327174417550"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174429047.png" alt="image-20220327174429047"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174439669.png" alt="image-20220327174439669"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174502319.png" alt="image-20220327174502319"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220327174534416.png" alt="image-20220327174534416"> </p>
<h1 id="六、数组和广义表"><a href="#六、数组和广义表" class="headerlink" title="六、数组和广义表"></a>六、数组和广义表</h1><h2 id="6-1、数组"><a href="#6-1、数组" class="headerlink" title="6.1、数组"></a>6.1、数组</h2><p>数组也是数据呈线性排列的一种数据结构。在数组中，<strong>访问数据十分简单</strong>，而添加和删除数据比较耗费功夫。</p>
<ul>
<li>数据是存储在连续的空间中，所以数据的内存地址可以根据数组下标直接访问</li>
<li>添加时，需要先确保增加的内存空间，再将数据一个个往后移</li>
<li>删除时，需要先删除数据，再一个一个往前移，最后删除多余的空间</li>
</ul>
<h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p>从<strong>逻辑结构</strong>上看，一维数组A是n（n&gt;1)个相同类型数据元素a<sub>1</sub>、a<sub>2</sub>、…、a<sub>n</sub>构成的优先序列，其逻辑表示为：$A&#x3D;(a_1,a_2,…,a_n)$其中，a<sub>i</sub>（1&leq;i&leq;n)表示数组A的第i个元素。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404152845227.png"> </p>
<p>数组抽象数据类型＝逻辑结构＋基本运算（运算描述）</p>
<p>数组的基本运算：</p>
<ul>
<li><code>Value(A,index1,index2,…,indexd)</code>：即A(index1,index2,…,indexd)&#x3D;e，元素赋值。</li>
<li><code>Assign(A,e,index1,index2,…,indexd)</code>：即e&#x3D; A(index1,index2,…,indexd)，取元素值。</li>
<li><code>ADisp(A,b1,b2,…,bd)</code>：输出d维数组A的所有元素值。</li>
</ul>
<h3 id="2、数组的存储结构"><a href="#2、数组的存储结构" class="headerlink" title="2、数组的存储结构"></a>2、数组的存储结构</h3><p>　将数组的所有元素存储在一块地址连续的内存单元中，这是一种顺序存储结构。　</p>
<p>几乎所有的计算机语言都支持数组类型，以C&#x2F;C++语言为例，其中数组数据类型具有以下性质：</p>
<ul>
<li>数组中的数据元素数目固定。</li>
<li>数组中的所有数据元素具有相同的数据类型。</li>
<li>数组中的每个数据元素都有一组唯一的下标。</li>
<li>数组是一种随机存储结构。可随机存取数组中的任意数据元素。</li>
</ul>
<p> 一维数组：一旦a1的存储地址LOC(a1)确定，并假设每个数据元素占用k个存储单元，则任一数据元素ai的存储地址LOC(ai)就可由以下公式求出：</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090447281.png" alt="image-20220430090447281"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090557224.png" alt="image-20220430090557224"></p>
<h4 id="①、以行序为主序的存储"><a href="#①、以行序为主序的存储" class="headerlink" title="①、以行序为主序的存储"></a>①、以行序为主序的存储</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090706818.png" alt="image-20220430090706818"> </p>
<p> <img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090805422.png" alt="image-20220430090805422"></p>
<h4 id="②、以列序为主序的存储"><a href="#②、以列序为主序的存储" class="headerlink" title="②、以列序为主序的存储"></a>②、以列序为主序的存储</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430090855626.png" alt="image-20220430090855626"> </p>
<h3 id="3、特殊矩阵的压缩存储"><a href="#3、特殊矩阵的压缩存储" class="headerlink" title="3、特殊矩阵的压缩存储"></a>3、特殊矩阵的压缩存储</h3><p>特殊矩阵的主要形式有：<br>（1）对称矩阵<br>（2）上三角矩阵／下三角矩阵<br>（3）对角矩阵<br>它们都是方阵，即行数和列数相同。</p>
<h4 id="①、对称矩阵的压缩存储"><a href="#①、对称矩阵的压缩存储" class="headerlink" title="①、对称矩阵的压缩存储"></a>①、对称矩阵的压缩存储</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430091243914.png" alt="image-20220430091243914"> </p>
<p> <img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430091605053.png" alt="image-20220430091605053">  </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430092121426.png" alt="image-20220430092121426"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404173500963.png" alt="image-20220404173500963"></p>
<h4 id="②、三角矩阵的压缩存储"><a href="#②、三角矩阵的压缩存储" class="headerlink" title="②、三角矩阵的压缩存储"></a>②、三角矩阵的压缩存储</h4><p>上三角矩阵</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430092329950.png" alt="image-20220430092329950"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430092348976.png" alt="image-20220430092348976"> </p>
<p>下三角矩阵</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430092437872.png" alt="image-20220430092437872"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404174422580.png" alt="image-20220404174422580"></p>
<h4 id="③、对角矩阵的压缩存储"><a href="#③、对角矩阵的压缩存储" class="headerlink" title="③、对角矩阵的压缩存储"></a>③、对角矩阵的压缩存储</h4><p> <img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430093123892.png" alt="image-20220430093123892"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430093140292.png" alt="image-20220430093140292"> </p>
<h2 id="6-2、稀疏矩阵"><a href="#6-2、稀疏矩阵" class="headerlink" title="6.2、稀疏矩阵"></a>6.2、稀疏矩阵</h2><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175020977.png" alt="image-20220404175020977"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175159469.png" alt="image-20220404175159469"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175315291.png" alt="image-20220404175315291"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175625621.png" alt="image-20220404175625621"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175741363.png" alt="image-20220404175741363"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175837135.png" alt="image-20220404175837135"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404175856214.png" alt="image-20220404175856214"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404180004795.png" alt="image-20220404180004795"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404180027557.png" alt="image-20220404180027557"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404180227105.png" alt="image-20220404180227105"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194743210.png" alt="image-20220404194743210"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194751615.png" alt="image-20220404194751615"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194819897.png" alt="image-20220404194819897"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194832691.png" alt="image-20220404194832691"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220404194845128.png" alt="image-20220404194845128"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406190524283.png" alt="image-20220406190524283"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191106932.png" alt="image-20220406191106932"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191430680.png" alt="image-20220406191430680"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191751823.png" alt="image-20220406191751823"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191854055.png" alt="image-20220406191854055"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406191913744.png" alt="image-20220406191913744"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192017584.png" alt="image-20220406192017584"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192138400.png" alt="image-20220406192138400"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192153848.png" alt="image-20220406192153848"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192517644.png" alt="image-20220406192517644"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220406192621446.png" alt="image-20220406192621446"> </p>
<h2 id="6-3、广义表"><a href="#6-3、广义表" class="headerlink" title="6.3、广义表"></a>6.3、广义表</h2><h3 id="1、定义-5"><a href="#1、定义-5" class="headerlink" title="1、定义"></a>1、定义</h3><p> 广义表是线性表的推广，是有限个元素的序列，其逻辑结构采用括号表示法表示如下：</p>
<p>GL&#x3D;（a<sub>1</sub>，a<sub>2</sub>，…，a<sub>i</sub>，…，a<sub>n</sub>）</p>
<ul>
<li>若n&#x3D;0时称为空表</li>
<li>ai为广义表的第i个元素。如果ai属于原子类型，称之为广义表GL的原子</li>
<li>如果ai又是一个广义表，称之为广义表GL的子表</li>
</ul>
<p>广义表重要概念：</p>
<ul>
<li>广义表的长度定义为最外层包含元素个数。</li>
<li>广义表的深度定义为所含括弧的重数。其中，原子的深度为0，空表的深度为1 。</li>
<li>广义表GL的表头为第一个元素a1，其余部分(a2，…，an)为GL的表尾。一个广义表的表尾始终是一个广义表。空表无表头表尾。</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102236456.png" alt="image-20220430102236456"> </p>
<p> 操作——取表头、取表尾 </p>
<p>F&#x3D;(b,(c,d,e))</p>
<p>GetHead(F)&#x3D;b<br>GetTail(F)&#x3D;((c,d,e))&#x3D;F1<br>GetHead(F1)&#x3D;(c,d,e)&#x3D;F2，GetTail(F1)&#x3D;( )<br>GetHead(F2)&#x3D;c，GetTail(F2)&#x3D;(d,e)&#x3D;F3<br>GetHead(F3)&#x3D;d，GetTail(F3)&#x3D;(e)&#x3D;F4<br>GetHead(F4)&#x3D;e，GetTail(F4)&#x3D;( )</p>
<ul>
<li>两个操作只对非空表有意义；</li>
<li>取表头的结果可能是原子，也可能是个广义表；</li>
<li>取表尾”必定”是个广义表，但可能是个空的广义表。</li>
</ul>
<h3 id="2、存储结构-1"><a href="#2、存储结构-1" class="headerlink" title="2、存储结构"></a>2、存储结构</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102622939.png" alt="image-20220430102622939"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102633779.png" alt="image-20220430102633779"> </p>
<p> 广义表的结点类型GLNode</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">lnode</span></span><br><span class="line">&#123;      <span class="type">int</span> tag;			<span class="comment">//结点类型标识</span></span><br><span class="line">        <span class="keyword">union</span> </span><br><span class="line">        &#123;	ElemType data;		<span class="comment">//存放原子值</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lnode</span> *sublist;	<span class="comment">//指向子表的指针</span></span><br><span class="line">        &#125; val;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">lnode</span> *link;		<span class="comment">//指向下一个元素</span></span><br><span class="line">&#125;  GLNode;			<span class="comment">//广义表的结点类型</span></span><br></pre></td></tr></table></figure>

<p> <img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102844707.png" alt="image-20220430102844707"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430102958350.png" alt="image-20220430102958350"> </p>
<p>存储结构中的几种情况：<br>（1）除空表的表头指针为空外，对于任何非空列表，其表头指针均指向一个表结点，且该结点中的hp域指示列表表头（原子结点或表结点），tp域指向表尾（非空即表结点）<br>（2）容易分清列表中原子和子表所在的层次。<br>（3）最高层的表结点的个数即为列表的长度。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430103044415.png" alt="image-20220430103044415"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430103125103.png" alt="image-20220430103125103"> </p>
<h3 id="3、广义表的运算"><a href="#3、广义表的运算" class="headerlink" title="3、广义表的运算"></a>3、广义表的运算</h3><h4 id="①、广义表算法设计方法"><a href="#①、广义表算法设计方法" class="headerlink" title="①、广义表算法设计方法"></a>①、广义表算法设计方法</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430103218439.png" alt="image-20220430103218439"> </p>
<p>子表的处理和整个广义表的处理是相似的。从这个角度出发设计求解广义表递归算法的一般格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(GLNode *g)</span>			<span class="comment">//g为广义表头结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;       GLNode *g1=g-&gt;val.sublist;		<span class="comment">//g1指向第一个元素</span></span><br><span class="line">         <span class="keyword">while</span> (g1!=<span class="literal">NULL</span>)			<span class="comment">//元素未处理完循环</span></span><br><span class="line">         &#123;      <span class="keyword">if</span> (g1-&gt;tag==<span class="number">1</span>)			<span class="comment">//为子表时</span></span><br><span class="line"> 	          <span class="built_in">fun1</span>(g1);			<span class="comment">//递归处理子表</span></span><br><span class="line">	   <span class="keyword">else</span>				<span class="comment">//为原子时</span></span><br><span class="line">	           原子处理语句;		<span class="comment">//实现原子操作</span></span><br><span class="line">    	    gl=g1-&gt;link;			<span class="comment">//处理兄弟</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  <img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430103509094.png" alt="image-20220430103509094"> </p>
<p>兄弟的处理与整个广义表的处理是相似的；对于子表结点，其元素的处理与整个广义表的处理是相似的。从这个角度出发设计求解广义表递归算法的一般格式如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(GLNode *g)</span>			<span class="comment">//g为广义表结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="keyword">if</span> (g!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;	<span class="keyword">if</span> (g-&gt;tag==<span class="number">1</span>)			<span class="comment">//为子表时</span></span><br><span class="line">	         <span class="built_in">fun2</span>(g-&gt;val.sublist);	<span class="comment">//递归处理其元素</span></span><br><span class="line">	<span class="keyword">else</span>				<span class="comment">//为原子时 </span></span><br><span class="line">	         原子处理语句;		<span class="comment">//实现原子操作</span></span><br><span class="line"> 	<span class="built_in">fun2</span>(g-&gt;link);			<span class="comment">//递归处理其兄弟</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="②、广义表基本算法设计"><a href="#②、广义表基本算法设计" class="headerlink" title="②、广义表基本算法设计"></a>②、广义表基本算法设计</h4><p>（1）求广义表的长度</p>
<p>​      在广义表中，同一层次的每个结点是通过link域链接起来的，所以可把它看做是由link域链接起来的单链表。这样,求广义表的长度就是求单链表的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GLLength</span><span class="params">(GLNode *g)</span>	<span class="comment">//求广义表g的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> n=<span class="number">0</span>;			<span class="comment">//累计元素个数，初始值为0</span></span><br><span class="line">       GLNode *g1;</span><br><span class="line">       g1=g-&gt;val.sublist;		<span class="comment">//g1指向广义表的第一个元素</span></span><br><span class="line">       <span class="keyword">while</span> (g1!=<span class="literal">NULL</span>)		<span class="comment">//扫描所有元素结点</span></span><br><span class="line">       &#123;	n++;			<span class="comment">//元素个数增1</span></span><br><span class="line">	g1=g1-&gt;link;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n;			<span class="comment">//返回元素个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> （2）求广义表的深度</p>
<p>​    　对于带头结点的广义表g，广义表深度的递归定义是它等于所有子表中表的最大深度加1。若g为原子，其深度为0。<br>​      求广义表深度的递归模型f()如下： </p>
<p>f(g)&#x3D;0 									g为原子<br>f(g)&#x3D;1 									g为空表<br>f(g)&#x3D;MAX{f(subg)}+1		其他情况 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GLDepth</span><span class="params">(GLNode *g)</span>		<span class="comment">//求广义表g的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;     GLNode *g1;  <span class="type">int</span> maxd=<span class="number">0</span>，dep;</span><br><span class="line">       <span class="keyword">if</span> (g-&gt;tag==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">//为原子时返回0</span></span><br><span class="line">       g1=g-&gt;val.sublist;			<span class="comment">//g1指向第一个元素</span></span><br><span class="line">       <span class="keyword">if</span> (g1==<span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">1</span>;		<span class="comment">//为空表时返回1</span></span><br><span class="line">       <span class="keyword">while</span> (g1!=<span class="literal">NULL</span>)			<span class="comment">//遍历表中的每一个元素</span></span><br><span class="line">       &#123;	<span class="keyword">if</span> (g1-&gt;tag==<span class="number">1</span>)			<span class="comment">//元素为子表的情况</span></span><br><span class="line">	&#123;       dep=<span class="built_in">GLDepth</span>(g1);		<span class="comment">//递归调用求出子表的深度</span></span><br><span class="line">	        <span class="keyword">if</span> (dep&gt;maxd)		<span class="comment">//maxd为同层子表深度的最大值</span></span><br><span class="line">		maxd=dep;</span><br><span class="line">	&#125;</span><br><span class="line">	g1=g1-&gt;link;			<span class="comment">//使g1指向下一个元素</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>(maxd<span class="number">+1</span>);			<span class="comment">//返回表的深度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430104205487.png" alt="image-20220430104205487"> </p>
<p>​       解：需要扫描广义表g中的所有结点，可以采用前面介绍的广义表算法设计方法中的两种解法来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用解法1的方法（子表的处理和整个广义表的处理是相似）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Count1</span><span class="params">(GLNode *g)</span>		<span class="comment">//求广义表g的原子个数</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">      GLNode *g1=g-&gt;val.sublist;</span><br><span class="line">       <span class="keyword">while</span> (g1!=<span class="literal">NULL</span>)		<span class="comment">//对每个元素进行循环处理</span></span><br><span class="line">        &#123;	<span class="keyword">if</span> (g1-&gt;tag==<span class="number">0</span>)		<span class="comment">//为原子时</span></span><br><span class="line">	       n++;		<span class="comment">//原子个数增1</span></span><br><span class="line">	<span class="keyword">else</span>			<span class="comment">//为子表时</span></span><br><span class="line">	       n+=<span class="built_in">Count1</span>(g1);	<span class="comment">//累加元素的原子个数</span></span><br><span class="line">	g1=g1-&gt;link;		<span class="comment">//累加兄弟的原子个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;			<span class="comment">//返回总原子个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//采用解法2的方法（兄弟的处理与整个广义表的处理是相似）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Count2</span><span class="params">(GLNode *g)</span>			<span class="comment">//求广义表g的原子个数</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g!=<span class="literal">NULL</span>)			<span class="comment">//对每个元素进行循环处理</span></span><br><span class="line">        &#123;	<span class="keyword">if</span> (g-&gt;tag==<span class="number">0</span>)			<span class="comment">//为原子时</span></span><br><span class="line">	      n++;				<span class="comment">//原子个数增1</span></span><br><span class="line">	<span class="keyword">else</span>				<span class="comment">//为子表时</span></span><br><span class="line">	       n+=<span class="built_in">Count2</span>(g-&gt;val.sublist);	<span class="comment">//累加元素的原子个数</span></span><br><span class="line">	n+=<span class="built_in">Count2</span>(g-&gt;link);		<span class="comment">//累加兄弟的原子个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;				<span class="comment">//返回总原子个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="五、树和二叉树"><a href="#五、树和二叉树" class="headerlink" title="五、树和二叉树"></a>五、树和二叉树</h1><h3 id="5-1、树的基本概念"><a href="#5-1、树的基本概念" class="headerlink" title="5.1、树的基本概念"></a><strong>5.1、树的基本概念</strong></h3><p>树根到每一结点的路径长度的最大值是树的高度减1</p>
<p>树的路径长度是所有结点的路径长度之和</p>
<p>二叉树可以所有结点只有一个子树</p>
<h3 id="5-2、二叉树的概念"><a href="#5-2、二叉树的概念" class="headerlink" title="5.2、二叉树的概念"></a><strong>5.2、二叉树的概念</strong></h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps7.jpg" alt="img"> </p>
<h3 id="5-3、二叉树的遍历和线索二叉树"><a href="#5-3、二叉树的遍历和线索二叉树" class="headerlink" title="5.3、二叉树的遍历和线索二叉树"></a><strong>5.3、二叉树的遍历和线索二叉树</strong></h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps8.jpg" alt="img"> </p>
<p>二叉树是一种逻辑结构。</p>
<p>线索二叉树指明了存储方式，是物理结构</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps9.jpg" alt="img"> </p>
<p>一颗线索二叉树，最多有两个空链域</p>
<p>后序线索二叉树的遍历需要栈的支持</p>
<h3 id="5-4、树、森林"><a href="#5-4、树、森林" class="headerlink" title="5.4、树、森林"></a><strong>5.4、树、森林</strong></h3><p>森林中，右边子树没有说是根节点的右兄弟，只是画是这样画的</p>
<h3 id="5-5、树与二叉树的应用"><a href="#5-5、树与二叉树的应用" class="headerlink" title="5.5、树与二叉树的应用"></a><strong>5.5、树与二叉树的应用</strong></h3><p>哈夫曼树不唯一：比如左右子树互换</p>
<p>并查集</p>
<p>逻辑上：双亲表示法的树</p>
<p>存储：数组</p>
<p>并查集常用于克鲁斯卡尔kruskal算法、判断图的连通性（无向图）</p>
<p>在长度为n的并查集中，查找操作，未优化的时间复杂度为O(n)，优化之后才为O(log2n)</p>
<h2 id="7-1、树的概念"><a href="#7-1、树的概念" class="headerlink" title="7.1、树的概念"></a>7.1、树的概念</h2><h3 id="1、树的定义"><a href="#1、树的定义" class="headerlink" title="1、树的定义"></a>1、树的定义</h3><p><strong>形式化定义</strong></p>
<p>树：T&#x3D;{D，R}。D是包含n个结点的有限集合（n≥0）。当n&#x3D;0时为空树，否则关系R满足以下条件:       </p>
<ul>
<li>有且仅有一个结点d0∈D，它对于关系R来说没有前驱结点，结点d0称作树的根结点。</li>
<li>除根结点外，每个结点有且仅有一个前驱结点。</li>
<li>D中每个结点可以有零个或多个后继结点。.</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110715720.png" alt="image-20220430110715720"> </p>
<h3 id="2、树的逻辑表示"><a href="#2、树的逻辑表示" class="headerlink" title="2、树的逻辑表示"></a>2、树的逻辑表示</h3><p>（1）树形表示法</p>
<p>使用一棵倒置的树表示树结构，非常直观和形象。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110808521.png" alt="image-20220430110808521"> </p>
<p>（2）文氏图表示法。使用集合以及集合的包含关系描述树结构。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110835529.png" alt="image-20220430110835529"> </p>
<p>（3）凹入表示法。使用线段的伸缩关系描述树结构。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110903433.png" alt="image-20220430110903433"> </p>
<p>（4）括号表示法。用一个字符串表示树。<br>          基本形式:<br>                   根(子树1，子树2，…，子树m)</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430110920824.png" alt="image-20220430110920824"> </p>
<h3 id="3、树的基本术语"><a href="#3、树的基本术语" class="headerlink" title="3、树的基本术语"></a>3、树的基本术语</h3><p>1、结点的度与树的度：树中一个结点的子树的个数称为该结点的度。树中各结点的度的最大值称为树的度，通常将度为m的树称为m次树或者m叉树。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111035849.png" alt="image-20220430111035849"> </p>
<p>2、分支结点与叶结点：度不为零的结点称为非终端结点，又叫分支结点。度为零的结点称为终端结点或叶结点（或叶子结点）。<br>       度为1的结点称为单分支结点；度为2的结点称为双分支结点，依此类推。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111106995.png" alt="image-20220430111106995"> </p>
<p> 3、路径与路径长度：两个结点di和dj的结点序列（di，di1，di2，…，dj）称为路径。其中&lt;dx，dy&gt;是分支。<br>     路径长度等于路径所通过的结点数目减1（即路径上分支数目）。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111144420.png" alt="image-20220430111144420"> </p>
<p>4、孩子结点、双亲结点和兄弟结点：在一棵树中，每个结点的后继，被称作该结点的孩子结点（或子女结点）。相应地，该结点被称作孩子结点的双亲结点（或父母结点）。<br>     具有同一双亲的孩子结点互为兄弟结点。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111204265.png" alt="image-20220430111204265"> </p>
<p>5、子孙结点和祖先结点：在一棵树中，一个结点的所有子树中的结点称为该结点的子孙结点。<br>       从根结点到达一个结点的路径上经过的所有结点被称作该结点的祖先结点。 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111223604.png" alt="image-20220430111223604"> </p>
<p>6、结点的层次和树的高度：树中的每个结点都处在一个层次上。结点的层次从树根开始定义，根结点为第1层，它的孩子结点为第2层，以此类推，一个结点所在的层次为其双亲结点所在的层次加1。<br>        树中结点的最大层次称为树的高度（或树的深度）。 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111306241.png" alt="image-20220430111306241"> </p>
<p>7、有序树和无序树：若树中各结点的子树是按照一定的次序从左向右安排的，且相对次序是不能随意变换的，则称为有序树，否则称为无序树。 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111322153.png" alt="image-20220430111322153"> </p>
<p>8、森林：n（n＞0）个互不相交的树的集合称为森林。<br>        只要把树的根结点删去就成了森林。<br>        反之，只要给n棵独立的树加上一个结点，并把这n棵树作为该结点的子树，则森林就变成了一颗树。 </p>
<p>独木也成林！！！</p>
<h3 id="4、树的性质"><a href="#4、树的性质" class="headerlink" title="4、树的性质"></a>4、树的性质</h3><p>性质1  树中的结点数等于所有结点的度数之和加1。 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111451262.png" alt="image-20220430111451262"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111509376.png" alt="image-20220430111509376"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111724769.png" alt="image-20220430111724769"> </p>
<p>性质2  度为m的树中第i层上至多有mi-1个结点（i≥1）。 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111756707.png" alt="image-20220430111756707"> </p>
<p>性质3  高度为h的m次树至多有 $\frac{m^h-1}{m-1}$个结点。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111909537.png" alt="image-20220430111909537"> </p>
<p>性质4  具有n个结点的m次树的最小高度为[logm(n(m-1)+1)]。 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430111940388.png" alt="image-20220430111940388"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430112028973.png" alt="image-20220430112028973"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430112257750.png" alt="image-20220430112257750"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430112309304.png" alt="image-20220430112309304"> </p>
<h3 id="5、树的基本运算"><a href="#5、树的基本运算" class="headerlink" title="5、树的基本运算"></a>5、树的基本运算</h3><p> 树的运算主要分为三大类：</p>
<ul>
<li>查找满足某种特定关系的结点，如查找当前结点的双亲结点等；</li>
<li>插入或删除某个结点，如在树的当前结点上插入一个新结点或删除当前结点的第i个孩子结点等；</li>
<li>遍历树中每个结点。</li>
</ul>
<p><strong>树的遍历</strong></p>
<p>树的遍历运算是指按某种方式访问树中的每一个结点且每一个结点只被访问一次。</p>
<p>主要的遍历方法</p>
<ul>
<li>先根遍历（先序遍历）<ul>
<li>若树不空，则先访问根结点，然后依次先根遍历各棵子树。 </li>
<li>在二叉树中，是根节点，左子树，右子树</li>
</ul>
</li>
<li>中序遍历<ul>
<li>左，跟，右</li>
</ul>
</li>
<li>后跟遍历<ul>
<li>若树不空，则先依次后根遍历各棵子树，然后访问根结点。</li>
<li>在二叉树中，是左子树，右子树，根节点</li>
</ul>
</li>
<li>层次遍历<ul>
<li>若树不空，则自上而下、自左至右访问树中每个结点。</li>
</ul>
</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220413113228766.png" alt=" "></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430142807444.png" alt="image-20220430142807444"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220413113352259.png" alt="image-20220413113352259"></p>
<h3 id="6、树的存储结构"><a href="#6、树的存储结构" class="headerlink" title="6、树的存储结构"></a>6、树的存储结构</h3><h4 id="①、双亲存储结构"><a href="#①、双亲存储结构" class="headerlink" title="①、双亲存储结构"></a>①、双亲存储结构</h4><p> <img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430143559376.png" alt="image-20220430143559376"> </p>
<p>双亲存储结构的类型声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;　 ElemType data;	<span class="comment">//结点的值,左边的</span></span><br><span class="line">　   <span class="type">int</span> parent;		<span class="comment">//指向双亲的位置，右边的</span></span><br><span class="line">&#125; PTree[MaxSize];</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="②、孩子链存储结构"><a href="#②、孩子链存储结构" class="headerlink" title="②、孩子链存储结构"></a>②、孩子链存储结构</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430143812780.png" alt="image-20220430143812780"> </p>
<p>孩子链存储结构的结点类型声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;      ElemType data;		      <span class="comment">//结点的值</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">node</span> *sons[MaxSons];	      <span class="comment">//指向孩子结点</span></span><br><span class="line">&#125;  TSonNode;</span><br><span class="line"><span class="comment">//其中，MaxSons为最多的孩子结点个数。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思考题：<br>（1）n个结点的m次树有多少个空指针域？<br>（2）孩子链存储结构的优缺点？</p>
<h4 id="③、孩子兄弟链存储结构"><a href="#③、孩子兄弟链存储结构" class="headerlink" title="③、孩子兄弟链存储结构"></a>③、孩子兄弟链存储结构</h4><p>左子树是孩子，右子树是兄弟</p>
<p>孩子兄弟链存储结构是为每个结点设计3个域： </p>
<ul>
<li>一个数据元素域</li>
<li>第一个孩子结点指针域</li>
<li>一个兄弟结点指针域</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430195437441.png" alt="image-20220430195437441"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430195559031.png" alt="image-20220430195559031"></p>
<p>左孩子，右兄弟 </p>
<p>兄弟链存储结构中结点的类型声明如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tnode</span> </span><br><span class="line">&#123;      ElemType data;	<span class="comment">//结点的值，中间</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tnode</span> *hp;  	<span class="comment">//指向兄弟，右边</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tnode</span> *vp;  	<span class="comment">//指向孩子结点，左边</span></span><br><span class="line">&#125; TSBNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个结点固定只有两个指针域！！！</p>
<h2 id="7-2、二叉树的概念"><a href="#7-2、二叉树的概念" class="headerlink" title="7.2、二叉树的概念"></a>7.2、二叉树的概念</h2><h3 id="1、二叉树的定义"><a href="#1、二叉树的定义" class="headerlink" title="1、二叉树的定义"></a>1、二叉树的定义</h3><p>递归定义：二叉树是有限的结点集合</p>
<ul>
<li>这个集合或者是空。</li>
<li>或者由一个根结点和两棵互不相交的称为左子树和右子树的二叉树组成。</li>
</ul>
<p> <img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430144655044.png" alt="image-20220430144655044"> </p>
<p>二叉树是可以采用树的逻辑结构表示法，其4种表示法如下：</p>
<ul>
<li>　树形表示法</li>
<li>　文氏图表示法</li>
<li>　凹入表示法</li>
<li>　括号表示法</li>
</ul>
<h3 id="2、两种特殊的二叉树"><a href="#2、两种特殊的二叉树" class="headerlink" title="2、两种特殊的二叉树"></a>2、两种特殊的二叉树</h3><h4 id="①、满二叉树"><a href="#①、满二叉树" class="headerlink" title="①、满二叉树"></a>①、满二叉树</h4><p>在一棵二叉树中：</p>
<p>如果所有分支结点都有双分结点;<br>并且叶结点都集中在二叉树的最下一层。</p>
<p>高度为h的二叉树恰好有2<sup>h</sup>-1 个结点。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430145224262.png" alt="image-20220430145224262"> </p>
<h4 id="②、完全二叉树"><a href="#②、完全二叉树" class="headerlink" title="②、完全二叉树"></a>②、完全二叉树</h4><p>在一棵二叉树中：</p>
<p>最多只有下面两层的结点的度数小于2<br>并且最下面一层的叶结点都依次排列在该层最左边的位置上。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430145410474.png" alt="image-20220430145410474"> </p>
<p>完全二叉树实际上是对应的满二叉树删除叶结点层最右边若干个结点得到的。</p>
<h3 id="3、二叉树性质"><a href="#3、二叉树性质" class="headerlink" title="3、二叉树性质"></a>3、二叉树性质</h3><p>​    <strong>性质1</strong>   非空二叉树上叶结点数等于双分支结点数加1。即：n<sub>0</sub>&#x3D;n<sub>2</sub>+1。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430145516259.png" alt="image-20220430145516259"> </p>
<p>求解二叉树的结点个数问题：通常利用二叉树的性质1，即n<sub>0</sub>&#x3D;n<sub>2</sub>+1来求解这类问题，常利用以下关系求解：<br>        n&#x3D;n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub><br>       度之和&#x3D;n-1<br>       度之和&#x3D;n<sub>1</sub>+2n<sub>2</sub><br>所以有：<br>        n&#x3D;n<sub>1</sub>+2n<sub>2</sub>+1</p>
<p><strong>性质2</strong>  非空二叉树上第i层上至多有2<sup>i-1</sup>个结点（i≥1）。</p>
<p> <strong>性质3</strong>  高度为h的二叉树至多有2<sup>h</sup>-1个结点（h≥1），最少为h个结点。</p>
<p><strong>性质4</strong>  完全二叉树性质（含n为结点）：</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150108280.png" alt="image-20220430150108280"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150119115.png" alt="image-20220430150119115"> </p>
<h3 id="4、二叉树与树、森林之间的转换"><a href="#4、二叉树与树、森林之间的转换" class="headerlink" title="4、二叉树与树、森林之间的转换"></a>4、二叉树与树、森林之间的转换</h3><h4 id="①、森林、树转换为二叉树"><a href="#①、森林、树转换为二叉树" class="headerlink" title="①、森林、树转换为二叉树"></a>①、森林、树转换为二叉树</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150257167.png" alt="image-20220430150257167"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150343993.png" alt="image-20220430150343993"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150755428.png" alt="image-20220430150755428"> </p>
<h4 id="②、二叉树还原为森林、树"><a href="#②、二叉树还原为森林、树" class="headerlink" title="②、二叉树还原为森林、树"></a>②、二叉树还原为森林、树</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150917956.png" alt="image-20220430150917956"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150935416.png" alt="image-20220430150935416"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150943502.png" alt="image-20220430150943502"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430150953443.png" alt="image-20220430150953443"> </p>
<h2 id="7-3、二叉树的存储结构"><a href="#7-3、二叉树的存储结构" class="headerlink" title="7.3、二叉树的存储结构"></a>7.3、二叉树的存储结构</h2><h3 id="1、二叉树的顺序存储结构"><a href="#1、二叉树的顺序存储结构" class="headerlink" title="1、二叉树的顺序存储结构"></a>1、二叉树的顺序存储结构</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164007717.png" alt="image-20220430164007717"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164017785.png" alt="image-20220430164017785"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164035944.png" alt="image-20220430164035944"> </p>
<p><strong>二叉树顺序存储结构的特点：</strong></p>
<ul>
<li>对于完全二叉树来说，其顺序存储是十分合适的。</li>
<li>对于一般的二叉树，特别是对于那些单分支结点较多的二叉树来说是很不合适的，因为可能只有少数存储单元被利用，特别是对退化的二叉树（即每个分支结点都是单分支的），空间浪费更是惊人。</li>
<li>在顺序存储结构中，找一个结点的双亲和孩子都很容易。</li>
</ul>
<h3 id="2、二叉树的链式存储结构"><a href="#2、二叉树的链式存储结构" class="headerlink" title="2、二叉树的链式存储结构"></a>2、二叉树的链式存储结构</h3><p>在二叉树的链式存储中，结点的类型定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;     ElemType data;</span><br><span class="line">       <span class="keyword">struct</span> <span class="title class_">node</span> *lchild， *rchild;	<span class="comment">//指向的都是二叉树，递归性</span></span><br><span class="line">&#125;   BTNode;   </span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164302741.png" alt="image-20220430164302741"> </p>
<p> 二叉链存储结构的特点： </p>
<p>除了指针外，二叉链比较节省存储空间。占用的存储空间与树形没有关系，只与树中结点个数有关。<br>在二叉链中，找一个结点的孩子很容易，但找其双亲不方便。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164407858.png" alt="image-20220430164407858"> </p>
<h2 id="7-4、二叉树基本运算及其实现"><a href="#7-4、二叉树基本运算及其实现" class="headerlink" title="7.4、二叉树基本运算及其实现"></a>7.4、二叉树基本运算及其实现</h2><h3 id="1、二叉树的基本运算概述"><a href="#1、二叉树的基本运算概述" class="headerlink" title="1、二叉树的基本运算概述"></a>1、二叉树的基本运算概述</h3><p>二叉树的基本运算</p>
<ul>
<li>​        创建二叉树CreateBTNode(<em>b，</em>str)：根据二叉树括号表示法字符串str生成对应的二叉链存储结构b。</li>
<li>​        销毁二叉链存储结构DestroyBT(*b)：销毁二叉链b并释放空间。</li>
<li>​        查找结点FindNode(*b，x)：在二叉树b中寻找data域值为x的结点，并返回指向该结点的指针。 </li>
<li>​         找孩子结点LchildNode(p)和Rchild-Node(p)：分别求二叉树中结点 * p 的左孩子结点和右孩子结点。</li>
<li>​     求高度BTNodeDepth( * b)：求二叉树b的高度。若二叉树为空，则其高度为0；否则，其高度等于左子树与右子树中的最大高度加l。</li>
<li>​       输出二叉树DispBTNode(*b)：以括号表示法输出一棵二叉树。</li>
</ul>
<h3 id="2、二叉树的基本运算算法实现"><a href="#2、二叉树的基本运算算法实现" class="headerlink" title="2、二叉树的基本运算算法实现"></a>2、二叉树的基本运算算法实现</h3><p>（1）创建二叉树<code>CreateBTNode(*b，*str)</code> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164719709.png" alt="image-20220430164719709"> </p>
<p>正确的二叉树括号表示串中只有4类字符:</p>
<ul>
<li>单个字符：结点的值</li>
<li>(：表示一棵左子树的开始</li>
<li>)：表示一棵子树的结束</li>
<li>，：表示一棵右子树的开始</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164755835.png" alt="image-20220430164755835"> </p>
<p>用ch扫描采用括号表示法表示二叉树的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">① 若ch=‘(’：则将前面刚创建的结点作为双亲结点进栈，并置k=1，表示开始处理左孩子结点；</span><br><span class="line">② 若ch=‘)’：表示栈顶结点的左、右孩子结点处理完毕，退栈；</span><br><span class="line">③ 若ch=‘，’：表示开始处理右孩子结点，置k=2；</span><br><span class="line">④ 其他情况（结点值）：</span><br><span class="line">　　     创建*p结点用于存放ch；</span><br><span class="line">        当k=1时，将*p结点作为栈顶结点的左孩子结点；</span><br><span class="line">        当k=2时，将*p结点作为栈顶结点的右孩子结点。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430164850493.png" alt="image-20220430164850493"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBTNode</span><span class="params">(BTNode * &amp;b，<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="comment">//由str  二叉链b</span></span><br><span class="line">        BTNode *St[MaxSize]， *p;</span><br><span class="line">        <span class="type">int</span> top=<span class="number">-1</span>，  k ， j=<span class="number">0</span>;  </span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        b=<span class="literal">NULL</span>;		<span class="comment">//建立的二叉链初始时为空</span></span><br><span class="line">        ch=str[j];</span><br><span class="line">        <span class="keyword">while</span> (ch!=<span class="string">&#x27;\0&#x27;</span>)  	<span class="comment">//str未扫描完时循环</span></span><br><span class="line">        &#123;     <span class="keyword">switch</span>(ch) </span><br><span class="line">               &#123;</span><br><span class="line">	 			<span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: top++; St[top]=p; k=<span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//可能有左孩子结点，进栈</span></span><br><span class="line">	 			<span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: top--;  <span class="keyword">break</span>;</span><br><span class="line">	 			<span class="keyword">case</span> <span class="string">&#x27;，&#x27;</span>: k=<span class="number">2</span>;  <span class="keyword">break</span>; 			<span class="comment">//后面为右孩子结点</span></span><br><span class="line">        		<span class="keyword">default</span>:        		 <span class="comment">//遇到结点值</span></span><br><span class="line">                	p=(BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line">	  				p-&gt;data=ch;  p-&gt;lchild=p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">	  				<span class="keyword">if</span>  (b==<span class="literal">NULL</span>)    	<span class="comment">//p为二叉树的根结点</span></span><br><span class="line">	       				b=p;</span><br><span class="line">	  				<span class="keyword">else</span>    			<span class="comment">//已建立二叉树根结点</span></span><br><span class="line">                	&#123;     <span class="keyword">switch</span>(k) </span><br><span class="line">                       &#123;</span><br><span class="line">	         			<span class="keyword">case</span> <span class="number">1</span>:  St[top]-&gt;lchild=p;  <span class="keyword">break</span>;</span><br><span class="line">	         			<span class="keyword">case</span> <span class="number">2</span>:  St[top]-&gt;rchild=p;  <span class="keyword">break</span>;</span><br><span class="line">	         			&#125;</span><br><span class="line">                	&#125;</span><br><span class="line">         		&#125;</span><br><span class="line">         j++;  ch=str[j];		<span class="comment">//继续扫描str</span></span><br><span class="line">     	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）销毁二叉链<code>DestroyBT(*b)</code>：</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165047893.png" alt="image-20220430165047893"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应算法如下</span></span><br><span class="line"><span class="function"><span class="type">void</span>   <span class="title">DestroyBT</span><span class="params">(BTNode *&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">      <span class="keyword">if</span> (b==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;     <span class="built_in">DestroyBT</span>(b-&gt;lchild);</span><br><span class="line">             <span class="built_in">DestroyBT</span>(b-&gt;rchild);</span><br><span class="line">             <span class="built_in">free</span>(b);      <span class="comment">//剩下一个结点*b，直接释放</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）查找结点<code>FindNode(*b，x)</code></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165142884.png" alt="image-20220430165142884"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法</span></span><br><span class="line"><span class="function">BTNode *<span class="title">FindNode</span><span class="params">(BTNode *b，ElemType x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     BTNode *p;</span><br><span class="line">      <span class="keyword">if</span> (b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;data==x) <span class="keyword">return</span> b;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;     p=<span class="built_in">FindNode</span>(b-&gt;lchild，x);</span><br><span class="line">            <span class="keyword">if</span> (p!=<span class="literal">NULL</span>) <span class="keyword">return</span> p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">FindNode</span>(b-&gt;rchild，x);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）找孩子结点<code>LchildNode(p)</code>和<code>RchildNode(p)</code></p>
<p>直接返回*p结点的左孩子结点或右孩子结点的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">LchildNode</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode *<span class="title">RchildNode</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（5）求高度<code>BTNodeDepth(*b)</code></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165319197.png" alt="image-20220430165319197"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BTNodeDepth</span><span class="params">(BTNode *b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> lchilddep，rchilddep;</span><br><span class="line">      <span class="keyword">if</span> (b==<span class="literal">NULL</span>) <span class="keyword">return</span>(<span class="number">0</span>); 	<span class="comment">//空树的高度为0</span></span><br><span class="line">      <span class="keyword">else</span>  </span><br><span class="line">      &#123;     lchilddep=<span class="built_in">BTNodeDepth</span>(b-&gt;lchild);	</span><br><span class="line">		<span class="comment">//求左子树的高度为lchilddep</span></span><br><span class="line">            rchilddep=<span class="built_in">BTNodeDepth</span>(b-&gt;rchild);	</span><br><span class="line">		<span class="comment">//求右子树的高度为rchilddep</span></span><br><span class="line">            <span class="keyword">return</span>(lchilddep&gt;rchilddep)? (lchilddep<span class="number">+1</span>):(rchilddep<span class="number">+1</span>));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（6）输出二叉树<code>DispBTNode(*b)</code></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165354172.png" alt="image-20220430165354172"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>   <span class="title">DispBTNode</span><span class="params">(BTNode *b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     <span class="keyword">if</span> (b!=<span class="literal">NULL</span>)</span><br><span class="line">      &#123;       <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>，b-&gt;data);</span><br><span class="line">              <span class="keyword">if</span> (b-&gt;lchild!=<span class="literal">NULL</span> || b-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">              &#123;    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">	     <span class="built_in">DispBTNode</span>(b-&gt;lchild);　<span class="comment">//递归处理左子树</span></span><br><span class="line">	     <span class="keyword">if</span> (b-&gt;rchild!=<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;，&quot;</span>);</span><br><span class="line">	     <span class="built_in">DispBTNode</span>(b-&gt;rchild);　<span class="comment">//递归处理右子树</span></span><br><span class="line">	     <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根节点（左子树，右子树）</span></span><br></pre></td></tr></table></figure>



<h2 id="7-5、二叉树的遍历"><a href="#7-5、二叉树的遍历" class="headerlink" title="7.5、二叉树的遍历"></a>7.5、二叉树的遍历</h2><h3 id="1、二叉树遍历的概念"><a href="#1、二叉树遍历的概念" class="headerlink" title="1、二叉树遍历的概念"></a>1、二叉树遍历的概念</h3><p>　　二叉树遍历是指按照一定次序访问树中所有结点，并且每个结点仅被访问一次的过程。<br>　　遍历是二叉树最基本的运算，是二叉树中其他运算的基础。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165703818.png" alt="image-20220430165703818"> </p>
<h4 id="①、先序遍历"><a href="#①、先序遍历" class="headerlink" title="①、先序遍历"></a>①、先序遍历</h4><ul>
<li>根节点</li>
<li>左子树</li>
<li>右子树</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430165859604.png"> </p>
<h4 id="②、中序遍历"><a href="#②、中序遍历" class="headerlink" title="②、中序遍历"></a>②、中序遍历</h4><ul>
<li>左子树</li>
<li>根节点</li>
<li>右子树</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170040399.png" alt="image-20220430170040399"> </p>
<h4 id="③、后序遍历"><a href="#③、后序遍历" class="headerlink" title="③、后序遍历"></a>③、后序遍历</h4><ul>
<li>左子树</li>
<li>右子树</li>
<li>根节点</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170121008.png" alt="image-20220430170121008"> </p>
<h3 id="2、二叉树3种遍历的递归算法"><a href="#2、二叉树3种遍历的递归算法" class="headerlink" title="2、二叉树3种遍历的递归算法"></a>2、二叉树3种遍历的递归算法</h3><p>先序遍历的递归算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="keyword">if</span> (b!=<span class="literal">NULL</span>)  </span><br><span class="line">      &#123;     <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，b-&gt;data); 	<span class="comment">//访问根结点</span></span><br><span class="line">             <span class="built_in">PreOrder</span>(b-&gt;lchild);</span><br><span class="line">             <span class="built_in">PreOrder</span>(b-&gt;rchild);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    上述访问是直接输出结点值。实际上，访问结点可以对该结点进行各种操作，如计数、删除结点等。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170242138.png" alt="image-20220430170242138"> </p>
<p> 中序遍历的递归算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;       <span class="keyword">if</span> (b!=<span class="literal">NULL</span>)  </span><br><span class="line">        &#123;      <span class="built_in">InOrder</span>(b-&gt;lchild);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，b-&gt;data); 	<span class="comment">//访问根结点</span></span><br><span class="line">	 <span class="built_in">InOrder</span>(b-&gt;rchild);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 后序遍历的递归算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BTNode *b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;      <span class="keyword">if</span> (b!=<span class="literal">NULL</span>)  </span><br><span class="line">        &#123;      <span class="built_in">PostOrder</span>(b-&gt;lchild);</span><br><span class="line">	 <span class="built_in">PostOrder</span>(b-&gt;rchild);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，b-&gt;data); 	<span class="comment">//访问根结点</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二叉树3种递归遍历算法的应用</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170353523.png" alt="image-20220430170353523"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170401143.png" alt="image-20220430170401143"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170409771.png" alt="image-20220430170409771"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170418570.png" alt="image-20220430170418570"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170425487.png" alt="image-20220430170425487"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170432964.png" alt="image-20220430170432964"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170441800.png" alt="image-20220430170441800"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170450624.png" alt="image-20220430170450624"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170458012.png" alt="image-20220430170458012"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170505956.png" alt="image-20220430170505956"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170513278.png" alt="image-20220430170513278"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170521632.png" alt="image-20220430170521632"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170531876.png" alt="image-20220430170531876"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170540047.png" alt="image-20220430170540047"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170547751.png" alt="image-20220430170547751"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170554459.png" alt="image-20220430170554459"> </p>
<h3 id="3、二叉树3种遍历的非递归算法"><a href="#3、二叉树3种遍历的非递归算法" class="headerlink" title="3、二叉树3种遍历的非递归算法"></a>3、二叉树3种遍历的非递归算法</h3><h4 id="①、先序遍历非递归算法1"><a href="#①、先序遍历非递归算法1" class="headerlink" title="①、先序遍历非递归算法1"></a>①、先序遍历非递归算法1</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170651120.png" alt="image-20220430170651120"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (当前b树不空)</span><br><span class="line">&#123;</span><br><span class="line">　  根结点b进栈;</span><br><span class="line">      <span class="keyword">while</span> (栈不空)</span><br><span class="line">      &#123;</span><br><span class="line">           出栈结点p并访问之;</span><br><span class="line">           若p结点有右孩子，将其右孩子进栈； </span><br><span class="line">           若p结点有左孩子，将其左孩子进栈；</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430170950439.png" alt="image-20220430170950439"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder1</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;     BTNode *p;</span><br><span class="line">       SqStack *st;				<span class="comment">//定义栈指针st</span></span><br><span class="line">       <span class="built_in">InitStack</span>(st);			<span class="comment">//初始化栈st</span></span><br><span class="line">       <span class="keyword">if</span> (b!=<span class="literal">NULL</span>) </span><br><span class="line">       &#123;	<span class="built_in">Push</span>(st，b);			<span class="comment">//根结点进栈</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(st))		<span class="comment">//栈不为空时循环</span></span><br><span class="line">	&#123;      <span class="built_in">Pop</span>(st，p);			<span class="comment">//退栈结点p并访问它</span></span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，p-&gt;data);</span><br><span class="line">	        <span class="keyword">if</span> (p-&gt;rchild!=<span class="literal">NULL</span>)	<span class="comment">//有右孩子时将其进栈</span></span><br><span class="line">		  <span class="built_in">Push</span>(st，p-&gt;rchild);</span><br><span class="line">	        <span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>)	<span class="comment">//有左孩子时将其进栈</span></span><br><span class="line">		   <span class="built_in">Push</span>(st，p-&gt;lchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">DestroyStack</span>(st);			<span class="comment">//销毁栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="②、先序遍历非递归算法2"><a href="#②、先序遍历非递归算法2" class="headerlink" title="②、先序遍历非递归算法2"></a>②、先序遍历非递归算法2</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171047640.png" alt="image-20220430171047640"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  p＝b;</span><br><span class="line">  <span class="keyword">while</span> (栈不空或者p!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;      访问p所指结点;将p进栈；</span><br><span class="line">                p=p-&gt;lchild</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">//以下考虑栈顶结点</span></span><br><span class="line">        <span class="keyword">if</span> (栈不空) </span><br><span class="line">　　&#123;      出栈p；</span><br><span class="line">　　　    p＝p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171115419.png" alt="image-20220430171115419"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171126419.png" alt="image-20220430171126419"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder2</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;       BTNode *p;  SqStack *st;		<span class="comment">//定义一个顺序栈指针st</span></span><br><span class="line">         <span class="built_in">InitStack</span>(st);			<span class="comment">//初始化栈st</span></span><br><span class="line">         p=b;</span><br><span class="line">         <span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(st) || p!=<span class="literal">NULL</span>)</span><br><span class="line">          &#123;	    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)	 <span class="comment">//访问结点p及其所有左下结点并进栈</span></span><br><span class="line">	     &#123;	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，p-&gt;data);	<span class="comment">//访问结点p</span></span><br><span class="line">		<span class="built_in">Push</span>(st，p);		<span class="comment">//结点p进栈</span></span><br><span class="line">		p=p-&gt;lchild;		<span class="comment">//移动到左孩子</span></span><br><span class="line">	     &#125;</span><br><span class="line">	      <span class="comment">//以下考虑栈顶结点</span></span><br><span class="line">	     <span class="keyword">if</span> (!<span class="built_in">StackEmpty</span>(st))		<span class="comment">//若栈不空</span></span><br><span class="line">	      &#123;	<span class="built_in">Pop</span>(st，p);		<span class="comment">//出栈结点p</span></span><br><span class="line">		p=p-&gt;rchild;		<span class="comment">//转向处理其右子树</span></span><br><span class="line">	      &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           <span class="built_in">DestroyStack</span>(st);			<span class="comment">//销毁栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="③、中序遍历非递归算法"><a href="#③、中序遍历非递归算法" class="headerlink" title="③、中序遍历非递归算法"></a>③、中序遍历非递归算法</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171207128.png" alt="image-20220430171207128"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p＝b;</span><br><span class="line"><span class="keyword">while</span> (栈不空或者p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;     将p进栈；</span><br><span class="line">               p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下考虑栈顶结点</span></span><br><span class="line">       <span class="keyword">if</span> (栈不空) </span><br><span class="line">       &#123;      出栈p并访问之；</span><br><span class="line">　　       p＝p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171225781.png" alt="image-20220430171225781"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171234043.png" alt="image-20220430171234043"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder1</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;      BTNode *p;  SqStack *st;	<span class="comment">//定义一个顺序栈指针st</span></span><br><span class="line">        <span class="built_in">InitStack</span>(st);		<span class="comment">//初始化栈st</span></span><br><span class="line">        p=b;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(st) || p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>)	<span class="comment">//扫描结点p的所有左下结点并进栈</span></span><br><span class="line">	&#123;      <span class="built_in">Push</span>(st，p);		<span class="comment">//结点p进栈</span></span><br><span class="line">	        p=p-&gt;lchild;	<span class="comment">//移动到左孩子</span></span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">//以下考虑栈顶结点</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">StackEmpty</span>(st))	<span class="comment">//若栈不空</span></span><br><span class="line">	&#123;      <span class="built_in">Pop</span>(st，p);		<span class="comment">//出栈结点p，访问结点p</span></span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，p-&gt;data);</span><br><span class="line">	        p=p-&gt;rchild;	<span class="comment">//转向处理其右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">DestroyStack</span>(st);		<span class="comment">//销毁栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="④、后序遍历非递归算法"><a href="#④、后序遍历非递归算法" class="headerlink" title="④、后序遍历非递归算法"></a>④、后序遍历非递归算法</h4><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171311781.png" alt="image-20220430171311781"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171318970.png" alt="image-20220430171318970"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历非递归过程</span></span><br><span class="line">p=b;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;      <span class="keyword">while</span> (结点p有左孩子)</span><br><span class="line">        &#123;	将结点p进栈;</span><br><span class="line">	p=p-&gt;lchild;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//此时栈顶结点(尚未访问)没有左孩子或左子树已遍历过</span></span><br><span class="line">        <span class="keyword">while</span> (栈不空且结点p是栈顶结点)</span><br><span class="line">        &#123;	取栈顶结点p;</span><br><span class="line">	<span class="keyword">if</span> (结点p的右子树已访问)</span><br><span class="line">	&#123;      访问结点p;</span><br><span class="line">	        退栈;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> p=p-&gt;rchild;     <span class="comment">//转向处理其右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (栈不空);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171357627.png" alt="image-20220430171357627"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder1</span><span class="params">(BTNode *b)</span>	<span class="comment">//后序非递归遍历算法</span></span></span><br><span class="line"><span class="function"></span>&#123;      BTNode *p，*r;</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        SqStack *st;		<span class="comment">//定义一个顺序栈指针st</span></span><br><span class="line">        <span class="built_in">InitStack</span>(st);		<span class="comment">//初始化栈st</span></span><br><span class="line">        p=b;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>)	<span class="comment">//扫描结点p的所有左下结点并进栈</span></span><br><span class="line">			&#123;       <span class="built_in">Push</span>(st，p);		<span class="comment">//结点p进栈</span></span><br><span class="line">	         		p=p-&gt;lchild;	<span class="comment">//移动到左孩子</span></span><br><span class="line">			&#125;</span><br><span class="line">			r=<span class="literal">NULL</span>;		<span class="comment">//r指向刚刚访问的结点，初始时为空</span></span><br><span class="line">			flag=<span class="literal">true</span>;		<span class="comment">//flag为真表示正在处理栈顶结点</span></span><br><span class="line">       		<span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(st) &amp;&amp; flag)</span><br><span class="line">        	&#123;      <span class="built_in">GetTop</span>(st，p);	         <span class="comment">//取出当前的栈顶结点p</span></span><br><span class="line">	 			<span class="keyword">if</span> (p-&gt;rchild==r)        <span class="comment">//若结点p的右孩子为空或者为刚访问结点	</span></span><br><span class="line">            	&#123;       <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，p-&gt;data);     <span class="comment">//访问结点p</span></span><br><span class="line">	         			<span class="built_in">Pop</span>(st，p);</span><br><span class="line">	         			r=p;		 <span class="comment">//r指向刚访问过的结点</span></span><br><span class="line">	 			&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;      p=p-&gt;rchild;	<span class="comment">//转向处理其右子树</span></span><br><span class="line">	       				flag=<span class="literal">false</span>;		<span class="comment">//表示当前不是处理栈顶结点</span></span><br><span class="line">				&#125;</span><br><span class="line">          	&#125;</span><br><span class="line">      	&#125; <span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(st));	<span class="comment">//栈不空循环</span></span><br><span class="line">      	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      	<span class="built_in">DestroyStack</span>(st);		<span class="comment">//销毁栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​       从上述过程可知，栈中保存的是当前结点p的所有祖先结点（均未访问过）。<br>​        例如，求一个结点的所有祖先结点等。 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171617193.png" alt="image-20220430171617193"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AllPath1</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;      BTNode *p，*r;</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        SqStack *st;		<span class="comment">//定义一个顺序栈指针st</span></span><br><span class="line">        <span class="built_in">InitStack</span>(st);		<span class="comment">//初始化栈st</span></span><br><span class="line">        p=b;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;	 <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)	<span class="comment">//扫描结点p的所有左下结点并进栈</span></span><br><span class="line">	 &#123;      <span class="built_in">Push</span>(st，p);	<span class="comment">//结点p进栈</span></span><br><span class="line">	         p=p-&gt;lchild;	<span class="comment">//移动到左孩子</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 r=<span class="literal">NULL</span>;		<span class="comment">//r指向刚刚访问的结点，初始时为空</span></span><br><span class="line">	 flag=<span class="literal">true</span>;		<span class="comment">//flag为真表示正在处理栈顶结点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171639931.png" alt="image-20220430171639931"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171647183.png" alt="image-20220430171647183"> </p>
<h3 id="4、层次遍历算法"><a href="#4、层次遍历算法" class="headerlink" title="4、层次遍历算法"></a>4、层次遍历算法</h3><p>层次遍历过程：</p>
<p>　　对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。<br>        每一个结点仅仅访问一次。</p>
<p>算法设计思路：</p>
<p>使用一个队列。</p>
<ol>
<li>将根结点进队；</li>
<li>队不空时循环：从队列中出列一个结点*p，访问它；<ol>
<li>若它有左孩子结点，将左孩子结点进队；</li>
<li>若它有右孩子结点，将右孩子结点进队。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应算法如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;      BTNode *data[MaxSize];	<span class="comment">//存放队中元素</span></span><br><span class="line">       <span class="type">int</span> front，rear;		<span class="comment">//队头和队尾指针</span></span><br><span class="line">&#125; SqQueue;			<span class="comment">//环形队列类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;      BTNode *p;</span><br><span class="line">        SqQueue *qu;			<span class="comment">//定义环形队列指针</span></span><br><span class="line">        <span class="built_in">InitQueue</span>(qu);			<span class="comment">//初始化队列</span></span><br><span class="line">        <span class="built_in">enQueue</span>(qu，b);			<span class="comment">//根结点指针进入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">QueueEmpty</span>(qu))		<span class="comment">//队不为空循环</span></span><br><span class="line">        &#123;	<span class="built_in">deQueue</span>(qu，p);		<span class="comment">//出队结点p</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，p-&gt;data);		<span class="comment">//访问结点p</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>)		<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">	       <span class="built_in">enQueue</span>(qu，p-&gt;lchild);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;rchild!=<span class="literal">NULL</span>)		<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">	       <span class="built_in">enQueue</span>(qu，p-&gt;rchild);</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171835596.png" alt="image-20220430171835596"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应算法如下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AllPath2</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;       <span class="type">int</span> k;</span><br><span class="line">        BTNode *p;</span><br><span class="line">        NodeType qelem;</span><br><span class="line">        QuType *qu;		    <span class="comment">//定义非非环形队列指针</span></span><br><span class="line">        <span class="built_in">InitQueue</span>(qu);		    <span class="comment">//初始化队列</span></span><br><span class="line">        qelem.pt=b; qelem.parent=<span class="number">-1</span>;   <span class="comment">//创建根结点对应的队列元素</span></span><br><span class="line">        <span class="built_in">enQueue</span>(qu，qelem);		    <span class="comment">//根结点进队</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">QueueEmpty</span>(qu))	<span class="comment">//队不空循环</span></span><br><span class="line">         &#123;	<span class="built_in">deQueue</span>(qu，qelem);	<span class="comment">//出队元素在队中下标为qu-&gt;front</span></span><br><span class="line">	p=qelem.pt;		<span class="comment">//取元素qelem对应的结点p</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; p-&gt;rchild==<span class="literal">NULL</span>)  </span><br><span class="line">	&#123;      k=qu-&gt;front;	<span class="comment">//输出结点p到根结点的路径逆序列</span></span><br><span class="line">	       <span class="keyword">while</span> (qu-&gt;data[k].parent!=<span class="number">-1</span>)</span><br><span class="line">	       &#123;	<span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;&quot;</span>，qu-&gt;data[k].pt-&gt;data);</span><br><span class="line">		k=qu-&gt;data[k].parent;</span><br><span class="line">	       &#125;</span><br><span class="line">	       <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>，qu-&gt;data[k].pt-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">             <span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>)		<span class="comment">//结点p有左孩子</span></span><br><span class="line">             &#123;      qelem.pt=p-&gt;lchild;		<span class="comment">//创建左孩子对应的队列元素</span></span><br><span class="line">	      qelem.parent=qu-&gt;front; 	<span class="comment">//其双亲位置为qu-&gt;front</span></span><br><span class="line">	      <span class="built_in">enQueue</span>(qu，qelem);		<span class="comment">//结点p的左孩子进队</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (p-&gt;rchild!=<span class="literal">NULL</span>)		<span class="comment">//结点p有右孩子</span></span><br><span class="line">             &#123;      qelem.pt=p-&gt;rchild;		<span class="comment">//创建右孩子对应的队列元素</span></span><br><span class="line">	      qelem.parent=qu-&gt;front;	<span class="comment">//其双亲位置为qu-&gt;front</span></span><br><span class="line">	      <span class="built_in">enQueue</span>(qu，qelem);		<span class="comment">//结点p的右孩子进队</span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171916368.png" alt="image-20220430171916368"> </p>
<h2 id="7-6、二叉树的构造"><a href="#7-6、二叉树的构造" class="headerlink" title="7.6、二叉树的构造"></a>7.6、二叉树的构造</h2><p>　 同时给定一棵二叉树的先序序列和中序序列就能唯一确定这棵二叉树。 √<br>　 同时给定一棵二叉树的中序序列和后序序列就能唯一确定这棵二叉树。 √<br>　 同时给定一棵二叉树的先序序列和后序序列就能唯一确定这棵二叉树。 ×</p>
<p>​      定理7.1：任何n（n&gt;0）个不同结点的二又树，都可由它的中序序列和先序序列唯一地确定。     </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184858197.png" alt="image-20220430184858197"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184913353.png" alt="image-20220430184913353"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下构造二叉树的算法：</span></span><br><span class="line"></span><br><span class="line"><span class="function">BTNode *<span class="title">CreateBT1</span><span class="params">(<span class="type">char</span> *pre，<span class="type">char</span> *in，<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;      BTNode *s;  <span class="type">char</span> *p;  <span class="type">int</span> k;</span><br><span class="line">       <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       s=(BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));            <span class="comment">//创建根结点</span></span><br><span class="line">       s-&gt;data=*pre;</span><br><span class="line">       <span class="keyword">for</span> (p=in;p&lt;in+n;p++)	             <span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">	 <span class="keyword">if</span> (*p==*pre)</span><br><span class="line"> 	      <span class="keyword">break</span>;</span><br><span class="line">       k=p-in; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184951612.png" alt="image-20220430184951612"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185002186.png" alt="image-20220430185002186"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185009768.png" alt="image-20220430185009768"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下构造二叉树的算法：</span></span><br><span class="line"><span class="function">BTNode *<span class="title">CreateBT2</span><span class="params">(<span class="type">char</span> *post，<span class="type">char</span> *in，<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;      BTNode *b;  <span class="type">char</span> r，*p;  <span class="type">int</span> k;</span><br><span class="line">       <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       r=*(post+n<span class="number">-1</span>);			     <span class="comment">//根结点值</span></span><br><span class="line">       b=(BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));    <span class="comment">//创建二叉树结点*b</span></span><br><span class="line">       b-&gt;data=r;</span><br><span class="line">       <span class="keyword">for</span> (p=in;p&lt;in+n;p++)		     <span class="comment">//在in中查找根结点</span></span><br><span class="line">	<span class="keyword">if</span> (*p==r)  <span class="keyword">break</span>;</span><br><span class="line">       k=p-in;				     <span class="comment">//k为根结点在in中的下标   </span></span><br><span class="line">       b-&gt;lchild=<span class="built_in">CreateBT2</span>(post，in，k);	        <span class="comment">//递归构造左子树</span></span><br><span class="line">       b-&gt;rchild=<span class="built_in">CreateBT2</span>(post+k，p<span class="number">+1</span>，n-k<span class="number">-1</span>);   <span class="comment">//递归构造右子树</span></span><br><span class="line">       <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185038845.png" alt="image-20220430185038845"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185047042.png" alt="image-20220430185047042"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应的递归算法如下： 先序遍历</span></span><br><span class="line"><span class="function">BTNode *<span class="title">trans</span><span class="params">(SqBTree a，<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;      BTNode *b;</span><br><span class="line">　　<span class="keyword">if</span> (i&gt;MaxSize)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">　　<span class="keyword">if</span> (a[i]==<span class="string">&#x27;#&#x27;</span>)	  <span class="keyword">return</span> <span class="literal">NULL</span>; 	      <span class="comment">//当结点不存在时返回NULL</span></span><br><span class="line">　　b=(BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));    <span class="comment">//创建根结点</span></span><br><span class="line">　　b-&gt;data=a[i];</span><br><span class="line">　　b-&gt;lchild=<span class="built_in">trans</span>(a，<span class="number">2</span>*i);		<span class="comment">//递归创建左子树</span></span><br><span class="line">　　b-&gt;rchild=<span class="built_in">trans</span>(a，<span class="number">2</span>*i<span class="number">+1</span>);  		<span class="comment">//递归创建右子树</span></span><br><span class="line">　　<span class="keyword">return</span>(b);				<span class="comment">//返回根结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185129792.png" alt="image-20220430185129792"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历的思路</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">trans1</span><span class="params">(BTNode *b，SqBTree a，<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;       a[i]=b-&gt;data;			 <span class="comment">//创建根结点</span></span><br><span class="line">                <span class="built_in">trans1</span>(b-&gt;lchild，a，<span class="number">2</span>*i);	 <span class="comment">//递归创建左子树</span></span><br><span class="line">                <span class="built_in">trans1</span>(b-&gt;rchild，a，<span class="number">2</span>*i<span class="number">+1</span>);	 <span class="comment">//递归创建右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171935232.png" alt="image-20220430171935232"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171943188.png" alt="image-20220430171943188"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430171950080.png" alt="image-20220430171950080"> </p>
<h2 id="7-7、线索二叉树"><a href="#7-7、线索二叉树" class="headerlink" title="7.7、线索二叉树"></a>7.7、线索二叉树</h2><h3 id="1、线索二叉树的概念"><a href="#1、线索二叉树的概念" class="headerlink" title="1、线索二叉树的概念"></a>1、线索二叉树的概念</h3><p>回顾</p>
<ul>
<li>对于具有n个结点的二叉树，采用二叉链存储结构时，每个结点有两个指针域，总共有2n个指针域。</li>
<li>其中只有n-1个结点被有效指针所指向，即有n-1个非空指针域。</li>
<li>所以共有2n-(n-1) &#x3D; n+1个空链域。</li>
</ul>
<p>相关概念</p>
<ul>
<li>采用某种方法遍历二叉树的结果是一个结点的线性序列。</li>
<li>修改空链域改为存放指向结点的前驱和后继结点的地址。</li>
<li>这样的指向该线性序列中的“前驱”和“后继”的指针，称作线索（thread）。</li>
<li>创建线索的过程称为线索化。</li>
<li>线索化的二叉树称为线索二叉树。</li>
<li>显然线索二叉树与采用的遍历方法相关，有先序线索二叉树、中序线索二叉树和后序线索二叉树。</li>
<li>线索二叉树的目的是提高该遍历过程的效率。</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430172049809.png" alt="image-20220430172049809"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索化二叉树中结点的类型定义</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">  &#123;      ElemType data;		<span class="comment">//结点数据域</span></span><br><span class="line">         <span class="type">int</span> ltag，rtag;      		<span class="comment">//增加的线索标记</span></span><br><span class="line">         <span class="keyword">struct</span> <span class="title class_">node</span> *lchild;		<span class="comment">//左孩子或线索指针</span></span><br><span class="line">         <span class="keyword">struct</span> <span class="title class_">node</span> *rchild;		<span class="comment">//右孩子或线索指针</span></span><br><span class="line">  &#125;  TBTNode;		　　　	<span class="comment">//线索树结点类型定义 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430172531696.png" alt="image-20220430172531696"> </p>
<h3 id="2、线索化二叉树"><a href="#2、线索化二叉树" class="headerlink" title="2、线索化二叉树"></a>2、线索化二叉树</h3><p>建立某种次序的线索二叉树过程： </p>
<ul>
<li>以该遍历方法遍历一棵二叉树。</li>
<li>在遍历的过程中，检查当前访问结点的左、右指针域是否为空：<ul>
<li>如果左指针域为空，将它改为指向前驱结点的线索；</li>
<li>如果右指针域为空，将它改为指向后继结点的线索。</li>
</ul>
</li>
</ul>
<p>以中序线索二叉树为例，讨论建立线索二叉树的算法。  </p>
<p> <strong>建立中序线索二叉树的算法</strong></p>
<ul>
<li>CreatThread(b)算法：对以二叉链存储的二叉树b进行中序线索化，并返回线索化后头结点的指针root。</li>
<li>Thread(p)算法：对以*p为根结点的二叉树子树的中序线索化。</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184607768.png" alt="image-20220430184607768"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184617351.png" alt="image-20220430184617351"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">TBTNode *pre;		   		<span class="comment">//全局变量</span></span><br><span class="line"><span class="function">TBTNode *<span class="title">CreatThread</span><span class="params">(TBTNode *b)</span>     <span class="comment">//中序线索化二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;    TBTNode *root;</span><br><span class="line">     root=(TBTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TBTNode));  <span class="comment">//创建头结点</span></span><br><span class="line">     root-&gt;ltag=<span class="number">0</span>; root-&gt;rtag=<span class="number">1</span>;  root-&gt;rchild=b;</span><br><span class="line">     <span class="keyword">if</span> (b==<span class="literal">NULL</span>) root-&gt;lchild=root;	<span class="comment">//空二叉树</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;        root-&gt;lchild=b;</span><br><span class="line">	pre=root;             	<span class="comment">//pre是*p的前驱结点，供加线索用</span></span><br><span class="line">	<span class="built_in">Thread</span>(b);   		<span class="comment">//中序遍历线索化二叉树</span></span><br><span class="line">	pre-&gt;rchild=root;    	<span class="comment">//最后处理，加入指向头结点的线索</span></span><br><span class="line">	pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">	root-&gt;rchild=pre;    	<span class="comment">//头结点右线索化</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Thread</span><span class="params">(TBTNode *&amp;p)</span>    		<span class="comment">//对二叉树b进行中序线索化</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>)	</span><br><span class="line">     &#123;  </span><br><span class="line">             <span class="built_in">Thread</span>(p-&gt;lchild);           		<span class="comment">//左子树线索化</span></span><br><span class="line">             <span class="keyword">if</span> (p-&gt;lchild==<span class="literal">NULL</span>)          	<span class="comment">//前驱线索化</span></span><br><span class="line">             &#123;     p-&gt;lchild=pre; p-&gt;ltag=<span class="number">1</span>;  &#125;	<span class="comment">//建立当前结点的前驱线索</span></span><br><span class="line">             <span class="keyword">else</span>  p-&gt;ltag=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span>  (pre-&gt;rchild==<span class="literal">NULL</span>)	     	<span class="comment">//后继线索化</span></span><br><span class="line">            &#123;     pre-&gt;rchild=p;pre-&gt;rtag=<span class="number">1</span>;&#125;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            <span class="keyword">else</span>  pre-&gt;rtag=<span class="number">0</span>;</span><br><span class="line">            pre=p;</span><br><span class="line">           <span class="built_in">Thread</span>(p-&gt;rchild);  		<span class="comment">//递归调用右子树线索化</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、遍历线索后二叉树"><a href="#3、遍历线索后二叉树" class="headerlink" title="3、遍历线索后二叉树"></a>3、遍历线索后二叉树</h3><p>　　 遍历某种次序的线索二叉树，就是从该次序下的开始结点出发，反复找到该结点在该次序下的后继结点，直到头结点。  　　 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184710915.png" alt="image-20220430184710915"> </p>
<p>在中序线索二叉树中中序遍历的过程： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p指向根结点；</span><br><span class="line"><span class="keyword">while</span> p ≠root时循环</span><br><span class="line">&#123;</span><br><span class="line">        找开始结点*p；</span><br><span class="line">        访问*p结点；</span><br><span class="line">        <span class="keyword">while</span> (*p结点有右线索)   </span><br><span class="line">                 一直访问下去；</span><br><span class="line">        p转向右孩子结点；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430184735896.png" alt="image-20220430184735896"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThInOrder</span><span class="params">(TBTNode *tb)</span></span></span><br><span class="line"><span class="function"></span>&#123;      TBTNode *p=tb-&gt;lchild;			<span class="comment">//p指向根结点</span></span><br><span class="line">       <span class="keyword">while</span> (p!=tb)</span><br><span class="line">       &#123;     </span><br><span class="line">              <span class="keyword">while</span> (p-&gt;ltag==<span class="number">0</span>)   p=p-&gt;lchild;		<span class="comment">//找开始结点</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>，p-&gt;data);			<span class="comment">//访问开始结点</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;rtag==<span class="number">1</span> &amp;&amp; p-&gt;rchild!=tb)</span><br><span class="line">	&#123;     p=p-&gt;rchild;</span><br><span class="line">	       <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>，p-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	p=p-&gt;rchild;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//优点：中序遍历算法既没有递归也没有用栈，空间效率得到提高。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="7-8、哈夫曼树"><a href="#7-8、哈夫曼树" class="headerlink" title="7.8、哈夫曼树"></a>7.8、哈夫曼树</h2><p>具有最小带权路径长度的二叉树称为赫夫曼树（也称最优树）。</p>
<h3 id="1、最优二叉树"><a href="#1、最优二叉树" class="headerlink" title="1、最优二叉树"></a>1、最优二叉树</h3><h4 id="①、定义"><a href="#①、定义" class="headerlink" title="①、定义"></a>①、定义</h4><p>　　设二叉树具有n个带权值的叶结点，那么从根结点到各个叶结点的路径长度与相应结点权值的乘积的和，叫做二叉树的带权路径长度。       </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185312519.png" alt="image-20220430185312519"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185359040.png" alt="image-20220430185359040"> </p>
<h3 id="2、构造赫夫曼树的原则"><a href="#2、构造赫夫曼树的原则" class="headerlink" title="2、构造赫夫曼树的原则"></a>2、构造赫夫曼树的原则</h3><ul>
<li>权值越大的叶结点越靠近根结点。</li>
<li>权值越小的叶结点越远离根结点。</li>
</ul>
<h3 id="3、构造赫夫曼树的过程："><a href="#3、构造赫夫曼树的过程：" class="headerlink" title="3、构造赫夫曼树的过程："></a>3、构造赫夫曼树的过程：</h3><p>​     （1）给定的n个权值{W1，W2，…，Wn}构造n棵只有一个叶结点的二叉树，从而得到一个二叉树的集合F&#x3D;{T1，T2，…，Tn}。<br>​     （2）在F中选取根结点的权值最小和次小的两棵二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根结点的权值为其左、右子树根结点权值之和。<br>​     （3）在集合F中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F中。<br>​     （4）重复（2）、（3）两步，当F中只剩下一棵二叉树时，这棵二叉树便是所要建立的赫夫曼树。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185550175.png" alt="image-20220430185550175"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185600049.png" alt="image-20220430185600049"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185610759.png" alt="image-20220430185610759"> </p>
<h3 id="4、Huffman编码"><a href="#4、Huffman编码" class="headerlink" title="4、Huffman编码"></a>4、Huffman编码</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185708137.png" alt="image-20220430185708137"> </p>
<p>（1）编码<br>    思想：根据字符出现频率编码，利用赫夫曼树构造一种不等长的二进制编码，使电文总长最短<br>    编码：根据字符出现频率构造Huffman树，然后将树中结点引向其左孩子的分支标“0”，引向其右孩子的分支标“1”；每个字符的编码即为从根到每个叶子的路径上得到的0、1序列</p>
<p>​         构造所得的赫夫曼编码是一种最优前缀编码，即使所传电文的总长度最短。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185746384.png"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185802631.png" alt="image-20220430185802631"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185811811.png" alt="image-20220430185811811"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220430185818382.png" alt="image-20220430185818382"> </p>
<h1 id="六、图"><a href="#六、图" class="headerlink" title="六、图"></a>六、图</h1><h3 id="6-1、图的基本概念"><a href="#6-1、图的基本概念" class="headerlink" title="6.1、图的基本概念"></a><strong>6.1、图的基本概念</strong></h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps10.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps11.jpg" alt="img"> </p>
<p>极大连通子图：包含所有的边</p>
<p>极小连通子图：保持图连通，同时边数最小</p>
<p>无向图的极大连通子图称为连通分量</p>
<p>（如果本身就是连通图则本身就是其连通分量，而非连通图的各个连通图作为其组成部分均为其连通分量）</p>
<p>生成树：包含所有顶点的一个极小连通子图</p>
<p>树：n个顶点，n-1条边</p>
<p>森林：顶点树-边数&#x3D;树的个数</p>
<h3 id="6-3、图的遍历"><a href="#6-3、图的遍历" class="headerlink" title="6.3、图的遍历"></a><strong>6.3、图的遍历</strong></h3><p>当各边的权值相等时，广度优先算法可以解决单源最短路径问题</p>
<p>对一个有n个顶点e条边的图采用邻接表表示时，进行DFS遍历的时间复杂度为 O(n+e),空间复杂度为 O(n)</p>
<p>进行BFS遍历的时间复杂度为 O(n+e),空间复杂度为 O(n)</p>
<p>临界矩阵的话，N*N，不管是DFS，还是BFS，都需要走完这个矩阵，复杂度：O(n2)</p>
<p>判断有向图存在回路：</p>
<p>1、拓扑排序</p>
<p>2、最短路径的Digkstra算法</p>
<p>3、深度优先：如果遍历的点已在栈中，说明有回路</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps12.jpg" alt="img"> </p>
<h3 id="6-4、图的应用"><a href="#6-4、图的应用" class="headerlink" title="6.4、图的应用"></a><strong>6.4、图的应用</strong></h3><p>生成树：树的极小连通子图，有****所有的顶点****和尽可能少的边</p>
<p>最小生成树：生成树中权值最小的，所有的顶点和最少的边</p>
<p>无向连通图中最小生成树必定存在</p>
<p>简单路径（顶点不重复出现）</p>
<p>最短路径一定是简单路径</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps13.jpg" alt="img"> </p>
<p>简单路径：顶点不重复出现</p>
<p>最短路径一定是简单路径</p>
<p>Floyd算法求两个顶点的最短路径时，pathk-1不一定是pathk的子集。因为还要对原有顶点的各个路径进行判断，是否由新顶点更近</p>
<p>判断一个有向图是否有环（回路）</p>
<p>1、深度优先</p>
<p>2、拓扑排序（本身就是判断是否有回路）</p>
<p>3、关键路径（的前提是无环，有争议）</p>
<p>Prim算法：点</p>
<p>Krushal算法：边</p>
<h2 id="8-1、图的概念"><a href="#8-1、图的概念" class="headerlink" title="8.1、图的概念"></a>8.1、图的概念</h2><h3 id="1、图的定义"><a href="#1、图的定义" class="headerlink" title="1、图的定义"></a>1、图的定义</h3><p>图（Graph）G由顶点集合V(G)和边集合E(G)构成。</p>
<p>对于n个顶点的图，对每个顶点连续编号，，即顶点的编号为0~n-1。通过编号唯一确定一个顶点。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504103935453.png" alt="image-20220504103935453"> </p>
<h3 id="2、图的基本术语"><a href="#2、图的基本术语" class="headerlink" title="2、图的基本术语"></a>2、图的基本术语</h3><h4 id="①、端点和邻接点"><a href="#①、端点和邻接点" class="headerlink" title="①、端点和邻接点"></a>①、端点和邻接点</h4><p>无向图：若存在一条边(i,j)，顶点 i 和顶点 j 为端点，互为邻接点。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504104551916.png" alt="image-20220504104551916"> </p>
<p>有向图：若存在一条边&lt;i,j&gt;，顶点 i 为起始端点（起点），顶点 j 为终止端点（终点），互为邻接点。<br>                边&lt;i,j&gt;称为弧，i 为弧尾（tail），j 为弧头（head）</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504104602459.png" alt="image-20220504104602459"> </p>
<h4 id="②、-顶点的度、入度和出度"><a href="#②、-顶点的度、入度和出度" class="headerlink" title="②、 顶点的度、入度和出度"></a>②、 顶点的度、入度和出度</h4><p>无向图：与顶点 i 为端点的边数称为该顶点的度。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504104854120.png" alt="image-20220504104854120"> </p>
<p>有向图：与顶点 i 为终点的边数称为该顶点的入度；与顶点 i 为起点的边数称为该顶点的出度。出度与入度之和为该顶点的度。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504104907204.png" alt="image-20220504104907204"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504105013204.png" alt="image-20220504105013204"> </p>
<p>度之和是边数的2倍</p>
<h4 id="③、完全图"><a href="#③、完全图" class="headerlink" title="③、完全图"></a>③、完全图</h4><p>无向图：每两个顶点之间都存在一条边，称为完全无向图。包含$\frac{n(n-1)}{2}$条边。</p>
<p>有向图：每两个顶点之间都存在方向相反的两条边，称为完全有向图。包含${n(n-1)}$条边。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504105328481.png" alt="image-20220504105328481"> </p>
<h4 id="④、稀疏图、稠密图"><a href="#④、稀疏图、稠密图" class="headerlink" title="④、稀疏图、稠密图"></a>④、稀疏图、稠密图</h4><p>稀疏图：一个图含有较少的边数</p>
<p>稠密图：一个图接近完全图，但不是完全图</p>
<h4 id="⑤、子图"><a href="#⑤、子图" class="headerlink" title="⑤、子图"></a>⑤、子图</h4><p>设有两个图G &#x3D; (V，E)和G’ &#x3D;(V’ , E’)，V’是V的子集，E’是E的子集，则称G’是G的子集。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504105826544.png" alt="image-20220504105826544"> </p>
<h4 id="⑥、路径和路径长度"><a href="#⑥、路径和路径长度" class="headerlink" title="⑥、路径和路径长度"></a>⑥、路径和路径长度</h4><p>在一个</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504105934646.png" alt="image-20220504105934646"> </p>
<h4 id="⑦、回路或环"><a href="#⑦、回路或环" class="headerlink" title="⑦、回路或环"></a>⑦、回路或环</h4><p>回路或环：一条路径上的开始点和结束点为同一个顶点</p>
<p>简单回路或简单环：开始点和结束点相同的简单路径 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504110257288.png" alt="image-20220504110257288"> </p>
<h4 id="⑧、连通、连通图和连通分量"><a href="#⑧、连通、连通图和连通分量" class="headerlink" title="⑧、连通、连通图和连通分量"></a>⑧、连通、连通图和连通分量</h4><p>针对无向图</p>
<p>连通：无向图中从顶点 i 到顶点 j 有路径，则称 顶点 i 和 j 连通</p>
<p>连通图：任意两个顶点都连通（有路径，不一定有边直接相连）</p>
<p>连通分量：无向图的极大连通子图称为它的连通分量。连通图的连通分量只有一个，即本身。非连通图有多个连通分量。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504111200323.png" alt="image-20220504111200323"> </p>
<h4 id="⑨、强连通图和强连通分量"><a href="#⑨、强连通图和强连通分量" class="headerlink" title="⑨、强连通图和强连通分量"></a>⑨、强连通图和强连通分量</h4><p>有向图：从顶点 i 到顶点 j 有路径，则称 从顶点 i 到 j 是连通的</p>
<p>强连通图：任意两个顶点i 和 j 都连通，从i 到 j 和 从j 到i都存在路径。</p>
<p>强连通分量：有向图的极大连通子图称为它的连通分量。强连通图的强连通分量只有一个，即本身。非强连通图有多个强连通分量。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504111751944.png" alt="image-20220504111751944"> </p>
<p><strong>在一个非强连通图中找强连通分量</strong></p>
<ol>
<li>找到一个有向环</li>
<li>扩展该有向环：如果某个顶点到环中任一顶点有路径，并且该环中任一顶点到该顶点也有路径，则加入这个顶点。</li>
</ol>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504112059071.png" alt="image-20220504112059071"> </p>
<h4 id="⑩、权和网"><a href="#⑩、权和网" class="headerlink" title="⑩、权和网"></a>⑩、权和网</h4><p>权：每条边附带的数值，可以表示表示一个顶点到另一个顶点到的时间或花费</p>
<p>边上带有权的图称为<strong>带权图</strong>，或<strong>网</strong>。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504112257436.png" alt="image-20220504112257436"> </p>
<h2 id="8-2、图的存储结构和基本运算算法"><a href="#8-2、图的存储结构和基本运算算法" class="headerlink" title="8.2、图的存储结构和基本运算算法"></a>8.2、图的存储结构和基本运算算法</h2><p>图的逻辑结构要映射为图的存储结构，逻辑结构不涉及物理存储。</p>
<p>图的存储结构：存储每个顶点的信息，存储每条边的信息</p>
<p>图的两种存储结构：</p>
<ol>
<li>邻接矩阵</li>
<li>邻接表</li>
</ol>
<h3 id="1、邻接矩阵存储方法"><a href="#1、邻接矩阵存储方法" class="headerlink" title="1、邻接矩阵存储方法"></a>1、邻接矩阵存储方法</h3><p>一般采用顺序存储</p>
<h4 id="①、定义-1"><a href="#①、定义-1" class="headerlink" title="①、定义"></a>①、定义</h4><p>邻接矩阵是表示顶点之间相邻关系的矩阵。设 G &#x3D; (V , E)是具有n(n&gt;0)个顶点的图，顶点的编号一次为0~n-1。</p>
<p>G的邻接矩阵A是 n 阶方阵。其定义如下：</p>
<p>（1）无向图<br>            $若(i，j)\in E(G),A[i][j] &#x3D; 1:有边；A[i][j] &#x3D; 0:无边$</p>
<p>（2）有向图<br>            $若&lt;i，j&gt;\in E(G),A[i][j] &#x3D; 1:i到j有边；A[i][j] &#x3D; 0:无边$</p>
<p>（3）带权无向图			<br>            $若(i，j)\in E(G),A[i][j] &#x3D; w_{ij} \ \ 0:i&#x3D;j；\infty:其他$</p>
<p>（4）带权无向图			<br>            $若&lt;i，j&gt;\in E(G),A[i][j] &#x3D; w_{ij} \ \ 0:i&#x3D;j；\infty:其他$</p>
<p>无向图</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504114400573.png" alt="image-20220504114400573"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504114415100.png" alt="image-20220504114415100"> </p>
<p>邻接矩阵的特点：</p>
<ul>
<li>一个图的邻接矩阵表示是唯一的</li>
<li>适合稠密图的存储</li>
<li>邻接矩阵的存储空间为O(n<sup>2</sup>)</li>
</ul>
<h4 id="②、存储类型定义"><a href="#②、存储类型定义" class="headerlink" title="②、存储类型定义"></a>②、存储类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图的邻接矩阵存储类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXV <span class="string">&lt;最大顶点个数&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//声明顶点的类型</span></span><br><span class="line">    <span class="type">int</span> no; 			<span class="comment">//顶点编号</span></span><br><span class="line">    InfoType info;		<span class="comment">//顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明的邻接矩阵类型</span></span><br><span class="line"><span class="comment">//图的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> edges[MAXV][MAXV];	<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> n, e;				<span class="comment">//顶点数，边数</span></span><br><span class="line">    VertexType vexs[MAXV];	<span class="comment">//存放顶点信息</span></span><br><span class="line">&#125;MatGraph;</span><br></pre></td></tr></table></figure>

<h3 id="2、邻接表存储方法"><a href="#2、邻接表存储方法" class="headerlink" title="2、邻接表存储方法"></a>2、邻接表存储方法</h3><h4 id="①、定义-2"><a href="#①、定义-2" class="headerlink" title="①、定义"></a>①、定义</h4><ul>
<li>对图中的每个顶点都建立一个单链表，将该顶点的所有邻接点都连接起来</li>
<li>每个单链表添加一个表头（表示顶点信息）。并将所有表头结点构成一个数组，下标为i 的元素表示顶点i的表头结点。</li>
<li>图的邻接表存储方法是一种顺序存储与链式存储相结合的存储方法<ul>
<li>头结点顺序存储，边结点链式存储</li>
</ul>
</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504120843315.png" alt="image-20220504120843315"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504140837162.png" alt="image-20220504140837162"> </p>
<p><strong>邻接表的特点</strong></p>
<ul>
<li>邻接表不一致</li>
<li><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504140918776.png" alt="image-20220504140918776"> </li>
<li>存储空间为O(n+e)</li>
<li>适合于稀疏图存储</li>
</ul>
<p>逆邻接表</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504141943569.png" alt="image-20220504141943569"></p>
<h4 id="②、存储类型"><a href="#②、存储类型" class="headerlink" title="②、存储类型"></a>②、存储类型</h4><p>图的邻接表存储类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明边结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;		<span class="comment">//该边的终点编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> *<span class="title">nextarc</span>;</span>	<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;	<span class="comment">//该边的权值等信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明邻接表头结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Vertex data;	<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;	<span class="comment">//指向第一条边</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明图邻接表类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VNode adjlist[MAXV];	<span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> n, e;	<span class="comment">//图中顶点数n和边数e</span></span><br><span class="line">&#125;AdjGraph;</span><br></pre></td></tr></table></figure>

<p> <img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504141657987.png" alt="image-20220504141657987"></p>
<p><strong>邻接矩阵和邻接表的优缺点</strong>：</p>
<p>邻接矩阵的优点是可以快速判断两个顶点之间是否存在边，可以快速添加边或者删除边。而其缺点是如果顶点之间的边比较少，会比较浪费空间。因为是一个 n∗nn∗n 的矩阵。</p>
<p>而邻接表的优点是节省空间，只存储实际存在的边。其缺点是关注顶点的度时，就可能需要遍历一个链表。还有一个缺点是，对于无向图，如果需要删除一条边，就需要在两个链表上查找并删除。</p>
<h3 id="3、图基本运算算法设计"><a href="#3、图基本运算算法设计" class="headerlink" title="3、图基本运算算法设计"></a>3、图基本运算算法设计</h3><h4 id="①、创建图的运算算法"><a href="#①、创建图的运算算法" class="headerlink" title="①、创建图的运算算法"></a>①、创建图的运算算法</h4><p>根据邻接矩阵数组A、顶点个数n和边数e来建立图的邻接表G。（采用邻接表指针方式）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建图的邻接表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateAdj</span><span class="params">(AdjGraph *&amp;G, <span class="type">int</span> A[MAXV][MAXV], <span class="type">int</span> n, ine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;	<span class="comment">//给邻接表中所有头结点的指针域置初值</span></span><br><span class="line">        G-&gt;adjlist[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;	<span class="comment">//检查邻接矩阵中每个元素</span></span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j] != <span class="number">0</span> &amp;&amp; A[i][j] != INF) &#123;	<span class="comment">//存在一条边</span></span><br><span class="line">                p = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));	<span class="comment">//创建一个结点p</span></span><br><span class="line">                p-&gt;adjvex = j;	<span class="comment">//存放邻接点</span></span><br><span class="line">                p-&gt;weight = A[i][j];	<span class="comment">//存放权</span></span><br><span class="line">                p-&gt;nextarc = G-&gt;adjlist[i].firstarc;	<span class="comment">//采用头插法插入结点p</span></span><br><span class="line">                <span class="comment">//让p的nextarc指向 头结点刚刚指向的位置</span></span><br><span class="line">                <span class="comment">//再让头结点指向p</span></span><br><span class="line">                G-&gt;adjlist[i].firstarc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②、输出图的运算算法"><a href="#②、输出图的运算算法" class="headerlink" title="②、输出图的运算算法"></a>②、输出图的运算算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出邻接表G</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispAdj</span><span class="params">(AdjGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d[%d]→&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="③、销毁图的运算算法"><a href="#③、销毁图的运算算法" class="headerlink" title="③、销毁图的运算算法"></a>③、销毁图的运算算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyAdj</span><span class="params">(AdjGraph *&amp;G)</span>	<span class="comment">//销毁邻接表</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *pre, *p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;		<span class="comment">//扫描所有的单链表</span></span><br><span class="line">        pre = G-&gt;adjlist[i].firstarc;	<span class="comment">//pre指向第i个单链表的首结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = pre-&gt;nextarc;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;		<span class="comment">//释放第i个单链表的所有边结点</span></span><br><span class="line">                <span class="built_in">free</span>(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = pre-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(G);	<span class="comment">//释放头结点数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例题</strong></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504175405148.png" alt="image-20220504175405148"> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MatToList</span><span class="params">(MatGraph g, AdjGraph *&amp;G)</span></span><br><span class="line"><span class="comment">//将邻接矩阵g转换为邻接表G</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        G-&gt;adjlist[i].firstarc = <span class="literal">NULL</span>;	<span class="comment">//将邻接表中所有头结点的指针域置初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;		<span class="comment">//检查邻接矩阵的每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = g.n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != <span class="number">0</span> &amp;&amp; g.edges[i][j] != INF) &#123;	<span class="comment">//存在一条边</span></span><br><span class="line">                p = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));		<span class="comment">//建一个边结点</span></span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = g.edges[i][j];</span><br><span class="line">                p-&gt;nextarc = G-&gt;adjlist[i].firstarc;	<span class="comment">//采用头插法插入结点p</span></span><br><span class="line">                G-&gt;adjlist[i].firstarc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = g.n;</span><br><span class="line">    G-&gt;e = g.e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504180124222.png" alt="image-20220504180124222">  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListToMat</span><span class="params">(AdjGraph *G, MatGraph &amp;g)</span></span><br><span class="line"><span class="comment">//将邻接表G转换为邻接矩阵g</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;	<span class="comment">//扫描所有的单链表</span></span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;		<span class="comment">//p指向第i个单链表的首结点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            g.edges[i][p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.n = G-&gt;n;</span><br><span class="line">    g.e = G-&gt;e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504180704782.png" alt="image-20220504180704782"> </p>
<h3 id="4、图的其他存储方法"><a href="#4、图的其他存储方法" class="headerlink" title="4、图的其他存储方法"></a>4、图的其他存储方法</h3><h4 id="①、十字链表"><a href="#①、十字链表" class="headerlink" title="①、十字链表"></a>①、十字链表</h4><p>十字链表是有向图的另外一种存储结构，它是邻接表和逆邻接表的结合。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504181214554.png" alt="image-20220504181214554"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504181416383.png" alt="image-20220504181416383"> </p>
<h4 id="②、邻接多重表"><a href="#②、邻接多重表" class="headerlink" title="②、邻接多重表"></a>②、邻接多重表</h4><p>邻接多重表是无向图的另外一种存储结构，与十字链表类似。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504181628550.png" alt="image-20220504181628550"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220504182015539.png" alt="image-20220504182015539"> </p>
<h2 id="8-3、图的遍历"><a href="#8-3、图的遍历" class="headerlink" title="8.3、图的遍历"></a>8.3、图的遍历</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>从给定图中任意指定的顶点（称为初始点）出发，按照某种搜索方法沿着图的边访问图中的所有顶点，使每个顶点仅被访问一次，这个过程称为图的遍历。</p>
<p>图的遍历得到的顶点序列称为图遍历序列。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509152819840.png" alt="image-20220509152819840"> </p>
<p>根据搜索方法的不同，图的遍历方法有两种：</p>
<ul>
<li>深度优先遍历（DFS）<ul>
<li>深度优先搜索会沿着一条路径不断往下搜索直到不能再继续为止，然后再折返，开始搜索下一条候补路径。</li>
</ul>
</li>
<li>广度优先遍历（BFS）</li>
</ul>
<h3 id="2、深度优先遍历算法"><a href="#2、深度优先遍历算法" class="headerlink" title="2、深度优先遍历算法"></a>2、深度优先遍历算法</h3><p>深度优先遍历过程：</p>
<p>（1）从图中某个初始顶点v出发，首先访问初始顶点v。</p>
<p>（2）选择一个与顶点v相邻且没被访问过的顶点w，再从w出发进行深度优先搜索，直到图中与当前顶点v邻接的所有顶点都被访问过为止。</p>
<p><strong>算法设计思路：</strong></p>
<p>深度优先遍历的过程体现出<strong>后进先出</strong>的特点：用栈或递归方式实现。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509153932738.png" alt="image-20220509153932738"></p>
<p>如何确定一个顶点是否被访问过？设置一个<code>visited[]</code>全局数组，<code>visited[i]=0</code>表示顶点v没有访问；等于1表示已经访问过</p>
<p>采用邻接表的DFS算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    visited[v] = <span class="number">1</span>;	<span class="comment">//置已访问标记</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);	<span class="comment">//输出被访问顶点的编号</span></span><br><span class="line">    p = G-&gt;adjlist[v].firstarc;	<span class="comment">//p指向顶点v的第一条边的边头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        w = p-&gt;adjvex;	<span class="comment">//边结点的编号</span></span><br><span class="line">        <span class="keyword">if</span> (visited[w] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, w);	<span class="comment">//若W顶点未访问，递归访问它</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;nextarc;	<span class="comment">//p指向顶点v的下一条边的边头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509155333937.png"> </p>
<h3 id="3、广度优先遍历算法"><a href="#3、广度优先遍历算法" class="headerlink" title="3、广度优先遍历算法"></a>3、广度优先遍历算法</h3><p>广度优先遍历的过程：</p>
<p>（1）访问初始点v，节奏访问v的所有未被访问过的邻接点v<sub>1</sub>,v<sub>2</sub>,…v<sub>t</sub>。</p>
<p>（2）按照v<sub>1</sub>,v<sub>2</sub>,…v<sub>t</sub>的次序，访问每一个顶点的所有未被访问过的邻接点。</p>
<p>（3）依次类推，直到图中所有和初始点v有路径想通的顶点都被访问过为止。</p>
<p><strong>算法设计思路：</strong></p>
<p>广度优先遍历的过程体现出<strong>先进先出</strong>的特点：用<strong>队列</strong>实现。</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509161105059.png" alt="image-20220509161105059"></p>
<p>如何确定一个顶点是否被访问过？设置一个<code>visited[]</code>全局数组，<code>visited[i]=0</code>表示顶点v没有访问；等于1表示已经访问过</p>
<p>采用邻接表的BFS算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> w, i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    SqQueue *qu;	<span class="comment">//定义环形队列指针</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(qu);	<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="type">int</span> visited[MAXV];	<span class="comment">//定义顶点访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;	<span class="comment">//访问标记数组初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>, v);	<span class="comment">//输出被访问结点的编号</span></span><br><span class="line">    visited[v] = <span class="number">1</span>;		<span class="comment">//置已访问标记</span></span><br><span class="line">    <span class="built_in">enQueue</span>(qu, v);		<span class="comment">//让V进队</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">QueueEmpty</span>(qu))		<span class="comment">//队不空循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">deQueue</span>(qu, w);		<span class="comment">//出队一个顶点w</span></span><br><span class="line">        p = G-&gt;adjlist[w].firstarc;	<span class="comment">//指向w的第一个邻接点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)	<span class="comment">//查找w的所有邻接点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>)	<span class="comment">//若当前邻接点未被访问</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>, p-&gt;adjvex);	<span class="comment">//访问该邻接点</span></span><br><span class="line">         		visited[p-&gt;adjvex] = <span class="number">1</span>;		<span class="comment">//置已访问标记</span></span><br><span class="line">                <span class="built_in">enQueue</span>(qu, p-&gt;adjvex);		<span class="comment">//该顶点进队</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;		<span class="comment">//找下一个邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509163412556.png" alt="image-20220509163412556"> </p>
<h3 id="4、非连通图的遍历"><a href="#4、非连通图的遍历" class="headerlink" title="4、非连通图的遍历"></a>4、非连通图的遍历</h3><ul>
<li>无向连通图：调用一次DFS或BFS，能够访问到图中的所有顶点</li>
<li>无相非连通图：调用一次DFS或BFS，只能访问到初始点所在联通分量中的所有顶点，不可能访问到其他连通分量中的顶点。可以分别遍历每个连通分量，才能够访问到图中的所有顶点。</li>
</ul>
<p>采用广度优先遍历遍历非连通图的算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS1</span><span class="params">(AdjGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)	<span class="comment">//遍历所有未被访问过的顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">BFS</span>(G, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非连通图：调用BFS()的次数恰好等于连通分量的个数</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509164258769.png" alt="image-20220509164258769"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509164439582.png" alt="image-20220509164439582"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509164506200.png" alt="image-20220509164506200"> </p>
<h2 id="8-4、生成树和最小生成树"><a href="#8-4、生成树和最小生成树" class="headerlink" title="8.4、生成树和最小生成树"></a>8.4、生成树和最小生成树</h2><h3 id="1、生成树的概念"><a href="#1、生成树的概念" class="headerlink" title="1、生成树的概念"></a>1、生成树的概念</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509164831118.png" alt="image-20220509164831118"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509165121272.png" alt="image-20220509165121272"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509165128684.png" alt="image-20220509165128684"> </p>
<p>最小生成树的概念：</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509165226936.png" alt="image-20220509165226936"> </p>
<h3 id="2、非连通图和生成树"><a href="#2、非连通图和生成树" class="headerlink" title="2、非连通图和生成树"></a>2、非连通图和生成树</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509171745984.png" alt="image-20220509171745984">   </p>
<h3 id="3、普里姆算法"><a href="#3、普里姆算法" class="headerlink" title="3、普里姆算法"></a>3、普里姆算法</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509172458434.png" alt="image-20220509172458434"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509173010636.png" alt="image-20220509173010636"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509173739332.png" alt="image-20220509173739332"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509173946932.png" alt="image-20220509173946932"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174002829.png" alt="image-20220509174002829"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174022264.png" alt="image-20220509174022264"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174035459.png" alt="image-20220509174035459"> </p>
<h3 id="4、克鲁斯卡尔算法"><a href="#4、克鲁斯卡尔算法" class="headerlink" title="4、克鲁斯卡尔算法"></a>4、克鲁斯卡尔算法</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174109174.png" alt="image-20220509174109174"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174126383.png" alt="image-20220509174126383"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174135039.png" alt="image-20220509174135039"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174231260.png" alt="image-20220509174231260"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174239167.png" alt="image-20220509174239167"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174247474.png" alt="image-20220509174247474"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174258722.png" alt="image-20220509174258722"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174310847.png" alt="image-20220509174310847"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174335574.png" alt="image-20220509174335574"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174348675.png" alt="image-20220509174348675"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174403187.png" alt="image-20220509174403187"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174417743.png" alt="image-20220509174417743"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174428749.png" alt="image-20220509174428749"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174440302.png" alt="image-20220509174440302"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220509174455323.png" alt="image-20220509174455323"></p>
<h2 id="8-5、最短路径"><a href="#8-5、最短路径" class="headerlink" title="8.5、最短路径"></a>8.5、最短路径</h2><h3 id="1、路径的概念"><a href="#1、路径的概念" class="headerlink" title="1、路径的概念"></a>1、路径的概念</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102039773.png" alt="image-20220511102039773"></p>
<h3 id="2、从一个顶点到其余各顶点的最短路径"><a href="#2、从一个顶点到其余各顶点的最短路径" class="headerlink" title="2、从一个顶点到其余各顶点的最短路径"></a>2、从一个顶点到其余各顶点的最短路径</h3><p>单源最短路径问题：Dijkstra算法</p>
<p>问题描述：给定一个带权有向图G与源点v，求从v到G中其他顶点的最短路径，并限定各边上的权值大于或等于0.</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102119621.png" alt="image-20220511102119621"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102318940.png" alt="image-20220511102318940"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102343523.png" alt="image-20220511102343523"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102350987.png" alt="image-20220511102350987"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102358743.png" alt="image-20220511102358743"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102410532.png" alt="image-20220511102410532"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102420210.png" alt="image-20220511102420210"></p>
<p>算法设计（解决2个问题）</p>
<ul>
<li>存放最短路径</li>
</ul>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102439266.png" alt="image-20220511102439266"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102456385.png" alt="image-20220511102456385"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102509575.png" alt="image-20220511102509575"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102551920.png" alt="image-20220511102551920"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102610247.png" alt="image-20220511102610247"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102627857.png" alt="image-20220511102627857"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102647776.png" alt="image-20220511102647776"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102713721.png" alt="image-20220511102713721"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102724770.png" alt="image-20220511102724770"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102742984.png" alt="image-20220511102742984"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511102948722.png" alt="image-20220511102948722"> </p>
<h2 id="8-6、拓扑排序"><a href="#8-6、拓扑排序" class="headerlink" title="8.6、拓扑排序"></a>8.6、拓扑排序</h2><p>AOV网是有向无环图</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103011043.png" alt="image-20220511103011043"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103019840.png" alt="image-20220511103019840"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103030076.png" alt="image-20220511103030076"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103213539.png" alt="image-20220511103213539"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103222239.png" alt="image-20220511103222239"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103247960.png" alt="image-20220511103247960"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103257749.png" alt="image-20220511103257749"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103316292.png" alt="image-20220511103316292"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103322658.png" alt="image-20220511103322658"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103331936.png" alt="image-20220511103331936"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103339002.png" alt="image-20220511103339002"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103353804.png" alt="image-20220511103353804"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103400761.png" alt="image-20220511103400761"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103410064.png" alt="image-20220511103410064"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103418843.png" alt="image-20220511103418843"> </p>
<h2 id="8-7、AOE网"><a href="#8-7、AOE网" class="headerlink" title="8.7、AOE网"></a>8.7、AOE网</h2><h3 id="1、AOE"><a href="#1、AOE" class="headerlink" title="1、AOE"></a>1、AOE</h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103447552.png" alt="image-20220511103447552"></p>
<h3 id="2、关键路径"><a href="#2、关键路径" class="headerlink" title="2、关键路径"></a>2、关键路径</h3><p>从AOE网中源点到汇点的最长路径，具有最大长度的路径叫关键路径</p>
<p>关键路径是由关键活动构成的，关键路径可能不唯一。 </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103513116.png" alt="image-20220511103513116"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103523636.png" alt="image-20220511103523636"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103537133.png" alt="image-20220511103537133"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103553020.png" alt="image-20220511103553020"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103611913.png" alt="image-20220511103611913"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103622128.png" alt="image-20220511103622128"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103633222.png" alt="image-20220511103633222"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103647320.png" alt="image-20220511103647320"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103716614.png" alt="image-20220511103716614"></p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103658852.png" alt="image-20220511103658852"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103806632.png" alt="image-20220511103806632"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103823863.png" alt="image-20220511103823863"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103841173.png" alt="image-20220511103841173"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220511103851483.png" alt="image-20220511103851483"> </p>
<h1 id="七、查找"><a href="#七、查找" class="headerlink" title="七、查找"></a>七、查找</h1><h3 id="7-2、顺序查找和折半查找"><a href="#7-2、顺序查找和折半查找" class="headerlink" title="7.2、顺序查找和折半查找"></a><strong>7.2、顺序查找和折半查找</strong></h3><p>折半查找的判定树是平衡二叉树</p>
<p>折半查找判定树高度为<img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps14.jpg" alt="img"></p>
<h3 id="7-3、树形查找"><a href="#7-3、树形查找" class="headerlink" title="7.3、树形查找"></a><strong>7.3、树形查找</strong></h3><p>二叉排序树BST</p>
<p>平衡二叉树AVL</p>
<p>二叉排序树的删除和平衡二叉树的插入可能导致树的分裂组合</p>
<p>二叉排序树，查找失败时直接在失败处插入，不会导致树的分裂组合</p>
<p>二叉排序树进行中序遍历可以得到有序数列</p>
<p>平衡二叉树深度<img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps15.jpg" alt="img"></p>
<p>C1&#x3D;1</p>
<p>C2&#x3D;2</p>
<p>C3&#x3D;C1+C2+1&#x3D;4</p>
<p>C4&#x3D;C2+C3+1&#x3D;7</p>
<p>C5&#x3D;C3+C4+1&#x3D;12</p>
<p>C6&#x3D;C4+C5+1&#x3D;20</p>
<p>红黑树插入最多旋转两次，删除最多旋转3次</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps16.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps17.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps18.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps19.jpg" alt="img"> </p>
<p>LL型，父和爷都染色</p>
<p>RR型，父和爷都染色</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps20.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps21.jpg" alt="img"> </p>
<p>红黑树是排序树，不一定是平衡二叉树，</p>
<p>红黑树的所有结点都是黑色的，那么它一定是满二叉树</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps22.jpg" alt="img"> </p>
<h3 id="7-4、B树和B-树"><a href="#7-4、B树和B-树" class="headerlink" title="7.4、B树和B+树"></a><strong>7.4、B树和B+树</strong></h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps23.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps24.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps25.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps26.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps27.jpg" alt="img"> </p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps28.jpg" alt="img"> </p>
<p>插入关键字，已达上限还要加时必须分裂</p>
<p>删除关键字，已至下限还要减时必须合并</p>
<p>具有n个关键字的m阶B树，应有N+1个叶节点</p>
<p>B树中，叶节点指最下面的空节点（不画的结点），查找失败的结点</p>
<p>中断结点是倒数第二层的结点</p>
<p>B树逻辑上是一棵树，不支持顺序查找</p>
<p>B+树支持顺序查找</p>
<p>B+树应用：OS的文件索引和数据库索引</p>
<p>编译器的词法分析使用有穷自动机和语法树</p>
<p>网络中的路由表快速查找主要靠高速缓存、路由表压缩技术和快速查找算法</p>
<p>系统一般采用空闲空间链表管理磁盘空闲块</p>
<h3 id="7-5、散列表"><a href="#7-5、散列表" class="headerlink" title="7.5、散列表"></a><strong>7.5、散列表</strong></h3><p>装填因子α：表中记录&#x2F;散列表长度</p>
<p>存储效率：哈希表中实际存储的元素个数与哈希表长度的比值</p>
<p>散列表在查找成功时的平均查找长度与表长无关</p>
<p>若在散列表中删除一个元素，不能简单地将该元素删除</p>
<p>再散列法处理冲突时不易产生聚集（两个散列函数）</p>
<p>链地址法处理冲突时不会产生聚集</p>
<h2 id="9-1、"><a href="#9-1、" class="headerlink" title="9.1、"></a>9.1、</h2><h2 id="9-4、哈希表的查找"><a href="#9-4、哈希表的查找" class="headerlink" title="9.4、哈希表的查找"></a>9.4、哈希表的查找</h2><h3 id="1、哈希表的概念"><a href="#1、哈希表的概念" class="headerlink" title="1、哈希表的概念"></a>1、哈希表的概念</h3><h4 id="①、哈希表适合情况"><a href="#①、哈希表适合情况" class="headerlink" title="①、哈希表适合情况"></a>①、哈希表适合情况</h4><p>哈希表是一种存储结构，并非适合所有情况，主要适合记录的关键字与存储地址存在某种函数关系的数据。</p>
<h4 id="②、几个概念"><a href="#②、几个概念" class="headerlink" title="②、几个概念"></a>②、几个概念</h4><p>哈希表：长度为m的连续存储单元</p>
<p>哈希地址：哈希表中的位置</p>
<p>哈希函数：把关键字为k<sub>i</sub>的对象存放在相应的哈希地址中</p>
<p>哈希冲突：对于两个关键字分别为ki和kj（i≠j）的记录，有ki≠kj，但h(ki)&#x3D;h(kj)。把这种现象叫做哈希冲突（同义词冲突）。</p>
<h4 id="③、哈希表设计"><a href="#③、哈希表设计" class="headerlink" title="③、哈希表设计"></a>③、哈希表设计</h4><p> 哈希表主要用来解决哈希冲突</p>
<ul>
<li>与装填因子有关。装填因子α&#x3D;存储的记录个数&#x2F;哈希表的大小&#x3D;n&#x2F;m  α越小，冲突的可能性就越小； α越大（最大可取1），冲突的可能性就越大。通常使最终的控制在0.6～0.9的范围内。</li>
<li>与所采用的哈希函数有关。好的哈希函数会减少冲突的发生；不好的哈希函数会增加冲突的发生。</li>
<li>与解决冲突方法有关。好的哈希冲突解决方法会减少冲突的发生。</li>
</ul>
<h1 id="十一、数组的查找"><a href="#十一、数组的查找" class="headerlink" title="十一、数组的查找"></a>十一、数组的查找</h1><h2 id="11-1、线性查找"><a href="#11-1、线性查找" class="headerlink" title="11.1、线性查找"></a>11.1、线性查找</h2><p>线性查找就是在数组中从头开始依次往下查找</p>
<p>时间复杂度为O(n)</p>
<h2 id="11-2、二分查找"><a href="#11-2、二分查找" class="headerlink" title="11.2、二分查找"></a>11.2、二分查找</h2><p>二分查找是一种在数组中查找数据的方法。</p>
<p>二分查找只能在已排好序的数组中进行查找，时间复杂度为O(log n)，</p>
<p>虽然比线性查找速度更快，但二分查找必须在已排好序的数组中查找，相比线性查找需要更多的时间去维护</p>
<p>二分查找的条件：在一个已排好序的数组中找到一个元素</p>
<p>[left, right]，需要设置一个中间量mid&#x3D;left + (right-left)&#x2F;2，int类型防止溢出</p>
<p>如果mid比查找的值大，表示查找的值在mid的左边，右边界right &#x3D; mid-1,再次取半，查找<br>如果mid比查找的值小，表示查找的值在mid的右边，左边界left &#x3D; mid + 1，取半，查找</p>
<h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><p>稳定排序：冒泡排序、插入排序、归并排序、基数排序</p>
<p>不稳定排序：希尔排序、快速排序、堆排序、选择排序</p>
<h2 id="8-1、排序的基本概念"><a href="#8-1、排序的基本概念" class="headerlink" title="8.1、排序的基本概念"></a><strong>8.1、排序的基本概念</strong></h2><p>排序算法的稳定性与优劣无关</p>
<p>排序算法：顺序表，链表都可实现。但是如果应用了随机存取特性，就不能在链表上实现</p>
<h2 id="8-2、冒泡排序"><a href="#8-2、冒泡排序" class="headerlink" title="8.2、冒泡排序"></a>8.2、冒泡排序</h2><p>冒泡排序就是重复“从序列右边开始比较相邻两个元素的大小，再根据结果交换两个元素的位置”这一操作的算法</p>
<p>第一轮比较n-1次，第二轮比较n-2次，第n-1轮比较1次。</p>
<p>总的比较次数约为$\frac{n^2}{2}$，时间复杂度为$O(n^2)$</p>
<h2 id="8-3、选择排序"><a href="#8-3、选择排序" class="headerlink" title="8.3、选择排序"></a>8.3、选择排序</h2><ol>
<li>从待排序的数据中寻找最值，</li>
<li>将最值放在前面有序部分的末尾</li>
</ol>
<p>时间复杂度为$O(n^2)$</p>
<h2 id="8-4、插入排序"><a href="#8-4、插入排序" class="headerlink" title="8.4、插入排序"></a>8.4、插入排序</h2><p>插入排序是一种从序列左端开始依次对数据进行排序的算法。</p>
<p>插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内的合适位置上</p>
<p>主要的插入排序方法：<br>（1）直接插入排序<br>（2）折半插入排序<br>（3）希尔排序</p>
<h3 id="1、直接插入排序"><a href="#1、直接插入排序" class="headerlink" title="1、直接插入排序"></a>1、直接插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)	<span class="comment">//每次排好一个数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//从第二个数开始排，这个数之前的数都是排好的，</span></span><br><span class="line">		<span class="comment">//只要它比之前的数小，就要插入；不小于的话，直接进行下一个数</span></span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>])	</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将待插入的数保存到temp中，它一定在左边某两个数之间</span></span><br><span class="line">			temp = arr[i];</span><br><span class="line">			j = i - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//将排好的数右移，直到发现比待插入的temp小的数</span></span><br><span class="line">				arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">				j--;</span><br><span class="line">			&#125; <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp);</span><br><span class="line">			<span class="comment">//插入temp</span></span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">insertSort</span>(arr, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、折半插入排序"><a href="#2、折半插入排序" class="headerlink" title="2、折半插入排序"></a>2、折半插入排序</h3><p>先对已经排序的算法进行折半比较，再进行插入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, low, high, mid;</span><br><span class="line">    <span class="comment">// A[]数组为A[0]~A[n],A[0]放置比较值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)	<span class="comment">// 依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">    &#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];			<span class="comment">// A[0]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;	<span class="comment">// 取中间点</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; A[<span class="number">0</span>])</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;	<span class="comment">// 找到排序位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j)</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];		<span class="comment">// 统一后移元素，空出插入位置</span></span><br><span class="line">        A[high + <span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、希尔排序"><a href="#3、希尔排序" class="headerlink" title="3、希尔排序"></a>3、希尔排序</h3><p>希尔排序的组内排序采用的是直接插入排序</p>
<h2 id="8-5、堆排序"><a href="#8-5、堆排序" class="headerlink" title="8.5、堆排序"></a>8.5、堆排序</h2><p>排序就是利用了数据结构中的堆。</p>
<p>将一组数据构建堆，取出数据，重新构造堆。</p>
<p>堆排序一开始需要将n个数据存进堆中，所需时间为<em>*<em>O</em>(<em>n</em>log*n</em>)**</p>
<p>插入数据<em>*<em>O</em>(log*n</em>)**</p>
<p>时间复杂度<em>*<em>O</em>(<em>n</em>log*n</em>)**</p>
<p>建堆的时间复杂度：O(n)</p>
<p>O(log2n):堆排、快排、归并、快排最好</p>
<p>n个记录堆排：建堆、取堆顶，重排</p>
<p>建堆：O（N）</p>
<p>单次删除O(log2n)</p>
<p>时间复杂度O（nlogn)</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps1.jpg" alt="img"></p>
<h2 id="8-6、归并排序"><a href="#8-6、归并排序" class="headerlink" title="8.6、归并排序"></a>8.6、归并排序</h2><p>归并排序会把序列分成长度相同的两个子序列，当无法继续往下分时，就对子序列进行排序。</p>
<p>归并指的是把两个排好的子序列合并成一个有序序列。该操作会一直重复进行，直到所有子序列都归并为一个整体为止。</p>
<p>时间复杂度O(nlog<em>n</em>)</p>
<p>归并排序既是内部排序，又是外部排序</p>
<h2 id="8-7、基数排序"><a href="#8-7、基数排序" class="headerlink" title="8.7、基数排序"></a>8.7、基数排序</h2><p>基数排序必须为整数</p>
<h2 id="8-8、快速排序"><a href="#8-8、快速排序" class="headerlink" title="8.8、快速排序"></a>8.8、快速排序</h2><p>当基本有序时，反而不好</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>快速排序其实就是从一组数中选出一个数（基准数）</li>
<li>小于基准数的放左边，大于基准数的放右边，一次操作结束</li>
<li>然后重复操作第二步，直到所有的数据都已排好</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以一个一维数组a[10]为例，取第一个数为<strong>基准数</strong></p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>72</td>
<td>6</td>
<td>57</td>
<td>88</td>
<td>60</td>
<td>42</td>
<td>83</td>
<td>73</td>
<td>48</td>
<td>85</td>
</tr>
</tbody></table>
<p>1.此时将 基准值赋值为 <code>x = a[0]</code><br>2.设<code>left = 0, right = 9</code>进行计算<br>3.从右边开始向前 和 基准数 比较大小<br>大于基准数，<code>right--</code>;大于基准数，暂停，将这个数赋给左边<code>a[left]</code>下的数<code>a[left] = a[right]</code><br>4.然后从左边开始和基准数进行比较，<br>小于基准数，<code>left++</code>;大于基准数，暂停，将这个数赋给刚刚从右边比较暂停的数，<code>a[right] = a[left]</code><br>5.循环上两步操作<br>6.直到<code>left &gt;= right</code>,将基准值赋给<code>a[left]</code>,一次排序结束，将基准值插入到正确的位置上，<br>7.重复以上操作，直到所有的数据都已排好<br><strong>一次操作</strong><br><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2510762-20220326104341352-1854258240.png"><br><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2510762-20220326104604748-268284983.png"><br>此时基准值在正确的位置上，左边都小于基准值，右边都大于基准值，递归重复此类操作</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">if</span>(left &lt;right)    </span><br><span class="line">&#123;        <span class="comment">//最后需要递归操作，从left到基准值，基准值到right，        </span></span><br><span class="line">        <span class="comment">//left和right是变化的，所以需要保存下来        </span></span><br><span class="line">        <span class="type">int</span> L = left, R =right;        <span class="type">int</span> x = a[left];    <span class="comment">//基准值        </span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)        </span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; a[right] &gt;= x)    <span class="comment">//从右边找第一个小于基准值的数            </span></span><br><span class="line">            &#123;                </span><br><span class="line">                right--;            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)            </span><br><span class="line">            &#123;                </span><br><span class="line">                a[left] = a[right];             </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; a[left] &lt;= x) <span class="comment">//从左边寻找            </span></span><br><span class="line">            &#123;                </span><br><span class="line">                left++;            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)            </span><br><span class="line">            &#123;                </span><br><span class="line">                a[right] = a[left];            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right)   <span class="comment">//将基准值赋到正确的位置上            </span></span><br><span class="line">            &#123;                </span><br><span class="line">                a[left] = x;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        QuickSort(a, L, left<span class="number">-1</span>);    <span class="comment">//递归操作        </span></span><br><span class="line">        QuickSort(a, left+<span class="number">1</span>, R);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n log<em>n</em>)</p>
<h3 id="8-6、各种内部排序算法的比较和应用"><a href="#8-6、各种内部排序算法的比较和应用" class="headerlink" title="8.6、各种内部排序算法的比较和应用"></a><strong>8.6、各种内部排序算法的比较和应用</strong></h3><p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps2.jpg" alt="img"> </p>
<p>归并排序的代码比插入排序的代码更为复杂</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps3.jpg" alt="img"> </p>
<p>堆是用于排序的，不可以查找</p>
<h3 id="8-7、外部排序"><a href="#8-7、外部排序" class="headerlink" title="8.7、外部排序"></a><strong>8.7、外部排序</strong></h3><p>置换-选择排序用于生成外排序的初始归并段</p>
<p>初始归并段不定长</p>
<p>最佳归并树设计m路归并排序的优化方案</p>
<p>m路平衡归并排序，m个输入缓冲，1个输出缓冲</p>
<p>为实现输入&#x2F;内部归并&#x2F;输出的并行处理，设置2m个输入缓冲，2个输出缓冲</p>
<p><img src="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/wps4.jpg" alt="img"> </p>

    </div>

    
    
    

    
        <div>
             <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

        </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>李新乾
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">http://example.com/2024/07/07/计算机基础/数据结构/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"># 计算机基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%20-%20%E5%89%AF%E6%9C%AC%20(2)/" rel="prev" title="编译原理(2)">
      <i class="fa fa-chevron-left"></i> 编译原理(2)
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="next" title="数据库">
      数据库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC82MDA0OC8zNjUxNA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BB%AA%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">一、绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、数据结构的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1、基本概念和术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2、数据结构的三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1、逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">2、存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、数据类型和抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1、数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2%E3%80%81%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2、抽象数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E3%80%81%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">1.3、算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1、算法的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2、时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3、空间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">二、线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%BF%90%E7%AE%97"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、知识结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2、顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%BF%90%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">2、运算的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.3.</span> <span class="nav-text">3、基本运算算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.2.4.</span> <span class="nav-text">4、算法设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">2.3、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.2.</span> <span class="nav-text">2、单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E5%92%8C%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">①、插入结点和删除结点操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">②、建立单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">③、线性表基本运算在单链表上的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">④、单链表的算法设计方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.3.</span> <span class="nav-text">3、双链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">①、双链表中结点的插入和删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%BB%BA%E7%AB%8B%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">②、建立双链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%9C%A8%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">③、线性表基本运算在双链表中的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.4.</span> <span class="nav-text">4、循环链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">①循环单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">②、循环双链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4%E3%80%81%E5%BA%94%E7%94%A8"><span class="nav-number">2.4.</span> <span class="nav-text">2.4、应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">三、栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E6%A0%88"><span class="nav-number">3.0.1.</span> <span class="nav-text">3.1、栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E9%98%9F%E5%88%97"><span class="nav-number">3.0.2.</span> <span class="nav-text">3.2、队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E3%80%81%E6%A0%88-1"><span class="nav-number">3.1.</span> <span class="nav-text">3.1、栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-3"><span class="nav-number">3.1.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">2、栈的顺序存储结构及其基本运算实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.3.</span> <span class="nav-text">3、栈的链式存储结构及其基本运算的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%BA%94%E7%94%A8"><span class="nav-number">3.1.4.</span> <span class="nav-text">4、应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">3.1.4.0.1.</span> <span class="nav-text">简单表达式求值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%93%BE%E6%A0%88"><span class="nav-number">3.1.5.</span> <span class="nav-text">5、链栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E3%80%81%E9%98%9F%E5%88%97-1"><span class="nav-number">3.2.</span> <span class="nav-text">3.2、队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-4"><span class="nav-number">3.2.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.2.</span> <span class="nav-text">2、顺序队及实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="nav-number">3.2.3.</span> <span class="nav-text">3、环形队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E9%93%BE%E9%98%9F"><span class="nav-number">3.2.4.</span> <span class="nav-text">4、链队</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">六、数组和广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">4.1.</span> <span class="nav-text">6.1、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.1.</span> <span class="nav-text">1、基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.2.</span> <span class="nav-text">2、数组的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E4%BB%A5%E8%A1%8C%E5%BA%8F%E4%B8%BA%E4%B8%BB%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">①、以行序为主序的存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E4%BB%A5%E5%88%97%E5%BA%8F%E4%B8%BA%E4%B8%BB%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">②、以列序为主序的存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">4.1.3.</span> <span class="nav-text">3、特殊矩阵的压缩存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">①、对称矩阵的压缩存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">②、三角矩阵的压缩存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">③、对角矩阵的压缩存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2%E3%80%81%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.</span> <span class="nav-text">6.2、稀疏矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">4.3.</span> <span class="nav-text">6.3、广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89-5"><span class="nav-number">4.3.1.</span> <span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">2、存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-number">4.3.3.</span> <span class="nav-text">3、广义表的运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">①、广义表算法设计方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">②、广义表基本算法设计</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">五、树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E3%80%81%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">5.0.1.</span> <span class="nav-text">5.1、树的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.0.2.</span> <span class="nav-text">5.2、二叉树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.0.3.</span> <span class="nav-text">5.3、二叉树的遍历和线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%E3%80%81%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="nav-number">5.0.4.</span> <span class="nav-text">5.4、树、森林</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">5.0.5.</span> <span class="nav-text">5.5、树与二叉树的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E3%80%81%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">7.1、树的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.1.</span> <span class="nav-text">1、树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E8%A1%A8%E7%A4%BA"><span class="nav-number">5.1.2.</span> <span class="nav-text">2、树的逻辑表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">5.1.3.</span> <span class="nav-text">3、树的基本术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">5.1.4.</span> <span class="nav-text">4、树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="nav-number">5.1.5.</span> <span class="nav-text">5、树的基本运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.6.</span> <span class="nav-text">6、树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%8F%8C%E4%BA%B2%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.6.1.</span> <span class="nav-text">①、双亲存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%AD%A9%E5%AD%90%E9%93%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.6.2.</span> <span class="nav-text">②、孩子链存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E9%93%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.6.3.</span> <span class="nav-text">③、孩子兄弟链存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.2.</span> <span class="nav-text">7.2、二叉树的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.2.1.</span> <span class="nav-text">1、二叉树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.2.2.</span> <span class="nav-text">2、两种特殊的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">①、满二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">②、完全二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-number">5.2.3.</span> <span class="nav-text">3、二叉树性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.2.4.</span> <span class="nav-text">4、二叉树与树、森林之间的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E6%A3%AE%E6%9E%97%E3%80%81%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">①、森林、树转换为二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E4%B8%BA%E6%A3%AE%E6%9E%97%E3%80%81%E6%A0%91"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">②、二叉树还原为森林、树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">7.3、二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.1.</span> <span class="nav-text">1、二叉树的顺序存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.2.</span> <span class="nav-text">2、二叉树的链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.4.</span> <span class="nav-text">7.4、二叉树基本运算及其实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E6%A6%82%E8%BF%B0"><span class="nav-number">5.4.1.</span> <span class="nav-text">1、二叉树的基本运算概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.4.2.</span> <span class="nav-text">2、二叉树的基本运算算法实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">5.5.</span> <span class="nav-text">7.5、二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.5.1.</span> <span class="nav-text">1、二叉树遍历的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">①、先序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">5.5.1.2.</span> <span class="nav-text">②、中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">5.5.1.3.</span> <span class="nav-text">③、后序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%913%E7%A7%8D%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.2.</span> <span class="nav-text">2、二叉树3种遍历的递归算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%913%E7%A7%8D%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.3.</span> <span class="nav-text">3、二叉树3种遍历的非递归算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%951"><span class="nav-number">5.5.3.1.</span> <span class="nav-text">①、先序遍历非递归算法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%952"><span class="nav-number">5.5.3.2.</span> <span class="nav-text">②、先序遍历非递归算法2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.3.3.</span> <span class="nav-text">③、中序遍历非递归算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.3.4.</span> <span class="nav-text">④、后序遍历非递归算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.4.</span> <span class="nav-text">4、层次遍历算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">5.6.</span> <span class="nav-text">7.6、二叉树的构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.7.</span> <span class="nav-text">7.7、线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.7.1.</span> <span class="nav-text">1、线索二叉树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.7.2.</span> <span class="nav-text">2、线索化二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E5%90%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.7.3.</span> <span class="nav-text">3、遍历线索后二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">5.8.</span> <span class="nav-text">7.8、哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.8.1.</span> <span class="nav-text">1、最优二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">5.8.1.1.</span> <span class="nav-text">①、定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%9E%84%E9%80%A0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">5.8.2.</span> <span class="nav-text">2、构造赫夫曼树的原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">5.8.3.</span> <span class="nav-text">3、构造赫夫曼树的过程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Huffman%E7%BC%96%E7%A0%81"><span class="nav-number">5.8.4.</span> <span class="nav-text">4、Huffman编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%9B%BE"><span class="nav-number">6.</span> <span class="nav-text">六、图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%E3%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">6.0.1.</span> <span class="nav-text">6.1、图的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">6.0.2.</span> <span class="nav-text">6.3、图的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4%E3%80%81%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">6.0.3.</span> <span class="nav-text">6.4、图的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1%E3%80%81%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">8.1、图的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">6.1.1.</span> <span class="nav-text">1、图的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">6.1.2.</span> <span class="nav-text">2、图的基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E7%AB%AF%E7%82%B9%E5%92%8C%E9%82%BB%E6%8E%A5%E7%82%B9"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">①、端点和邻接点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81-%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6%E3%80%81%E5%85%A5%E5%BA%A6%E5%92%8C%E5%87%BA%E5%BA%A6"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">②、 顶点的度、入度和出度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="nav-number">6.1.2.3.</span> <span class="nav-text">③、完全图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E3%80%81%E7%A8%80%E7%96%8F%E5%9B%BE%E3%80%81%E7%A8%A0%E5%AF%86%E5%9B%BE"><span class="nav-number">6.1.2.4.</span> <span class="nav-text">④、稀疏图、稠密图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E3%80%81%E5%AD%90%E5%9B%BE"><span class="nav-number">6.1.2.5.</span> <span class="nav-text">⑤、子图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5%E3%80%81%E8%B7%AF%E5%BE%84%E5%92%8C%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="nav-number">6.1.2.6.</span> <span class="nav-text">⑥、路径和路径长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A6%E3%80%81%E5%9B%9E%E8%B7%AF%E6%88%96%E7%8E%AF"><span class="nav-number">6.1.2.7.</span> <span class="nav-text">⑦、回路或环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A7%E3%80%81%E8%BF%9E%E9%80%9A%E3%80%81%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%92%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">6.1.2.8.</span> <span class="nav-text">⑧、连通、连通图和连通分量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A8%E3%80%81%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%92%8C%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">6.1.2.9.</span> <span class="nav-text">⑨、强连通图和强连通分量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A9%E3%80%81%E6%9D%83%E5%92%8C%E7%BD%91"><span class="nav-number">6.1.2.10.</span> <span class="nav-text">⑩、权和网</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">8.2、图的存储结构和基本运算算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.1.</span> <span class="nav-text">1、邻接矩阵存储方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%AE%9A%E4%B9%89-1"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">①、定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">②、存储类型定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.2.</span> <span class="nav-text">2、邻接表存储方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%AE%9A%E4%B9%89-2"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">①、定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">②、存储类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%9B%BE%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.2.3.</span> <span class="nav-text">3、图基本运算算法设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%88%9B%E5%BB%BA%E5%9B%BE%E7%9A%84%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.3.1.</span> <span class="nav-text">①、创建图的运算算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E8%BE%93%E5%87%BA%E5%9B%BE%E7%9A%84%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.3.2.</span> <span class="nav-text">②、输出图的运算算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E9%94%80%E6%AF%81%E5%9B%BE%E7%9A%84%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.3.3.</span> <span class="nav-text">③、销毁图的运算算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%9B%BE%E7%9A%84%E5%85%B6%E4%BB%96%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.4.</span> <span class="nav-text">4、图的其他存储方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-number">6.2.4.1.</span> <span class="nav-text">①、十字链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-number">6.2.4.2.</span> <span class="nav-text">②、邻接多重表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">6.3.</span> <span class="nav-text">8.3、图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="nav-number">6.3.1.</span> <span class="nav-text">1、概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.2.</span> <span class="nav-text">2、深度优先遍历算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">3、广度优先遍历算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">6.3.4.</span> <span class="nav-text">4、非连通图的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4%E3%80%81%E7%94%9F%E6%88%90%E6%A0%91%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">6.4.</span> <span class="nav-text">8.4、生成树和最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">6.4.1.</span> <span class="nav-text">1、生成树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%92%8C%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">6.4.2.</span> <span class="nav-text">2、非连通图和生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.3.</span> <span class="nav-text">3、普里姆算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.4.</span> <span class="nav-text">4、克鲁斯卡尔算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">6.5.</span> <span class="nav-text">8.5、最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">6.5.1.</span> <span class="nav-text">1、路径的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%A1%B6%E7%82%B9%E5%88%B0%E5%85%B6%E4%BD%99%E5%90%84%E9%A1%B6%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">6.5.2.</span> <span class="nav-text">2、从一个顶点到其余各顶点的最短路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">6.6.</span> <span class="nav-text">8.6、拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7%E3%80%81AOE%E7%BD%91"><span class="nav-number">6.7.</span> <span class="nav-text">8.7、AOE网</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81AOE"><span class="nav-number">6.7.1.</span> <span class="nav-text">1、AOE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">6.7.2.</span> <span class="nav-text">2、关键路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%9F%A5%E6%89%BE"><span class="nav-number">7.</span> <span class="nav-text">七、查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2%E3%80%81%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-number">7.0.1.</span> <span class="nav-text">7.2、顺序查找和折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3%E3%80%81%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE"><span class="nav-number">7.0.2.</span> <span class="nav-text">7.3、树形查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4%E3%80%81B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="nav-number">7.0.3.</span> <span class="nav-text">7.4、B树和B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-number">7.0.4.</span> <span class="nav-text">7.5、散列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1%E3%80%81"><span class="nav-number">7.1.</span> <span class="nav-text">9.1、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">7.2.</span> <span class="nav-text">9.4、哈希表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">7.2.1.</span> <span class="nav-text">1、哈希表的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E9%80%82%E5%90%88%E6%83%85%E5%86%B5"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">①、哈希表适合情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E3%80%81%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">②、几个概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.2.1.3.</span> <span class="nav-text">③、哈希表设计</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">8.</span> <span class="nav-text">十一、数组的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1%E3%80%81%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="nav-number">8.1.</span> <span class="nav-text">11.1、线性查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">8.2.</span> <span class="nav-text">11.2、二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%8E%92%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">八、排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">9.1.</span> <span class="nav-text">8.1、排序的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">9.2.</span> <span class="nav-text">8.2、冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">9.3.</span> <span class="nav-text">8.3、选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.</span> <span class="nav-text">8.4、插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.1.</span> <span class="nav-text">1、直接插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.2.</span> <span class="nav-text">2、折半插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.3.</span> <span class="nav-text">3、希尔排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">9.5.</span> <span class="nav-text">8.5、堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">9.6.</span> <span class="nav-text">8.6、归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">9.7.</span> <span class="nav-text">8.7、基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-8%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">9.8.</span> <span class="nav-text">8.8、快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">9.8.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">9.8.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.8.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6%E3%80%81%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-number">9.8.4.</span> <span class="nav-text">8.6、各种内部排序算法的比较和应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7%E3%80%81%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">9.8.5.</span> <span class="nav-text">8.7、外部排序</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李新乾"
      src="/images/cat.png">
  <p class="site-author-name" itemprop="name">李新乾</p>
  <div class="site-description" itemprop="description">命由我做，福自己求</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lxq-02" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lxq-02" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://chatgpt.com/" title="Chatgpt → https:&#x2F;&#x2F;chatgpt.com" rel="noopener" target="_blank"><i class="fas fa-robot fa-fw"></i>Chatgpt</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      链接网站
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mail.qq.com/" title="https:&#x2F;&#x2F;mail.qq.com" rel="noopener" target="_blank">QQ邮箱</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://outlook.live.com/" title="https:&#x2F;&#x2F;outlook.live.com" rel="noopener" target="_blank">Outlook</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fishc.com.cn/" title="https:&#x2F;&#x2F;fishc.com.cn" rel="noopener" target="_blank">鱼C论坛</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李新乾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset);
            clearInterval(int);
        }
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据
            clearInterval(int); // 停止检测
        }
    }

});
</script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
